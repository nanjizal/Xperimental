// Generated by Haxe 4.0.0-preview.5+83d9c11
(function () { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
var Main = function() {
	this.appColors = [0,16711680,16744192,16776960,65280,255,4915330,9699539,4473924,3355443,789516,1118481,16777215];
	this.showMouse = true;
	this.mouseIsDown = false;
	this.places = 12;
	this.points = 7;
	var t = [];
	var this2;
	if(t == null) {
		var t1 = [];
		var this3 = t1 == null ? trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new([]) : t1;
		this2 = this3;
	} else {
		this2 = t;
	}
	var this1 = this2;
	this.triangles = this1;
	this.lineWidth = 0.3;
	this.circleSize = 5.;
	var this11;
	var canvas = window.document.createElement("canvas");
	var dom = canvas;
	var style = dom.style;
	style.paddingLeft = "0px";
	style.paddingTop = "0px";
	style.left = "0px";
	style.top = "0px";
	style.position = "absolute";
	this11 = canvas;
	this.canvas = this11;
	this.distance = 50;
	var doc = window.document;
	this.canvas.width = 2048;
	this.canvas.height = 1536;
	this.centreX = this.canvas.width / 2;
	this.centreY = this.canvas.height / 2;
	doc.body.appendChild(this.canvas);
	this.surface = new justDrawing_Surface(this.canvas.getContext("2d",null));
	this.shapes = new trilateral_polys_Shapes(this.triangles,this.appColors);
	var this12 = { x : 100., y : 100., z : 0., w : 1.};
	this.mousePos = this12;
	this.innerDemo = new constraints_demo_Inner(100,100,this.distance);
	this.chainDemo = new constraints_demo_Chain(this.centreX,this.centreY,this.points,this.distance);
	this.fabrikDemo = new constraints_demo_Fabrik(this.centreX / 2,this.centreY / 2,this.points,this.distance);
	var collisionArea = 300;
	this.collisionDemo = new constraints_demo_Collision(this.centreX,this.centreY,this.places,this.circleSize,collisionArea,this.distance);
	htmlHelper_tools_AnimateTimer.onFrame = $bind(this,this.render);
	if(htmlHelper_tools_AnimateTimer.s == null) {
		htmlHelper_tools_AnimateTimer.s = window.document.createElement("style");
		htmlHelper_tools_AnimateTimer.s.innerHTML = "@keyframes spin { from { transform:rotate( 0deg ); } to { transform:rotate( 360deg ); } }";
		window.document.getElementsByTagName("head")[0].appendChild(htmlHelper_tools_AnimateTimer.s);
		htmlHelper_tools_AnimateTimer.s.animation = "spin 1s linear infinite";
		htmlHelper_tools_AnimateTimer.loop(60.0);
	}
	doc.onmousemove = $bind(this,this.mouseMove);
	doc.onmousedown = $bind(this,this.mouseDown);
	doc.onmouseup = $bind(this,this.mouseUp);
};
Main.__name__ = true;
Main.main = function() {
	new Main();
};
Main.prototype = {
	setupExperiments: function() {
		this.innerDemo = new constraints_demo_Inner(100,100,this.distance);
		this.chainDemo = new constraints_demo_Chain(this.centreX,this.centreY,this.points,this.distance);
		this.fabrikDemo = new constraints_demo_Fabrik(this.centreX / 2,this.centreY / 2,this.points,this.distance);
		var collisionArea = 300;
		this.collisionDemo = new constraints_demo_Collision(this.centreX,this.centreY,this.places,this.circleSize,collisionArea,this.distance);
	}
	,findColorID: function(col) {
		return this.appColors.indexOf(col);
	}
	,circleOutline: function(x,y,radius,color) {
		var this1 = this.triangles;
		var gamma = 2 * Math.PI;
		var t = [];
		var this2;
		if(t == null) {
			var t1 = [];
			var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this2 = this3;
		} else {
			this2 = t;
		}
		var this4 = this2;
		var out = this4;
		var pi = Math.PI;
		var step = pi * 2 / 36;
		var dif;
		switch(trilateral_angle_DifferencePreference.CLOCKWISE._hx_index) {
		case 0:
			var f;
			if(0 > Math.PI) {
				f = 0;
			} else {
				var a = 0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this5 = f;
			var za = this5;
			var f1;
			if(gamma >= 0 && gamma > Math.PI) {
				f1 = gamma;
			} else {
				var a1 = gamma % (2 * Math.PI);
				f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
			}
			var this6 = f1;
			var zb = this6;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(0 - gamma);
			var clockwise = 0 < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f2;
			if(0 > Math.PI) {
				f2 = 0;
			} else {
				var a2 = 0 % (2 * Math.PI);
				f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
			}
			var this7 = f2;
			var za1 = this7;
			var f3;
			if(gamma >= 0 && gamma > Math.PI) {
				f3 = gamma;
			} else {
				var a3 = gamma % (2 * Math.PI);
				f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
			}
			var this8 = f3;
			var zb1 = this8;
			var fa1 = za1;
			var fb1 = zb1;
			var theta1 = Math.abs(0 - gamma);
			var clockwise1 = 0 < gamma;
			var dif2 = clockwise1 ? theta1 : -theta1;
			dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
			break;
		case 2:
			var f4;
			if(0 > Math.PI) {
				f4 = 0;
			} else {
				var a4 = 0 % (2 * Math.PI);
				f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
			}
			var this9 = f4;
			var za2 = this9;
			var f5;
			if(gamma >= 0 && gamma > Math.PI) {
				f5 = gamma;
			} else {
				var a5 = gamma % (2 * Math.PI);
				f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
			}
			var this10 = f5;
			var zb2 = this10;
			var fa2 = 0;
			var fb2 = gamma;
			var theta2 = Math.abs(0 - gamma);
			var smallest = theta2 <= Math.PI;
			var clockwise2 = 0 < gamma;
			var dif3 = clockwise2 ? theta2 : -theta2;
			dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
			break;
		case 3:
			var f6;
			if(0 > Math.PI) {
				f6 = 0;
			} else {
				var a6 = 0 % (2 * Math.PI);
				f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
			}
			var this11 = f6;
			var za3 = this11;
			var f7;
			if(gamma >= 0 && gamma > Math.PI) {
				f7 = gamma;
			} else {
				var a7 = gamma % (2 * Math.PI);
				f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
			}
			var this12 = f7;
			var zb3 = this12;
			var fa3 = 0;
			var fb3 = gamma;
			var theta3 = Math.abs(0 - gamma);
			var largest = theta3 > Math.PI;
			var clockwise3 = 0 < gamma;
			var dif4 = clockwise3 ? theta3 : -theta3;
			dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step1 = dif / totalSteps;
		var angle = 0;
		var cx;
		var cy;
		var bx = 0;
		var by = 0;
		var dx = 0;
		var dy = 0;
		var ex = 0;
		var ey = 0;
		var r2 = radius - 1;
		var _g = 0;
		var _g1 = totalSteps + 1;
		while(_g < _g1) {
			var i = _g++;
			cx = x + radius * Math.sin(angle);
			cy = y + radius * Math.cos(angle);
			ex = x + r2 * Math.sin(angle);
			ey = y + r2 * Math.cos(angle);
			if(i != 0) {
				var t0 = new trilateral_tri_Trilateral(dx,dy,bx,by,cx,cy);
				var t11 = new trilateral_tri_Trilateral(dx,dy,cx,cy,ex,ey);
				out[out.length] = t0;
				out[out.length] = t11;
			}
			angle += step1;
			bx = cx;
			by = cy;
			dx = ex;
			dy = ey;
		}
		var triArr = out;
		var colorID = this.appColors.indexOf(color);
		var tri;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t2 = triArr[_g2];
			++_g2;
			if(t2 != null) {
				var t3 = Object.create(trilateral_tri_Triangle.prototype);
				t3.id = 0;
				t3.ax = t2.ax;
				t3.ay = t2.ay;
				t3.bx = t2.bx;
				t3.by = t2.by;
				t3.cx = t2.cx;
				t3.cy = t2.cy;
				t3.mark = t2.mark;
				t3.depth = 0;
				t3.alpha = 1.;
				t3.colorID = colorID;
				t3.colorA = colorID;
				t3.colorB = colorID;
				t3.colorC = colorID;
				t3.windingAdjusted = t2.windingAdjusted;
				tri = t3;
				this1[this1.length] = tri;
			}
		}
	}
	,createSpot: function(x,y,color) {
		var _this = this.shapes;
		var radius = this.circleSize;
		var color1 = this.appColors.indexOf(color);
		var this1 = _this.triangles;
		var id = _this.refCount++;
		var t = [];
		var this2;
		if(t == null) {
			var t1 = [];
			var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this2 = this3;
		} else {
			this2 = t;
		}
		var this4 = this2;
		var out = this4;
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx;
		var by;
		var cx;
		var cy;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = x + radius * Math.sin(theta);
			by = y + radius * Math.cos(theta);
			theta += step;
			cx = x + radius * Math.sin(theta);
			cy = y + radius * Math.cos(theta);
			var tri = new trilateral_tri_Trilateral(x,y,bx,by,cx,cy);
			out[out.length] = tri;
		}
		var triArr = out;
		var tri1;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t2 = triArr[_g2];
			++_g2;
			if(t2 != null) {
				var t3 = Object.create(trilateral_tri_Triangle.prototype);
				t3.id = id;
				t3.ax = t2.ax;
				t3.ay = t2.ay;
				t3.bx = t2.bx;
				t3.by = t2.by;
				t3.cx = t2.cx;
				t3.cy = t2.cy;
				t3.mark = t2.mark;
				t3.depth = 0;
				t3.alpha = 1.;
				t3.colorID = color1;
				t3.colorA = color1;
				t3.colorB = color1;
				t3.colorC = color1;
				t3.windingAdjusted = t2.windingAdjusted;
				tri1 = t3;
				this1[this1.length] = tri1;
			}
		}
	}
	,createCircle: function(x,y,color) {
		var radius = this.distance;
		var this1 = this.triangles;
		var gamma = 2 * Math.PI;
		var t = [];
		var this2;
		if(t == null) {
			var t1 = [];
			var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this2 = this3;
		} else {
			this2 = t;
		}
		var this4 = this2;
		var out = this4;
		var pi = Math.PI;
		var step = pi * 2 / 36;
		var dif;
		switch(trilateral_angle_DifferencePreference.CLOCKWISE._hx_index) {
		case 0:
			var f;
			if(0 > Math.PI) {
				f = 0;
			} else {
				var a = 0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this5 = f;
			var za = this5;
			var f1;
			if(gamma >= 0 && gamma > Math.PI) {
				f1 = gamma;
			} else {
				var a1 = gamma % (2 * Math.PI);
				f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
			}
			var this6 = f1;
			var zb = this6;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(0 - gamma);
			var clockwise = 0 < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f2;
			if(0 > Math.PI) {
				f2 = 0;
			} else {
				var a2 = 0 % (2 * Math.PI);
				f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
			}
			var this7 = f2;
			var za1 = this7;
			var f3;
			if(gamma >= 0 && gamma > Math.PI) {
				f3 = gamma;
			} else {
				var a3 = gamma % (2 * Math.PI);
				f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
			}
			var this8 = f3;
			var zb1 = this8;
			var fa1 = za1;
			var fb1 = zb1;
			var theta1 = Math.abs(0 - gamma);
			var clockwise1 = 0 < gamma;
			var dif2 = clockwise1 ? theta1 : -theta1;
			dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
			break;
		case 2:
			var f4;
			if(0 > Math.PI) {
				f4 = 0;
			} else {
				var a4 = 0 % (2 * Math.PI);
				f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
			}
			var this9 = f4;
			var za2 = this9;
			var f5;
			if(gamma >= 0 && gamma > Math.PI) {
				f5 = gamma;
			} else {
				var a5 = gamma % (2 * Math.PI);
				f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
			}
			var this10 = f5;
			var zb2 = this10;
			var fa2 = 0;
			var fb2 = gamma;
			var theta2 = Math.abs(0 - gamma);
			var smallest = theta2 <= Math.PI;
			var clockwise2 = 0 < gamma;
			var dif3 = clockwise2 ? theta2 : -theta2;
			dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
			break;
		case 3:
			var f6;
			if(0 > Math.PI) {
				f6 = 0;
			} else {
				var a6 = 0 % (2 * Math.PI);
				f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
			}
			var this11 = f6;
			var za3 = this11;
			var f7;
			if(gamma >= 0 && gamma > Math.PI) {
				f7 = gamma;
			} else {
				var a7 = gamma % (2 * Math.PI);
				f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
			}
			var this12 = f7;
			var zb3 = this12;
			var fa3 = 0;
			var fb3 = gamma;
			var theta3 = Math.abs(0 - gamma);
			var largest = theta3 > Math.PI;
			var clockwise3 = 0 < gamma;
			var dif4 = clockwise3 ? theta3 : -theta3;
			dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step1 = dif / totalSteps;
		var angle = 0;
		var cx;
		var cy;
		var bx = 0;
		var by = 0;
		var dx = 0;
		var dy = 0;
		var ex = 0;
		var ey = 0;
		var r2 = radius - 1;
		var _g = 0;
		var _g1 = totalSteps + 1;
		while(_g < _g1) {
			var i = _g++;
			cx = x + radius * Math.sin(angle);
			cy = y + radius * Math.cos(angle);
			ex = x + r2 * Math.sin(angle);
			ey = y + r2 * Math.cos(angle);
			if(i != 0) {
				var t0 = new trilateral_tri_Trilateral(dx,dy,bx,by,cx,cy);
				var t11 = new trilateral_tri_Trilateral(dx,dy,cx,cy,ex,ey);
				out[out.length] = t0;
				out[out.length] = t11;
			}
			angle += step1;
			bx = cx;
			by = cy;
			dx = ex;
			dy = ey;
		}
		var triArr = out;
		var colorID = this.appColors.indexOf(color);
		var tri;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t2 = triArr[_g2];
			++_g2;
			if(t2 != null) {
				var t3 = Object.create(trilateral_tri_Triangle.prototype);
				t3.id = 0;
				t3.ax = t2.ax;
				t3.ay = t2.ay;
				t3.bx = t2.bx;
				t3.by = t2.by;
				t3.cx = t2.cx;
				t3.cy = t2.cy;
				t3.mark = t2.mark;
				t3.depth = 0;
				t3.alpha = 1.;
				t3.colorID = colorID;
				t3.colorA = colorID;
				t3.colorB = colorID;
				t3.colorC = colorID;
				t3.windingAdjusted = t2.windingAdjusted;
				tri = t3;
				this1[this1.length] = tri;
			}
		}
	}
	,mouseDown: function(e) {
		this.mouseIsDown = true;
		var this1 = { x : e.clientX, y : e.clientY, z : 0., w : 1.};
		this.mousePos = this1;
	}
	,mouseMove: function(e) {
		if(this.mouseIsDown) {
			var this1 = { x : e.clientX, y : e.clientY, z : 0., w : 1.};
			this.mousePos = this1;
		}
	}
	,mouseCoord: function(e) {
		var this1 = { x : e.clientX, y : e.clientY, z : 0., w : 1.};
		this.mousePos = this1;
	}
	,mouseUp: function(e) {
		var this1 = { x : e.clientX, y : e.clientY, z : 0., w : 1.};
		this.mousePos = this1;
		this.mouseIsDown = false;
	}
	,clear: function() {
		this.triangles = [];
		this.shapes.triangles = this.triangles;
	}
	,simple: function() {
		var _this = this.innerDemo;
		var anchor = this.mousePos;
		var b = _this.point;
		var toNext_x = anchor.x - b.x;
		var toNext_y = anchor.y - b.y;
		var toNext_z = anchor.z - b.z;
		var toNext_w = anchor.w - b.w;
		if(Math.sqrt(toNext_x * toNext_x + toNext_y * toNext_y + toNext_z * toNext_z + toNext_w * toNext_w) > _this.distance) {
			var this1 = _this.point;
			var distance = _this.distance;
			var a_x = this1.x - anchor.x;
			var a_y = this1.y - anchor.y;
			var a_z = this1.z - anchor.z;
			var a_w = this1.w - anchor.w;
			var currentLength = Math.sqrt(a_x * a_x + a_y * a_y + a_z * a_z + a_w * a_w);
			if(currentLength != 0.) {
				var mul = 1. / currentLength;
				a_x *= mul;
				a_y *= mul;
				a_z *= mul;
				a_w *= mul;
				var tmp = a_x * a_x + a_y * a_y + a_z * a_z + a_w * a_w;
			}
			var a_x1 = a_x * distance;
			var a_y1 = a_y * distance;
			var a_z1 = a_z * distance;
			var a_w1 = a_w * distance;
			var this2 = { x : a_x1 + anchor.x, y : a_y1 + anchor.y, z : a_z1 + anchor.z, w : a_w1 + anchor.w};
			_this.point = this2;
			console.log("constraints/demo/Inner.hx:19:",_this.point.x + " " + _this.point.y);
		}
		var x = this.innerDemo.point.x;
		var y = this.innerDemo.point.y;
		var _this1 = this.shapes;
		var radius = this.circleSize;
		var color = this.appColors.indexOf(16777215);
		var this3 = _this1.triangles;
		var id = _this1.refCount++;
		var t = [];
		var this4;
		if(t == null) {
			var t1 = [];
			var this5 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this4 = this5;
		} else {
			this4 = t;
		}
		var this6 = this4;
		var out = this6;
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx;
		var by;
		var cx;
		var cy;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = x + radius * Math.sin(theta);
			by = y + radius * Math.cos(theta);
			theta += step;
			cx = x + radius * Math.sin(theta);
			cy = y + radius * Math.cos(theta);
			var tri = new trilateral_tri_Trilateral(x,y,bx,by,cx,cy);
			out[out.length] = tri;
		}
		var triArr = out;
		var tri1;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t2 = triArr[_g2];
			++_g2;
			if(t2 != null) {
				var t3 = Object.create(trilateral_tri_Triangle.prototype);
				t3.id = id;
				t3.ax = t2.ax;
				t3.ay = t2.ay;
				t3.bx = t2.bx;
				t3.by = t2.by;
				t3.cx = t2.cx;
				t3.cy = t2.cy;
				t3.mark = t2.mark;
				t3.depth = 0;
				t3.alpha = 1.;
				t3.colorID = color;
				t3.colorA = color;
				t3.colorB = color;
				t3.colorC = color;
				t3.windingAdjusted = t2.windingAdjusted;
				tri1 = t3;
				this3[this3.length] = tri1;
			}
		}
	}
	,chain: function() {
		var _gthis = this;
		var jointRender = function(i,joint) {
			var _this = _gthis.shapes;
			var x = joint.x;
			var y = joint.y;
			var radius = _gthis.circleSize;
			var color = _gthis.appColors.indexOf(16711680) + i;
			var this1 = _this.triangles;
			var id = _this.refCount++;
			var t = [];
			var this2;
			if(t == null) {
				var t1 = [];
				var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
				this2 = this3;
			} else {
				this2 = t;
			}
			var this4 = this2;
			var out = this4;
			var pi = Math.PI;
			var theta = pi / 2;
			var step = pi * 2 / 36;
			var bx;
			var by;
			var cx;
			var cy;
			var _g = 0;
			var _g1 = 36;
			while(_g < _g1) {
				var i1 = _g++;
				bx = x + radius * Math.sin(theta);
				by = y + radius * Math.cos(theta);
				theta += step;
				cx = x + radius * Math.sin(theta);
				cy = y + radius * Math.cos(theta);
				var tri = new trilateral_tri_Trilateral(x,y,bx,by,cx,cy);
				out[out.length] = tri;
			}
			var triArr = out;
			var tri1;
			var _g2 = 0;
			while(_g2 < triArr.length) {
				var t2 = triArr[_g2];
				++_g2;
				if(t2 != null) {
					var t3 = Object.create(trilateral_tri_Triangle.prototype);
					t3.id = id;
					t3.ax = t2.ax;
					t3.ay = t2.ay;
					t3.bx = t2.bx;
					t3.by = t2.by;
					t3.cx = t2.cx;
					t3.cy = t2.cy;
					t3.mark = t2.mark;
					t3.depth = 0;
					t3.alpha = 1.;
					t3.colorID = color;
					t3.colorA = color;
					t3.colorB = color;
					t3.colorC = color;
					t3.windingAdjusted = t2.windingAdjusted;
					tri1 = t3;
					this1[this1.length] = tri1;
				}
			}
			return _this.refCount - 1;
		};
		var _this1 = this.chainDemo;
		var anchor = this.mousePos;
		var joint1 = _this1.joints[0];
		joint1.x = anchor.x;
		joint1.y = anchor.y;
		jointRender(0,joint1);
		var _g3 = 1;
		var _g11 = _this1.points;
		while(_g3 < _g11) {
			var i2 = _g3++;
			var this5 = _this1.joints[i2];
			var anchor1 = _this1.joints[i2 - 1];
			var distance = _this1.distance;
			var a_x = this5.x - anchor1.x;
			var a_y = this5.y - anchor1.y;
			var a_z = this5.z - anchor1.z;
			var a_w = this5.w - anchor1.w;
			var currentLength = Math.sqrt(a_x * a_x + a_y * a_y + a_z * a_z + a_w * a_w);
			if(currentLength != 0.) {
				var mul = 1. / currentLength;
				a_x *= mul;
				a_y *= mul;
				a_z *= mul;
				a_w *= mul;
				var tmp = a_x * a_x + a_y * a_y + a_z * a_z + a_w * a_w;
			}
			var a_x1 = a_x * distance;
			var a_y1 = a_y * distance;
			var a_z1 = a_z * distance;
			var a_w1 = a_w * distance;
			var this6 = { x : a_x1 + anchor1.x, y : a_y1 + anchor1.y, z : a_z1 + anchor1.z, w : a_w1 + anchor1.w};
			_this1.joints[i2] = this6;
			joint1 = _this1.joints[i2];
			jointRender(i2,joint1);
		}
	}
	,fabrik: function() {
		var _gthis = this;
		var jointRender = function(i,joint) {
			var _this = _gthis.shapes;
			var x = joint.x;
			var y = joint.y;
			var radius = _gthis.circleSize;
			var color = _gthis.appColors.indexOf(16711680) + i;
			var this1 = _this.triangles;
			var id = _this.refCount++;
			var t = [];
			var this2;
			if(t == null) {
				var t1 = [];
				var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
				this2 = this3;
			} else {
				this2 = t;
			}
			var this4 = this2;
			var out = this4;
			var pi = Math.PI;
			var theta = pi / 2;
			var step = pi * 2 / 36;
			var bx;
			var by;
			var cx;
			var cy;
			var _g = 0;
			var _g1 = 36;
			while(_g < _g1) {
				var i1 = _g++;
				bx = x + radius * Math.sin(theta);
				by = y + radius * Math.cos(theta);
				theta += step;
				cx = x + radius * Math.sin(theta);
				cy = y + radius * Math.cos(theta);
				var tri = new trilateral_tri_Trilateral(x,y,bx,by,cx,cy);
				out[out.length] = tri;
			}
			var triArr = out;
			var tri1;
			var _g2 = 0;
			while(_g2 < triArr.length) {
				var t2 = triArr[_g2];
				++_g2;
				if(t2 != null) {
					var t3 = Object.create(trilateral_tri_Triangle.prototype);
					t3.id = id;
					t3.ax = t2.ax;
					t3.ay = t2.ay;
					t3.bx = t2.bx;
					t3.by = t2.by;
					t3.cx = t2.cx;
					t3.cy = t2.cy;
					t3.mark = t2.mark;
					t3.depth = 0;
					t3.alpha = 1.;
					t3.colorID = color;
					t3.colorA = color;
					t3.colorB = color;
					t3.colorC = color;
					t3.windingAdjusted = t2.windingAdjusted;
					tri1 = t3;
					this1[this1.length] = tri1;
				}
			}
			return _this.refCount - 1;
		};
		var _this1 = this.fabrikDemo;
		var anchor = this.mousePos;
		var joint1 = _this1.joints[0];
		joint1.x = anchor.x;
		joint1.y = anchor.y;
		jointRender(0,joint1);
		var _g3 = 1;
		var _g11 = _this1.points;
		while(_g3 < _g11) {
			var i2 = _g3++;
			var this5 = _this1.joints[i2];
			var anchor1 = _this1.joints[i2 - 1];
			var distance = _this1.distance;
			var a_x = this5.x - anchor1.x;
			var a_y = this5.y - anchor1.y;
			var a_z = this5.z - anchor1.z;
			var a_w = this5.w - anchor1.w;
			var currentLength = Math.sqrt(a_x * a_x + a_y * a_y + a_z * a_z + a_w * a_w);
			if(currentLength != 0.) {
				var mul = 1. / currentLength;
				a_x *= mul;
				a_y *= mul;
				a_z *= mul;
				a_w *= mul;
				var tmp = a_x * a_x + a_y * a_y + a_z * a_z + a_w * a_w;
			}
			var a_x1 = a_x * distance;
			var a_y1 = a_y * distance;
			var a_z1 = a_z * distance;
			var a_w1 = a_w * distance;
			var this6 = { x : a_x1 + anchor1.x, y : a_y1 + anchor1.y, z : a_z1 + anchor1.z, w : a_w1 + anchor1.w};
			_this1.joints[i2] = this6;
		}
		var j;
		var joint2 = _this1.joints[_this1.points - 1];
		joint2.x = _this1.x;
		joint2.y = _this1.y;
		jointRender(_this1.points - 1,joint2);
		var _g21 = 1;
		var _g31 = _this1.points;
		while(_g21 < _g31) {
			var i3 = _g21++;
			j = _this1.points - i3;
			var this7 = _this1.joints[j - 1];
			var anchor2 = _this1.joints[j];
			var distance1 = _this1.distance;
			var a_x2 = this7.x - anchor2.x;
			var a_y2 = this7.y - anchor2.y;
			var a_z2 = this7.z - anchor2.z;
			var a_w2 = this7.w - anchor2.w;
			var currentLength1 = Math.sqrt(a_x2 * a_x2 + a_y2 * a_y2 + a_z2 * a_z2 + a_w2 * a_w2);
			if(currentLength1 != 0.) {
				var mul1 = 1. / currentLength1;
				a_x2 *= mul1;
				a_y2 *= mul1;
				a_z2 *= mul1;
				a_w2 *= mul1;
				var tmp1 = a_x2 * a_x2 + a_y2 * a_y2 + a_z2 * a_z2 + a_w2 * a_w2;
			}
			var a_x3 = a_x2 * distance1;
			var a_y3 = a_y2 * distance1;
			var a_z3 = a_z2 * distance1;
			var a_w3 = a_w2 * distance1;
			var this8 = { x : a_x3 + anchor2.x, y : a_y3 + anchor2.y, z : a_z3 + anchor2.z, w : a_w3 + anchor2.w};
			_this1.joints[j - 1] = this8;
			joint2 = _this1.joints[j - 1];
			jointRender(j,joint2);
		}
	}
	,collision: function() {
		var _gthis = this;
		var jointRender = function(i,joint) {
			var col = _gthis.appColors.indexOf(16711680) + i;
			if(col > 7) {
				col -= 7;
			}
			var _this = _gthis.shapes;
			var x = joint.x;
			var y = joint.y;
			var radius = _gthis.circleSize;
			var this1 = _this.triangles;
			var id = _this.refCount++;
			var t = [];
			var this2;
			if(t == null) {
				var t1 = [];
				var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
				this2 = this3;
			} else {
				this2 = t;
			}
			var this4 = this2;
			var out = this4;
			var pi = Math.PI;
			var theta = pi / 2;
			var step = pi * 2 / 36;
			var bx;
			var by;
			var cx;
			var cy;
			var _g = 0;
			var _g1 = 36;
			while(_g < _g1) {
				var i1 = _g++;
				bx = x + radius * Math.sin(theta);
				by = y + radius * Math.cos(theta);
				theta += step;
				cx = x + radius * Math.sin(theta);
				cy = y + radius * Math.cos(theta);
				var tri = new trilateral_tri_Trilateral(x,y,bx,by,cx,cy);
				out[out.length] = tri;
			}
			var triArr = out;
			var tri1;
			var _g2 = 0;
			while(_g2 < triArr.length) {
				var t2 = triArr[_g2];
				++_g2;
				if(t2 != null) {
					var t3 = Object.create(trilateral_tri_Triangle.prototype);
					t3.id = id;
					t3.ax = t2.ax;
					t3.ay = t2.ay;
					t3.bx = t2.bx;
					t3.by = t2.by;
					t3.cx = t2.cx;
					t3.cy = t2.cy;
					t3.mark = t2.mark;
					t3.depth = 0;
					t3.alpha = 1.;
					t3.colorID = col;
					t3.colorA = col;
					t3.colorB = col;
					t3.colorC = col;
					t3.windingAdjusted = t2.windingAdjusted;
					tri1 = t3;
					this1[this1.length] = tri1;
				}
			}
			return _this.refCount - 1;
		};
		var _this1 = this.collisionDemo;
		var anchor = this.mousePos;
		var joint1;
		var mouseEdge = 2;
		var radius1 = _this1.distance + mouseEdge + _this1.circleSize / 2;
		var _g3 = 0;
		var _g11 = _this1.points;
		while(_g3 < _g11) {
			var i2 = _g3++;
			joint1 = _this1.joints[i2];
			var toNext_x = anchor.x - joint1.x;
			var toNext_y = anchor.y - joint1.y;
			var toNext_z = anchor.z - joint1.z;
			var toNext_w = anchor.w - joint1.w;
			if(Math.sqrt(toNext_x * toNext_x + toNext_y * toNext_y + toNext_z * toNext_z + toNext_w * toNext_w) < radius1) {
				var currentLength = Math.sqrt(toNext_x * toNext_x + toNext_y * toNext_y + toNext_z * toNext_z + toNext_w * toNext_w);
				if(currentLength != 0.) {
					var mul = radius1 / currentLength;
					toNext_x *= mul;
					toNext_y *= mul;
					toNext_z *= mul;
					toNext_w *= mul;
					var tmp = toNext_x * toNext_x + toNext_y * toNext_y + toNext_z * toNext_z + toNext_w * toNext_w;
				}
				var a_x = anchor.x - joint1.x;
				var a_y = anchor.y - joint1.y;
				var a_z = anchor.z - joint1.z;
				var a_w = anchor.w - joint1.w;
				var offset_x = a_x - toNext_x;
				var offset_y = a_y - toNext_y;
				var offset_z = a_z - toNext_z;
				var offset_w = a_w - toNext_w;
				var this5 = { x : joint1.x + offset_x, y : joint1.y + offset_y, z : joint1.z + offset_z, w : joint1.w + offset_w};
				_this1.joints[i2] = this5;
			}
		}
		var other;
		var _g21 = 0;
		var _g31 = _this1.points;
		while(_g21 < _g31) {
			var i3 = _g21++;
			var _g22 = i3;
			var _g32 = _this1.points;
			while(_g22 < _g32) {
				var j = _g22++;
				joint1 = _this1.joints[i3];
				other = _this1.joints[j];
				var toNext_x1 = other.x - joint1.x;
				var toNext_y1 = other.y - joint1.y;
				var toNext_z1 = other.z - joint1.z;
				var toNext_w1 = other.w - joint1.w;
				if(Math.sqrt(toNext_x1 * toNext_x1 + toNext_y1 * toNext_y1 + toNext_z1 * toNext_z1 + toNext_w1 * toNext_w1) < _this1.circleSize * 2) {
					var currentLength1 = Math.sqrt(toNext_x1 * toNext_x1 + toNext_y1 * toNext_y1 + toNext_z1 * toNext_z1 + toNext_w1 * toNext_w1);
					if(currentLength1 != 0.) {
						var mul1 = _this1.circleSize * 2 / currentLength1;
						toNext_x1 *= mul1;
						toNext_y1 *= mul1;
						toNext_z1 *= mul1;
						toNext_w1 *= mul1;
						var tmp1 = toNext_x1 * toNext_x1 + toNext_y1 * toNext_y1 + toNext_z1 * toNext_z1 + toNext_w1 * toNext_w1;
					}
					var a_x1 = other.x - joint1.x;
					var a_y1 = other.y - joint1.y;
					var a_z1 = other.z - joint1.z;
					var a_w1 = other.w - joint1.w;
					var b_x = toNext_x1 * 0.5;
					var b_y = toNext_y1 * 0.5;
					var b_z = toNext_z1 * 0.5;
					var b_w = toNext_w1 * 0.5;
					var offset_x1 = a_x1 - b_x;
					var offset_y1 = a_y1 - b_y;
					var offset_z1 = a_z1 - b_z;
					var offset_w1 = a_w1 - b_w;
					var this6 = { x : joint1.x + offset_x1, y : joint1.y + offset_y1, z : joint1.z + offset_z1, w : joint1.w + offset_w1};
					_this1.joints[i3] = this6;
					var this7 = { x : other.x - offset_x1, y : other.y - offset_y1, z : other.z - offset_z1, w : other.w - offset_w1};
					_this1.joints[j] = this7;
				}
			}
		}
		var _g4 = 0;
		var _g5 = _this1.points;
		while(_g4 < _g5) {
			var i4 = _g4++;
			jointRender(i4,_this1.joints[i4]);
		}
	}
	,render: function(i) {
		this.triangles = [];
		this.shapes.triangles = this.triangles;
		var x = this.mousePos.x;
		var y = this.mousePos.y;
		var radius = this.distance;
		var this1 = this.triangles;
		var gamma = 2 * Math.PI;
		var t = [];
		var this2;
		if(t == null) {
			var t1 = [];
			var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this2 = this3;
		} else {
			this2 = t;
		}
		var this4 = this2;
		var out = this4;
		var pi = Math.PI;
		var step = pi * 2 / 36;
		var dif;
		switch(trilateral_angle_DifferencePreference.CLOCKWISE._hx_index) {
		case 0:
			var f;
			if(0 > Math.PI) {
				f = 0;
			} else {
				var a = 0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this5 = f;
			var za = this5;
			var f1;
			if(gamma >= 0 && gamma > Math.PI) {
				f1 = gamma;
			} else {
				var a1 = gamma % (2 * Math.PI);
				f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
			}
			var this6 = f1;
			var zb = this6;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(0 - gamma);
			var clockwise = 0 < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f2;
			if(0 > Math.PI) {
				f2 = 0;
			} else {
				var a2 = 0 % (2 * Math.PI);
				f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
			}
			var this7 = f2;
			var za1 = this7;
			var f3;
			if(gamma >= 0 && gamma > Math.PI) {
				f3 = gamma;
			} else {
				var a3 = gamma % (2 * Math.PI);
				f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
			}
			var this8 = f3;
			var zb1 = this8;
			var fa1 = za1;
			var fb1 = zb1;
			var theta1 = Math.abs(0 - gamma);
			var clockwise1 = 0 < gamma;
			var dif2 = clockwise1 ? theta1 : -theta1;
			dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
			break;
		case 2:
			var f4;
			if(0 > Math.PI) {
				f4 = 0;
			} else {
				var a4 = 0 % (2 * Math.PI);
				f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
			}
			var this9 = f4;
			var za2 = this9;
			var f5;
			if(gamma >= 0 && gamma > Math.PI) {
				f5 = gamma;
			} else {
				var a5 = gamma % (2 * Math.PI);
				f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
			}
			var this10 = f5;
			var zb2 = this10;
			var fa2 = 0;
			var fb2 = gamma;
			var theta2 = Math.abs(0 - gamma);
			var smallest = theta2 <= Math.PI;
			var clockwise2 = 0 < gamma;
			var dif3 = clockwise2 ? theta2 : -theta2;
			dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
			break;
		case 3:
			var f6;
			if(0 > Math.PI) {
				f6 = 0;
			} else {
				var a6 = 0 % (2 * Math.PI);
				f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
			}
			var this11 = f6;
			var za3 = this11;
			var f7;
			if(gamma >= 0 && gamma > Math.PI) {
				f7 = gamma;
			} else {
				var a7 = gamma % (2 * Math.PI);
				f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
			}
			var this12 = f7;
			var zb3 = this12;
			var fa3 = 0;
			var fb3 = gamma;
			var theta3 = Math.abs(0 - gamma);
			var largest = theta3 > Math.PI;
			var clockwise3 = 0 < gamma;
			var dif4 = clockwise3 ? theta3 : -theta3;
			dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step1 = dif / totalSteps;
		var angle = 0;
		var cx;
		var cy;
		var bx = 0;
		var by = 0;
		var dx = 0;
		var dy = 0;
		var ex = 0;
		var ey = 0;
		var r2 = radius - 1;
		var _g = 0;
		var _g1 = totalSteps + 1;
		while(_g < _g1) {
			var i1 = _g++;
			cx = x + radius * Math.sin(angle);
			cy = y + radius * Math.cos(angle);
			ex = x + r2 * Math.sin(angle);
			ey = y + r2 * Math.cos(angle);
			if(i1 != 0) {
				var t0 = new trilateral_tri_Trilateral(dx,dy,bx,by,cx,cy);
				var t11 = new trilateral_tri_Trilateral(dx,dy,cx,cy,ex,ey);
				out[out.length] = t0;
				out[out.length] = t11;
			}
			angle += step1;
			bx = cx;
			by = cy;
			dx = ex;
			dy = ey;
		}
		var triArr = out;
		var colorID = this.appColors.indexOf(3355443);
		var tri;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t2 = triArr[_g2];
			++_g2;
			if(t2 != null) {
				var t3 = Object.create(trilateral_tri_Triangle.prototype);
				t3.id = 0;
				t3.ax = t2.ax;
				t3.ay = t2.ay;
				t3.bx = t2.bx;
				t3.by = t2.by;
				t3.cx = t2.cx;
				t3.cy = t2.cy;
				t3.mark = t2.mark;
				t3.depth = 0;
				t3.alpha = 1.;
				t3.colorID = colorID;
				t3.colorA = colorID;
				t3.colorB = colorID;
				t3.colorC = colorID;
				t3.windingAdjusted = t2.windingAdjusted;
				tri = t3;
				this1[this1.length] = tri;
			}
		}
		var _this = this.innerDemo;
		var anchor = this.mousePos;
		var b = _this.point;
		var toNext_x = anchor.x - b.x;
		var toNext_y = anchor.y - b.y;
		var toNext_z = anchor.z - b.z;
		var toNext_w = anchor.w - b.w;
		if(Math.sqrt(toNext_x * toNext_x + toNext_y * toNext_y + toNext_z * toNext_z + toNext_w * toNext_w) > _this.distance) {
			var this13 = _this.point;
			var distance = _this.distance;
			var a_x = this13.x - anchor.x;
			var a_y = this13.y - anchor.y;
			var a_z = this13.z - anchor.z;
			var a_w = this13.w - anchor.w;
			var currentLength = Math.sqrt(a_x * a_x + a_y * a_y + a_z * a_z + a_w * a_w);
			if(currentLength != 0.) {
				var mul = 1. / currentLength;
				a_x *= mul;
				a_y *= mul;
				a_z *= mul;
				a_w *= mul;
				var tmp = a_x * a_x + a_y * a_y + a_z * a_z + a_w * a_w;
			}
			var a_x1 = a_x * distance;
			var a_y1 = a_y * distance;
			var a_z1 = a_z * distance;
			var a_w1 = a_w * distance;
			var this14 = { x : a_x1 + anchor.x, y : a_y1 + anchor.y, z : a_z1 + anchor.z, w : a_w1 + anchor.w};
			_this.point = this14;
			console.log("constraints/demo/Inner.hx:19:",_this.point.x + " " + _this.point.y);
		}
		var x1 = this.innerDemo.point.x;
		var y1 = this.innerDemo.point.y;
		var _this1 = this.shapes;
		var radius1 = this.circleSize;
		var color = this.appColors.indexOf(16777215);
		var this15 = _this1.triangles;
		var id = _this1.refCount++;
		var t4 = [];
		var this16;
		if(t4 == null) {
			var t5 = [];
			var this17 = t5 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t5;
			this16 = this17;
		} else {
			this16 = t4;
		}
		var this18 = this16;
		var out1 = this18;
		var pi1 = Math.PI;
		var theta4 = pi1 / 2;
		var step2 = pi1 * 2 / 36;
		var bx1;
		var by1;
		var cx1;
		var cy1;
		var _g3 = 0;
		var _g11 = 36;
		while(_g3 < _g11) {
			var i2 = _g3++;
			bx1 = x1 + radius1 * Math.sin(theta4);
			by1 = y1 + radius1 * Math.cos(theta4);
			theta4 += step2;
			cx1 = x1 + radius1 * Math.sin(theta4);
			cy1 = y1 + radius1 * Math.cos(theta4);
			var tri1 = new trilateral_tri_Trilateral(x1,y1,bx1,by1,cx1,cy1);
			out1[out1.length] = tri1;
		}
		var triArr1 = out1;
		var tri2;
		var _g4 = 0;
		while(_g4 < triArr1.length) {
			var t6 = triArr1[_g4];
			++_g4;
			if(t6 != null) {
				var t7 = Object.create(trilateral_tri_Triangle.prototype);
				t7.id = id;
				t7.ax = t6.ax;
				t7.ay = t6.ay;
				t7.bx = t6.bx;
				t7.by = t6.by;
				t7.cx = t6.cx;
				t7.cy = t6.cy;
				t7.mark = t6.mark;
				t7.depth = 0;
				t7.alpha = 1.;
				t7.colorID = color;
				t7.colorA = color;
				t7.colorB = color;
				t7.colorC = color;
				t7.windingAdjusted = t6.windingAdjusted;
				tri2 = t7;
				this15[this15.length] = tri2;
			}
		}
		var _gthis = this;
		var jointRender = function(i3,joint) {
			var _this2 = _gthis.shapes;
			var x2 = joint.x;
			var y2 = joint.y;
			var radius2 = _gthis.circleSize;
			var color1 = _gthis.appColors.indexOf(16711680) + i3;
			var this19 = _this2.triangles;
			var id1 = _this2.refCount++;
			var t8 = [];
			var this20;
			if(t8 == null) {
				var t9 = [];
				var this21 = t9 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t9;
				this20 = this21;
			} else {
				this20 = t8;
			}
			var this22 = this20;
			var out2 = this22;
			var pi2 = Math.PI;
			var theta5 = pi2 / 2;
			var step3 = pi2 * 2 / 36;
			var bx2;
			var by2;
			var cx2;
			var cy2;
			var _g5 = 0;
			var _g12 = 36;
			while(_g5 < _g12) {
				var i4 = _g5++;
				bx2 = x2 + radius2 * Math.sin(theta5);
				by2 = y2 + radius2 * Math.cos(theta5);
				theta5 += step3;
				cx2 = x2 + radius2 * Math.sin(theta5);
				cy2 = y2 + radius2 * Math.cos(theta5);
				var tri3 = new trilateral_tri_Trilateral(x2,y2,bx2,by2,cx2,cy2);
				out2[out2.length] = tri3;
			}
			var triArr2 = out2;
			var tri4;
			var _g6 = 0;
			while(_g6 < triArr2.length) {
				var t10 = triArr2[_g6];
				++_g6;
				if(t10 != null) {
					var t12 = Object.create(trilateral_tri_Triangle.prototype);
					t12.id = id1;
					t12.ax = t10.ax;
					t12.ay = t10.ay;
					t12.bx = t10.bx;
					t12.by = t10.by;
					t12.cx = t10.cx;
					t12.cy = t10.cy;
					t12.mark = t10.mark;
					t12.depth = 0;
					t12.alpha = 1.;
					t12.colorID = color1;
					t12.colorA = color1;
					t12.colorB = color1;
					t12.colorC = color1;
					t12.windingAdjusted = t10.windingAdjusted;
					tri4 = t12;
					this19[this19.length] = tri4;
				}
			}
			return _this2.refCount - 1;
		};
		var _this3 = this.chainDemo;
		var anchor1 = this.mousePos;
		var joint1 = _this3.joints[0];
		joint1.x = anchor1.x;
		joint1.y = anchor1.y;
		jointRender(0,joint1);
		var _g7 = 1;
		var _g13 = _this3.points;
		while(_g7 < _g13) {
			var i5 = _g7++;
			var this23 = _this3.joints[i5];
			var anchor2 = _this3.joints[i5 - 1];
			var distance1 = _this3.distance;
			var a_x2 = this23.x - anchor2.x;
			var a_y2 = this23.y - anchor2.y;
			var a_z2 = this23.z - anchor2.z;
			var a_w2 = this23.w - anchor2.w;
			var currentLength1 = Math.sqrt(a_x2 * a_x2 + a_y2 * a_y2 + a_z2 * a_z2 + a_w2 * a_w2);
			if(currentLength1 != 0.) {
				var mul1 = 1. / currentLength1;
				a_x2 *= mul1;
				a_y2 *= mul1;
				a_z2 *= mul1;
				a_w2 *= mul1;
				var tmp1 = a_x2 * a_x2 + a_y2 * a_y2 + a_z2 * a_z2 + a_w2 * a_w2;
			}
			var a_x3 = a_x2 * distance1;
			var a_y3 = a_y2 * distance1;
			var a_z3 = a_z2 * distance1;
			var a_w3 = a_w2 * distance1;
			var this24 = { x : a_x3 + anchor2.x, y : a_y3 + anchor2.y, z : a_z3 + anchor2.z, w : a_w3 + anchor2.w};
			_this3.joints[i5] = this24;
			joint1 = _this3.joints[i5];
			jointRender(i5,joint1);
		}
		var _gthis1 = this;
		var jointRender1 = function(i6,joint2) {
			var _this4 = _gthis1.shapes;
			var x3 = joint2.x;
			var y3 = joint2.y;
			var radius3 = _gthis1.circleSize;
			var color2 = _gthis1.appColors.indexOf(16711680) + i6;
			var this25 = _this4.triangles;
			var id2 = _this4.refCount++;
			var t13 = [];
			var this26;
			if(t13 == null) {
				var t14 = [];
				var this27 = t14 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t14;
				this26 = this27;
			} else {
				this26 = t13;
			}
			var this28 = this26;
			var out3 = this28;
			var pi3 = Math.PI;
			var theta6 = pi3 / 2;
			var step4 = pi3 * 2 / 36;
			var bx3;
			var by3;
			var cx3;
			var cy3;
			var _g8 = 0;
			var _g14 = 36;
			while(_g8 < _g14) {
				var i7 = _g8++;
				bx3 = x3 + radius3 * Math.sin(theta6);
				by3 = y3 + radius3 * Math.cos(theta6);
				theta6 += step4;
				cx3 = x3 + radius3 * Math.sin(theta6);
				cy3 = y3 + radius3 * Math.cos(theta6);
				var tri5 = new trilateral_tri_Trilateral(x3,y3,bx3,by3,cx3,cy3);
				out3[out3.length] = tri5;
			}
			var triArr3 = out3;
			var tri6;
			var _g9 = 0;
			while(_g9 < triArr3.length) {
				var t15 = triArr3[_g9];
				++_g9;
				if(t15 != null) {
					var t16 = Object.create(trilateral_tri_Triangle.prototype);
					t16.id = id2;
					t16.ax = t15.ax;
					t16.ay = t15.ay;
					t16.bx = t15.bx;
					t16.by = t15.by;
					t16.cx = t15.cx;
					t16.cy = t15.cy;
					t16.mark = t15.mark;
					t16.depth = 0;
					t16.alpha = 1.;
					t16.colorID = color2;
					t16.colorA = color2;
					t16.colorB = color2;
					t16.colorC = color2;
					t16.windingAdjusted = t15.windingAdjusted;
					tri6 = t16;
					this25[this25.length] = tri6;
				}
			}
			return _this4.refCount - 1;
		};
		var _this5 = this.fabrikDemo;
		var anchor3 = this.mousePos;
		var joint3 = _this5.joints[0];
		joint3.x = anchor3.x;
		joint3.y = anchor3.y;
		jointRender1(0,joint3);
		var _g10 = 1;
		var _g15 = _this5.points;
		while(_g10 < _g15) {
			var i8 = _g10++;
			var this29 = _this5.joints[i8];
			var anchor4 = _this5.joints[i8 - 1];
			var distance2 = _this5.distance;
			var a_x4 = this29.x - anchor4.x;
			var a_y4 = this29.y - anchor4.y;
			var a_z4 = this29.z - anchor4.z;
			var a_w4 = this29.w - anchor4.w;
			var currentLength2 = Math.sqrt(a_x4 * a_x4 + a_y4 * a_y4 + a_z4 * a_z4 + a_w4 * a_w4);
			if(currentLength2 != 0.) {
				var mul2 = 1. / currentLength2;
				a_x4 *= mul2;
				a_y4 *= mul2;
				a_z4 *= mul2;
				a_w4 *= mul2;
				var tmp2 = a_x4 * a_x4 + a_y4 * a_y4 + a_z4 * a_z4 + a_w4 * a_w4;
			}
			var a_x5 = a_x4 * distance2;
			var a_y5 = a_y4 * distance2;
			var a_z5 = a_z4 * distance2;
			var a_w5 = a_w4 * distance2;
			var this30 = { x : a_x5 + anchor4.x, y : a_y5 + anchor4.y, z : a_z5 + anchor4.z, w : a_w5 + anchor4.w};
			_this5.joints[i8] = this30;
		}
		var j;
		var joint4 = _this5.joints[_this5.points - 1];
		joint4.x = _this5.x;
		joint4.y = _this5.y;
		jointRender1(_this5.points - 1,joint4);
		var _g21 = 1;
		var _g31 = _this5.points;
		while(_g21 < _g31) {
			var i9 = _g21++;
			j = _this5.points - i9;
			var this31 = _this5.joints[j - 1];
			var anchor5 = _this5.joints[j];
			var distance3 = _this5.distance;
			var a_x6 = this31.x - anchor5.x;
			var a_y6 = this31.y - anchor5.y;
			var a_z6 = this31.z - anchor5.z;
			var a_w6 = this31.w - anchor5.w;
			var currentLength3 = Math.sqrt(a_x6 * a_x6 + a_y6 * a_y6 + a_z6 * a_z6 + a_w6 * a_w6);
			if(currentLength3 != 0.) {
				var mul3 = 1. / currentLength3;
				a_x6 *= mul3;
				a_y6 *= mul3;
				a_z6 *= mul3;
				a_w6 *= mul3;
				var tmp3 = a_x6 * a_x6 + a_y6 * a_y6 + a_z6 * a_z6 + a_w6 * a_w6;
			}
			var a_x7 = a_x6 * distance3;
			var a_y7 = a_y6 * distance3;
			var a_z7 = a_z6 * distance3;
			var a_w7 = a_w6 * distance3;
			var this32 = { x : a_x7 + anchor5.x, y : a_y7 + anchor5.y, z : a_z7 + anchor5.z, w : a_w7 + anchor5.w};
			_this5.joints[j - 1] = this32;
			joint4 = _this5.joints[j - 1];
			jointRender1(j,joint4);
		}
		var spots = this.chainDemo.joints;
		var width = this.lineWidth;
		var path = new trilateral_path_Fine(null,null,3);
		path.width = width;
		path.moveTo(spots[0].x,spots[0].y);
		var _g16 = 1;
		var _g17 = this.points;
		while(_g16 < _g17) {
			var i10 = _g16++;
			var x_ = spots[i10].x;
			var y_ = spots[i10].y;
			var repeat = path.x == x_ && path.y == y_;
			if(!repeat) {
				if(path.widthFunction != null) {
					path.width = path.widthFunction(path.width,path.x,path.x,x_,y_);
				}
				var _this6 = path.contour;
				var ax_ = path.x;
				var ay_ = path.y;
				var width_ = path.width;
				var oldAngle = _this6.dx != null ? _this6.angle1 : null;
				_this6.halfA = Math.PI / 2;
				_this6.ax = x_;
				_this6.ay = y_;
				_this6.bx = ax_;
				_this6.by = ay_;
				_this6.beta = Math.PI / 2 - _this6.halfA;
				_this6.r = width_ / 2 * Math.cos(_this6.beta);
				_this6.theta = Math.atan2(_this6.ay - _this6.by,_this6.ax - _this6.bx);
				if(_this6.theta > 0) {
					if(_this6.halfA < 0) {
						_this6.angle2 = _this6.theta + _this6.halfA + Math.PI / 2;
						_this6.angle1 = _this6.theta - _this6.halfA;
					} else {
						_this6.angle1 = _this6.theta + _this6.halfA - Math.PI;
						_this6.angle2 = _this6.theta + _this6.halfA;
					}
				} else if(_this6.halfA > 0) {
					_this6.angle1 = _this6.theta + _this6.halfA - Math.PI;
					_this6.angle2 = _this6.theta + _this6.halfA;
				} else {
					_this6.angle2 = _this6.theta + _this6.halfA + Math.PI / 2;
					_this6.angle1 = _this6.theta - _this6.halfA;
				}
				if(_this6.dxPrev != null) {
					_this6.dxOld = _this6.dxPrev;
				}
				if(_this6.dyPrev != null) {
					_this6.dyOld = _this6.dyPrev;
				}
				if(_this6.exPrev != null) {
					_this6.exOld = _this6.exPrev;
				}
				if(_this6.eyPrev != null) {
					_this6.eyOld = _this6.eyPrev;
				}
				if(_this6.dx != null) {
					_this6.dxPrev = _this6.dx;
				}
				if(_this6.dy != null) {
					_this6.dyPrev = _this6.dy;
				}
				if(_this6.ex != null) {
					_this6.exPrev = _this6.ex;
				}
				if(_this6.ey != null) {
					_this6.eyPrev = _this6.ey;
				}
				_this6.dx = _this6.bx + _this6.r * Math.cos(_this6.angle1);
				_this6.dy = _this6.by + _this6.r * Math.sin(_this6.angle1);
				_this6.ex = _this6.bx + _this6.r * Math.cos(_this6.angle2);
				_this6.ey = _this6.by + _this6.r * Math.sin(_this6.angle2);
				_this6.ax = ax_;
				_this6.ay = ay_;
				_this6.bx = x_;
				_this6.by = y_;
				_this6.theta = Math.atan2(_this6.ay - _this6.by,_this6.ax - _this6.bx);
				if(_this6.theta > 0) {
					if(_this6.halfA < 0) {
						_this6.angle2 = _this6.theta + _this6.halfA + Math.PI / 2;
						_this6.angle1 = _this6.theta - _this6.halfA;
					} else {
						_this6.angle1 = _this6.theta + _this6.halfA - Math.PI;
						_this6.angle2 = _this6.theta + _this6.halfA;
					}
				} else if(_this6.halfA > 0) {
					_this6.angle1 = _this6.theta + _this6.halfA - Math.PI;
					_this6.angle2 = _this6.theta + _this6.halfA;
				} else {
					_this6.angle2 = _this6.theta + _this6.halfA + Math.PI / 2;
					_this6.angle1 = _this6.theta - _this6.halfA;
				}
				if(_this6.dxPrev != null) {
					_this6.dxOld = _this6.dxPrev;
				}
				if(_this6.dyPrev != null) {
					_this6.dyOld = _this6.dyPrev;
				}
				if(_this6.exPrev != null) {
					_this6.exOld = _this6.exPrev;
				}
				if(_this6.eyPrev != null) {
					_this6.eyOld = _this6.eyPrev;
				}
				if(_this6.dx != null) {
					_this6.dxPrev = _this6.dx;
				}
				if(_this6.dy != null) {
					_this6.dyPrev = _this6.dy;
				}
				if(_this6.ex != null) {
					_this6.exPrev = _this6.ex;
				}
				if(_this6.ey != null) {
					_this6.eyPrev = _this6.ey;
				}
				_this6.dx = _this6.bx + _this6.r * Math.cos(_this6.angle1);
				_this6.dy = _this6.by + _this6.r * Math.sin(_this6.angle1);
				_this6.ex = _this6.bx + _this6.r * Math.cos(_this6.angle2);
				_this6.ey = _this6.by + _this6.r * Math.sin(_this6.angle2);
				var x4 = _this6.dxOld - x_;
				var y4 = _this6.dyOld - y_;
				var x5 = _this6.exOld - x_;
				var y5 = _this6.eyOld - y_;
				var clockWise = x4 * x4 + y4 * y4 > x5 * x5 + y5 * y5;
				var theta0;
				var theta11;
				if(clockWise) {
					theta0 = -Math.atan2(_this6.ay - _this6.dyOld,_this6.ax - _this6.dxOld) - Math.PI / 2;
					theta11 = -Math.atan2(_this6.ay - _this6.eyPrev,_this6.ax - _this6.exPrev) - Math.PI / 2;
				} else {
					theta0 = -Math.atan2(_this6.ay - _this6.eyOld,_this6.ax - _this6.exOld) - Math.PI / 2;
					theta11 = -Math.atan2(_this6.ay - _this6.dyPrev,_this6.ax - _this6.dxPrev) - Math.PI / 2;
				}
				var dif5;
				switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
				case 0:
					var f8;
					if(theta0 >= 0 && theta0 > Math.PI) {
						f8 = theta0;
					} else {
						var a8 = theta0 % (2 * Math.PI);
						f8 = a8 >= 0 ? a8 : a8 + 2 * Math.PI;
					}
					var this33 = f8;
					var za4 = this33;
					var f9;
					if(theta11 >= 0 && theta11 > Math.PI) {
						f9 = theta11;
					} else {
						var a9 = theta11 % (2 * Math.PI);
						f9 = a9 >= 0 ? a9 : a9 + 2 * Math.PI;
					}
					var this34 = f9;
					var zb4 = this34;
					var fa4 = za4;
					var fb4 = zb4;
					var theta7 = Math.abs(theta0 - theta11);
					var clockwise4 = theta0 < theta11;
					var dif6 = clockwise4 ? theta7 : -theta7;
					dif5 = dif6 > 0 ? dif6 : 2 * Math.PI + dif6;
					break;
				case 1:
					var f10;
					if(theta0 >= 0 && theta0 > Math.PI) {
						f10 = theta0;
					} else {
						var a10 = theta0 % (2 * Math.PI);
						f10 = a10 >= 0 ? a10 : a10 + 2 * Math.PI;
					}
					var this35 = f10;
					var za5 = this35;
					var f11;
					if(theta11 >= 0 && theta11 > Math.PI) {
						f11 = theta11;
					} else {
						var a11 = theta11 % (2 * Math.PI);
						f11 = a11 >= 0 ? a11 : a11 + 2 * Math.PI;
					}
					var this36 = f11;
					var zb5 = this36;
					var fa5 = za5;
					var fb5 = zb5;
					var theta8 = Math.abs(theta0 - theta11);
					var clockwise5 = theta0 < theta11;
					var dif7 = clockwise5 ? theta8 : -theta8;
					dif5 = dif7 < 0 ? dif7 : -2 * Math.PI + dif7;
					break;
				case 2:
					var f12;
					if(theta0 >= 0 && theta0 > Math.PI) {
						f12 = theta0;
					} else {
						var a12 = theta0 % (2 * Math.PI);
						f12 = a12 >= 0 ? a12 : a12 + 2 * Math.PI;
					}
					var this37 = f12;
					var za6 = this37;
					var f13;
					if(theta11 >= 0 && theta11 > Math.PI) {
						f13 = theta11;
					} else {
						var a13 = theta11 % (2 * Math.PI);
						f13 = a13 >= 0 ? a13 : a13 + 2 * Math.PI;
					}
					var this38 = f13;
					var zb6 = this38;
					var fa6 = theta0;
					var fb6 = theta11;
					var theta9 = Math.abs(theta0 - theta11);
					var smallest1 = theta9 <= Math.PI;
					var clockwise6 = theta0 < theta11;
					var dif8 = clockwise6 ? theta9 : -theta9;
					dif5 = smallest1 ? dif8 : clockwise6 ? -(2 * Math.PI - theta9) : 2 * Math.PI - theta9;
					break;
				case 3:
					var f14;
					if(theta0 >= 0 && theta0 > Math.PI) {
						f14 = theta0;
					} else {
						var a14 = theta0 % (2 * Math.PI);
						f14 = a14 >= 0 ? a14 : a14 + 2 * Math.PI;
					}
					var this39 = f14;
					var za7 = this39;
					var f15;
					if(theta11 >= 0 && theta11 > Math.PI) {
						f15 = theta11;
					} else {
						var a15 = theta11 % (2 * Math.PI);
						f15 = a15 >= 0 ? a15 : a15 + 2 * Math.PI;
					}
					var this40 = f15;
					var zb7 = this40;
					var fa7 = theta0;
					var fb7 = theta11;
					var theta10 = Math.abs(theta0 - theta11);
					var largest1 = theta10 > Math.PI;
					var clockwise7 = theta0 < theta11;
					var dif9 = clockwise7 ? theta10 : -theta10;
					dif5 = largest1 ? dif9 : clockwise7 ? -(2 * Math.PI - theta10) : 2 * Math.PI - theta10;
					break;
				}
				if(_this6.count != 0) {
					var gamma1 = Math.abs(dif5) / 2;
					var h = width_ / 2 / Math.cos(gamma1);
					var f16;
					if(theta0 <= Math.PI && theta0 > -Math.PI) {
						f16 = theta0;
					} else {
						var a16 = (theta0 + Math.PI) % (2 * Math.PI);
						f16 = a16 >= 0 ? a16 - Math.PI : a16 + Math.PI;
					}
					var this41 = f16;
					var start = this41;
					var start2 = start;
					var delta = start2 + dif5 / 2 + Math.PI;
					_this6.jx = _this6.ax + h * Math.sin(delta);
					_this6.jy = _this6.ay + h * Math.cos(delta);
				}
				if(_this6.count == 0 && (_this6.endLine == 1 || _this6.endLine == 3)) {
					var ax = _this6.ax;
					var ay = _this6.ay;
					var radius4 = width_ / 2;
					var beta = -_this6.angle1 - Math.PI / 2;
					var gamma2 = -_this6.angle1 - Math.PI / 2 + Math.PI;
					var temp = [];
					var this42 = _this6.triArr;
					var t17 = [];
					var this43;
					if(t17 == null) {
						var t18 = [];
						var this44 = t18 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t18;
						this43 = this44;
					} else {
						this43 = t17;
					}
					var this45 = this43;
					var out4 = this45;
					var pi4 = Math.PI;
					var step5 = pi4 * 2 / 36;
					var dif10;
					switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
					case 0:
						var f17;
						if(beta >= 0 && beta > Math.PI) {
							f17 = beta;
						} else {
							var a17 = beta % (2 * Math.PI);
							f17 = a17 >= 0 ? a17 : a17 + 2 * Math.PI;
						}
						var this46 = f17;
						var za8 = this46;
						var f18;
						if(gamma2 >= 0 && gamma2 > Math.PI) {
							f18 = gamma2;
						} else {
							var a18 = gamma2 % (2 * Math.PI);
							f18 = a18 >= 0 ? a18 : a18 + 2 * Math.PI;
						}
						var this47 = f18;
						var zb8 = this47;
						var fa8 = za8;
						var fb8 = zb8;
						var theta12 = Math.abs(beta - gamma2);
						var clockwise8 = beta < gamma2;
						var dif11 = clockwise8 ? theta12 : -theta12;
						dif10 = dif11 > 0 ? dif11 : 2 * Math.PI + dif11;
						break;
					case 1:
						var f19;
						if(beta >= 0 && beta > Math.PI) {
							f19 = beta;
						} else {
							var a19 = beta % (2 * Math.PI);
							f19 = a19 >= 0 ? a19 : a19 + 2 * Math.PI;
						}
						var this48 = f19;
						var za9 = this48;
						var f20;
						if(gamma2 >= 0 && gamma2 > Math.PI) {
							f20 = gamma2;
						} else {
							var a20 = gamma2 % (2 * Math.PI);
							f20 = a20 >= 0 ? a20 : a20 + 2 * Math.PI;
						}
						var this49 = f20;
						var zb9 = this49;
						var fa9 = za9;
						var fb9 = zb9;
						var theta13 = Math.abs(beta - gamma2);
						var clockwise9 = beta < gamma2;
						var dif12 = clockwise9 ? theta13 : -theta13;
						dif10 = dif12 < 0 ? dif12 : -2 * Math.PI + dif12;
						break;
					case 2:
						var f21;
						if(beta >= 0 && beta > Math.PI) {
							f21 = beta;
						} else {
							var a21 = beta % (2 * Math.PI);
							f21 = a21 >= 0 ? a21 : a21 + 2 * Math.PI;
						}
						var this50 = f21;
						var za10 = this50;
						var f22;
						if(gamma2 >= 0 && gamma2 > Math.PI) {
							f22 = gamma2;
						} else {
							var a22 = gamma2 % (2 * Math.PI);
							f22 = a22 >= 0 ? a22 : a22 + 2 * Math.PI;
						}
						var this51 = f22;
						var zb10 = this51;
						var fa10 = beta;
						var fb10 = gamma2;
						var theta14 = Math.abs(beta - gamma2);
						var smallest2 = theta14 <= Math.PI;
						var clockwise10 = beta < gamma2;
						var dif13 = clockwise10 ? theta14 : -theta14;
						dif10 = smallest2 ? dif13 : clockwise10 ? -(2 * Math.PI - theta14) : 2 * Math.PI - theta14;
						break;
					case 3:
						var f23;
						if(beta >= 0 && beta > Math.PI) {
							f23 = beta;
						} else {
							var a23 = beta % (2 * Math.PI);
							f23 = a23 >= 0 ? a23 : a23 + 2 * Math.PI;
						}
						var this52 = f23;
						var za11 = this52;
						var f24;
						if(gamma2 >= 0 && gamma2 > Math.PI) {
							f24 = gamma2;
						} else {
							var a24 = gamma2 % (2 * Math.PI);
							f24 = a24 >= 0 ? a24 : a24 + 2 * Math.PI;
						}
						var this53 = f24;
						var zb11 = this53;
						var fa11 = beta;
						var fb11 = gamma2;
						var theta15 = Math.abs(beta - gamma2);
						var largest2 = theta15 > Math.PI;
						var clockwise11 = beta < gamma2;
						var dif14 = clockwise11 ? theta15 : -theta15;
						dif10 = largest2 ? dif14 : clockwise11 ? -(2 * Math.PI - theta15) : 2 * Math.PI - theta15;
						break;
					}
					var positive1 = dif10 >= 0;
					var totalSteps1 = Math.ceil(Math.abs(dif10) / step5);
					var step6 = dif10 / totalSteps1;
					var angle1 = beta;
					var cx4;
					var cy4;
					var bx4 = 0;
					var by4 = 0;
					var p2 = temp.length;
					var _g18 = 0;
					var _g19 = totalSteps1 + 1;
					while(_g18 < _g19) {
						var i11 = _g18++;
						cx4 = ax + radius4 * Math.sin(angle1);
						cy4 = ay + radius4 * Math.cos(angle1);
						temp[p2++] = cx4;
						temp[p2++] = cy4;
						if(i11 != 0) {
							var t19 = new trilateral_tri_Trilateral(ax,ay,bx4,by4,cx4,cy4);
							out4[out4.length] = t19;
						}
						angle1 += step6;
						bx4 = cx4;
						by4 = cy4;
					}
					var triArr4 = out4;
					var _g20 = 0;
					while(_g20 < triArr4.length) {
						var t20 = triArr4[_g20];
						++_g20;
						this42[this42.length] = t20;
					}
					var pA = _this6.pointsAnti.length;
					var len = temp.length / 2 | 0;
					var p4 = temp.length / 4 | 0;
					var _g22 = 0;
					var _g110 = p4;
					while(_g22 < _g110) {
						var i12 = _g22++;
						_this6.pointsAnti[pA++] = temp[len - 2 * i12 + 1];
						_this6.pointsAnti[pA++] = temp[len - 2 * i12];
					}
					var pC = _this6.pointsClock.length;
					var _g23 = 0;
					var _g32 = p4;
					while(_g23 < _g32) {
						var i13 = _g23++;
						_this6.pointsClock[pC++] = temp[i13 * 2 + len + 1];
						_this6.pointsClock[pC++] = temp[i13 * 2 + len];
					}
				}
				if(_this6.count != 0) {
					_this6.addQuads(clockWise,width_);
				}
				_this6.quadIndex = _this6.triArr.length;
				if(_this6.count == 0) {
					_this6.penultimateAX = _this6.dxPrev;
					_this6.penultimateAY = _this6.dyPrev;
					_this6.lastAntiX = _this6.ex;
					_this6.lastAntiY = _this6.ey;
					_this6.penultimateCX = _this6.dx;
					_this6.penultimateCY = _this6.dy;
					_this6.lastClockX = _this6.exPrev;
					_this6.lastClockY = _this6.eyPrev;
					var this54 = _this6.triArr;
					var tri7 = new trilateral_tri_Trilateral(_this6.dxPrev,_this6.dyPrev,_this6.dx,_this6.dy,_this6.ex,_this6.ey,0);
					this54[this54.length] = tri7;
					var this55 = _this6.triArr;
					var tri8 = new trilateral_tri_Trilateral(_this6.dxPrev,_this6.dyPrev,_this6.dx,_this6.dy,_this6.exPrev,_this6.eyPrev,0);
					this55[this55.length] = tri8;
				} else {
					if(clockWise && !_this6.lastClock) {
						_this6.penultimateAX = _this6.jx;
						_this6.penultimateAY = _this6.jy;
						_this6.lastAntiX = _this6.ex;
						_this6.lastAntiY = _this6.ey;
						_this6.penultimateCX = _this6.dx;
						_this6.penultimateCY = _this6.dy;
						_this6.lastClockX = _this6.exPrev;
						_this6.lastClockY = _this6.eyPrev;
						var this56 = _this6.triArr;
						var tri9 = new trilateral_tri_Trilateral(_this6.jx,_this6.jy,_this6.dx,_this6.dy,_this6.ex,_this6.ey,0);
						this56[this56.length] = tri9;
						var this57 = _this6.triArr;
						var tri10 = new trilateral_tri_Trilateral(_this6.jx,_this6.jy,_this6.dx,_this6.dy,_this6.exPrev,_this6.eyPrev,0);
						this57[this57.length] = tri10;
					}
					if(clockWise && _this6.lastClock) {
						_this6.penultimateAX = _this6.jx;
						_this6.penultimateAY = _this6.jy;
						_this6.lastAntiX = _this6.ex;
						_this6.lastAntiY = _this6.ey;
						_this6.penultimateCX = _this6.dx;
						_this6.penultimateCY = _this6.dy;
						_this6.lastClockX = _this6.exPrev;
						_this6.lastClockY = _this6.eyPrev;
						var this58 = _this6.triArr;
						var tri11 = new trilateral_tri_Trilateral(_this6.jx,_this6.jy,_this6.dx,_this6.dy,_this6.ex,_this6.ey,0);
						this58[this58.length] = tri11;
						var this59 = _this6.triArr;
						var tri12 = new trilateral_tri_Trilateral(_this6.jx,_this6.jy,_this6.dx,_this6.dy,_this6.exPrev,_this6.eyPrev,0);
						this59[this59.length] = tri12;
					}
					if(!clockWise && !_this6.lastClock) {
						_this6.penultimateCX = _this6.dx;
						_this6.penultimateCY = _this6.dy;
						_this6.lastClockX = _this6.jx;
						_this6.lastClockY = _this6.jy;
						_this6.penultimateAX = _this6.dxPrev;
						_this6.penultimateAY = _this6.dyPrev;
						_this6.lastAntiX = _this6.ex;
						_this6.lastAntiY = _this6.ey;
						var this60 = _this6.triArr;
						var tri13 = new trilateral_tri_Trilateral(_this6.dxPrev,_this6.dyPrev,_this6.dx,_this6.dy,_this6.jx,_this6.jy,0);
						this60[this60.length] = tri13;
						var this61 = _this6.triArr;
						var tri14 = new trilateral_tri_Trilateral(_this6.dxPrev,_this6.dyPrev,_this6.dx,_this6.dy,_this6.ex,_this6.ey,0);
						this61[this61.length] = tri14;
					}
					if(!clockWise && _this6.lastClock) {
						_this6.penultimateAX = _this6.dxPrev;
						_this6.penultimateAY = _this6.dyPrev;
						_this6.lastAntiX = _this6.ex;
						_this6.lastAntiY = _this6.ey;
						_this6.penultimateCX = _this6.jx;
						_this6.penultimateCY = _this6.jy;
						_this6.lastClockX = _this6.dx;
						_this6.lastClockY = _this6.dy;
						var this62 = _this6.triArr;
						var tri15 = new trilateral_tri_Trilateral(_this6.jx,_this6.jy,_this6.dx,_this6.dy,_this6.ex,_this6.ey,0);
						this62[this62.length] = tri15;
						var this63 = _this6.triArr;
						var tri16 = new trilateral_tri_Trilateral(_this6.dxPrev,_this6.dyPrev,_this6.jx,_this6.jy,_this6.ex,_this6.ey,0);
						this63[this63.length] = tri16;
					}
				}
				if(clockWise) {
					var radius5 = width_ / 2;
					var edgePoly = _this6.pointsClock;
					var t21 = [];
					var this64;
					if(t21 == null) {
						var t22 = [];
						var this65 = t22 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t22;
						this64 = this65;
					} else {
						this64 = t21;
					}
					var this66 = this64;
					var out5 = this66;
					var pi5 = Math.PI;
					var step7 = pi5 * 2 / 36;
					var positive2 = dif5 >= 0;
					var totalSteps2 = Math.ceil(Math.abs(dif5) / step7);
					var step8 = dif5 / totalSteps2;
					var angle2 = theta0;
					var cx5;
					var cy5;
					var bx5 = 0;
					var by5 = 0;
					var p21 = edgePoly.length;
					var count = 0;
					var _g24 = 0;
					var _g111 = totalSteps2 + 1;
					while(_g24 < _g111) {
						var i14 = _g24++;
						cx5 = ax_ + radius5 * Math.sin(angle2);
						cy5 = ay_ + radius5 * Math.cos(angle2);
						if(i14 != 0) {
							var t23 = new trilateral_tri_Trilateral(ax_,ay_,bx5,by5,cx5,cy5);
							out5[out5.length] = t23;
							edgePoly[p21++] = cx5;
							edgePoly[p21++] = cy5;
						}
						angle2 += step8;
						bx5 = cx5;
						by5 = cy5;
					}
					var trilateralArray = out5;
					var this67 = _this6.triArr;
					var _g25 = 0;
					while(_g25 < trilateralArray.length) {
						var t24 = trilateralArray[_g25];
						++_g25;
						this67[this67.length] = t24;
					}
				} else {
					var radius6 = width_ / 2;
					var edgePoly1 = _this6.pointsAnti;
					var t25 = [];
					var this68;
					if(t25 == null) {
						var t26 = [];
						var this69 = t26 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t26;
						this68 = this69;
					} else {
						this68 = t25;
					}
					var this70 = this68;
					var out6 = this70;
					var pi6 = Math.PI;
					var step9 = pi6 * 2 / 36;
					var positive3 = dif5 >= 0;
					var totalSteps3 = Math.ceil(Math.abs(dif5) / step9);
					var step10 = dif5 / totalSteps3;
					var angle3 = theta0;
					var cx6;
					var cy6;
					var bx6 = 0;
					var by6 = 0;
					var p22 = edgePoly1.length;
					var count1 = 0;
					var _g26 = 0;
					var _g112 = totalSteps3 + 1;
					while(_g26 < _g112) {
						var i15 = _g26++;
						cx6 = ax_ + radius6 * Math.sin(angle3);
						cy6 = ay_ + radius6 * Math.cos(angle3);
						if(i15 != 0) {
							var t27 = new trilateral_tri_Trilateral(ax_,ay_,bx6,by6,cx6,cy6);
							out6[out6.length] = t27;
							edgePoly1[p22++] = cx6;
							edgePoly1[p22++] = cy6;
						}
						angle3 += step10;
						bx6 = cx6;
						by6 = cy6;
					}
					var trilateralArray1 = out6;
					var this71 = _this6.triArr;
					var _g27 = 0;
					while(_g27 < trilateralArray1.length) {
						var t28 = trilateralArray1[_g27];
						++_g27;
						this71[this71.length] = t28;
					}
				}
				_this6.kax = _this6.dxPrev;
				_this6.kay = _this6.dyPrev;
				_this6.kbx = _this6.dx;
				_this6.kby = _this6.dy;
				_this6.ncx = _this6.exPrev;
				_this6.ncy = _this6.eyPrev;
				_this6.kcx = _this6.ex;
				_this6.kcy = _this6.ey;
				if(_this6.count != 0) {
					if(clockWise) {
						var this72 = _this6.triArr;
						var tri17 = new trilateral_tri_Trilateral(_this6.ax,_this6.ay,_this6.dxOld,_this6.dyOld,_this6.jx,_this6.jy,0);
						this72[this72.length] = tri17;
						var this73 = _this6.triArr;
						var tri18 = new trilateral_tri_Trilateral(_this6.ax,_this6.ay,_this6.exPrev,_this6.eyPrev,_this6.jx,_this6.jy,0);
						this73[this73.length] = tri18;
					} else {
						var this74 = _this6.triArr;
						var tri19 = new trilateral_tri_Trilateral(_this6.ax,_this6.ay,_this6.exOld,_this6.eyOld,_this6.jx,_this6.jy,0);
						this74[this74.length] = tri19;
						var this75 = _this6.triArr;
						var tri20 = new trilateral_tri_Trilateral(_this6.ax,_this6.ay,_this6.dxPrev,_this6.dyPrev,_this6.jx,_this6.jy,0);
						this75[this75.length] = tri20;
					}
				}
				_this6.jxOld = _this6.jx;
				_this6.jyOld = _this6.jy;
				_this6.lastClock = clockWise;
				_this6.count++;
				var l = path.points.length;
				var p = path.points[l - 1];
				var l2 = p.length;
				p[l2] = x_;
				p[l2 + 1] = y_;
				var d = path.dim[path.dim.length - 1];
				if(x_ < d.minX) {
					d.minX = x_;
				}
				if(x_ > d.maxX) {
					d.maxX = x_;
				}
				if(y_ < d.minY) {
					d.minY = y_;
				}
				if(y_ > d.maxY) {
					d.maxY = y_;
				}
				path.x = x_;
				path.y = y_;
			}
		}
		var this76 = this.triangles;
		var triArr5 = path.trilateralArray;
		var colorID1 = this.appColors.indexOf(789516);
		var tri21;
		var _g28 = 0;
		while(_g28 < triArr5.length) {
			var t29 = triArr5[_g28];
			++_g28;
			if(t29 != null) {
				var t30 = Object.create(trilateral_tri_Triangle.prototype);
				t30.id = 10;
				t30.ax = t29.ax;
				t30.ay = t29.ay;
				t30.bx = t29.bx;
				t30.by = t29.by;
				t30.cx = t29.cx;
				t30.cy = t29.cy;
				t30.mark = t29.mark;
				t30.depth = 0;
				t30.alpha = 1.;
				t30.colorID = colorID1;
				t30.colorA = colorID1;
				t30.colorB = colorID1;
				t30.colorC = colorID1;
				t30.windingAdjusted = t29.windingAdjusted;
				tri21 = t30;
				this76[this76.length] = tri21;
			}
		}
		var spots1 = this.fabrikDemo.joints;
		var width1 = this.lineWidth;
		var path1 = new trilateral_path_Fine(null,null,3);
		path1.width = width1;
		path1.moveTo(spots1[0].x,spots1[0].y);
		var _g29 = 1;
		var _g113 = this.points;
		while(_g29 < _g113) {
			var i16 = _g29++;
			var x_1 = spots1[i16].x;
			var y_1 = spots1[i16].y;
			var repeat1 = path1.x == x_1 && path1.y == y_1;
			if(!repeat1) {
				if(path1.widthFunction != null) {
					path1.width = path1.widthFunction(path1.width,path1.x,path1.x,x_1,y_1);
				}
				var _this7 = path1.contour;
				var ax_1 = path1.x;
				var ay_1 = path1.y;
				var width_1 = path1.width;
				var oldAngle1 = _this7.dx != null ? _this7.angle1 : null;
				_this7.halfA = Math.PI / 2;
				_this7.ax = x_1;
				_this7.ay = y_1;
				_this7.bx = ax_1;
				_this7.by = ay_1;
				_this7.beta = Math.PI / 2 - _this7.halfA;
				_this7.r = width_1 / 2 * Math.cos(_this7.beta);
				_this7.theta = Math.atan2(_this7.ay - _this7.by,_this7.ax - _this7.bx);
				if(_this7.theta > 0) {
					if(_this7.halfA < 0) {
						_this7.angle2 = _this7.theta + _this7.halfA + Math.PI / 2;
						_this7.angle1 = _this7.theta - _this7.halfA;
					} else {
						_this7.angle1 = _this7.theta + _this7.halfA - Math.PI;
						_this7.angle2 = _this7.theta + _this7.halfA;
					}
				} else if(_this7.halfA > 0) {
					_this7.angle1 = _this7.theta + _this7.halfA - Math.PI;
					_this7.angle2 = _this7.theta + _this7.halfA;
				} else {
					_this7.angle2 = _this7.theta + _this7.halfA + Math.PI / 2;
					_this7.angle1 = _this7.theta - _this7.halfA;
				}
				if(_this7.dxPrev != null) {
					_this7.dxOld = _this7.dxPrev;
				}
				if(_this7.dyPrev != null) {
					_this7.dyOld = _this7.dyPrev;
				}
				if(_this7.exPrev != null) {
					_this7.exOld = _this7.exPrev;
				}
				if(_this7.eyPrev != null) {
					_this7.eyOld = _this7.eyPrev;
				}
				if(_this7.dx != null) {
					_this7.dxPrev = _this7.dx;
				}
				if(_this7.dy != null) {
					_this7.dyPrev = _this7.dy;
				}
				if(_this7.ex != null) {
					_this7.exPrev = _this7.ex;
				}
				if(_this7.ey != null) {
					_this7.eyPrev = _this7.ey;
				}
				_this7.dx = _this7.bx + _this7.r * Math.cos(_this7.angle1);
				_this7.dy = _this7.by + _this7.r * Math.sin(_this7.angle1);
				_this7.ex = _this7.bx + _this7.r * Math.cos(_this7.angle2);
				_this7.ey = _this7.by + _this7.r * Math.sin(_this7.angle2);
				_this7.ax = ax_1;
				_this7.ay = ay_1;
				_this7.bx = x_1;
				_this7.by = y_1;
				_this7.theta = Math.atan2(_this7.ay - _this7.by,_this7.ax - _this7.bx);
				if(_this7.theta > 0) {
					if(_this7.halfA < 0) {
						_this7.angle2 = _this7.theta + _this7.halfA + Math.PI / 2;
						_this7.angle1 = _this7.theta - _this7.halfA;
					} else {
						_this7.angle1 = _this7.theta + _this7.halfA - Math.PI;
						_this7.angle2 = _this7.theta + _this7.halfA;
					}
				} else if(_this7.halfA > 0) {
					_this7.angle1 = _this7.theta + _this7.halfA - Math.PI;
					_this7.angle2 = _this7.theta + _this7.halfA;
				} else {
					_this7.angle2 = _this7.theta + _this7.halfA + Math.PI / 2;
					_this7.angle1 = _this7.theta - _this7.halfA;
				}
				if(_this7.dxPrev != null) {
					_this7.dxOld = _this7.dxPrev;
				}
				if(_this7.dyPrev != null) {
					_this7.dyOld = _this7.dyPrev;
				}
				if(_this7.exPrev != null) {
					_this7.exOld = _this7.exPrev;
				}
				if(_this7.eyPrev != null) {
					_this7.eyOld = _this7.eyPrev;
				}
				if(_this7.dx != null) {
					_this7.dxPrev = _this7.dx;
				}
				if(_this7.dy != null) {
					_this7.dyPrev = _this7.dy;
				}
				if(_this7.ex != null) {
					_this7.exPrev = _this7.ex;
				}
				if(_this7.ey != null) {
					_this7.eyPrev = _this7.ey;
				}
				_this7.dx = _this7.bx + _this7.r * Math.cos(_this7.angle1);
				_this7.dy = _this7.by + _this7.r * Math.sin(_this7.angle1);
				_this7.ex = _this7.bx + _this7.r * Math.cos(_this7.angle2);
				_this7.ey = _this7.by + _this7.r * Math.sin(_this7.angle2);
				var x6 = _this7.dxOld - x_1;
				var y6 = _this7.dyOld - y_1;
				var x7 = _this7.exOld - x_1;
				var y7 = _this7.eyOld - y_1;
				var clockWise1 = x6 * x6 + y6 * y6 > x7 * x7 + y7 * y7;
				var theta01;
				var theta16;
				if(clockWise1) {
					theta01 = -Math.atan2(_this7.ay - _this7.dyOld,_this7.ax - _this7.dxOld) - Math.PI / 2;
					theta16 = -Math.atan2(_this7.ay - _this7.eyPrev,_this7.ax - _this7.exPrev) - Math.PI / 2;
				} else {
					theta01 = -Math.atan2(_this7.ay - _this7.eyOld,_this7.ax - _this7.exOld) - Math.PI / 2;
					theta16 = -Math.atan2(_this7.ay - _this7.dyPrev,_this7.ax - _this7.dxPrev) - Math.PI / 2;
				}
				var dif15;
				switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
				case 0:
					var f25;
					if(theta01 >= 0 && theta01 > Math.PI) {
						f25 = theta01;
					} else {
						var a25 = theta01 % (2 * Math.PI);
						f25 = a25 >= 0 ? a25 : a25 + 2 * Math.PI;
					}
					var this77 = f25;
					var za12 = this77;
					var f26;
					if(theta16 >= 0 && theta16 > Math.PI) {
						f26 = theta16;
					} else {
						var a26 = theta16 % (2 * Math.PI);
						f26 = a26 >= 0 ? a26 : a26 + 2 * Math.PI;
					}
					var this78 = f26;
					var zb12 = this78;
					var fa12 = za12;
					var fb12 = zb12;
					var theta17 = Math.abs(theta01 - theta16);
					var clockwise12 = theta01 < theta16;
					var dif16 = clockwise12 ? theta17 : -theta17;
					dif15 = dif16 > 0 ? dif16 : 2 * Math.PI + dif16;
					break;
				case 1:
					var f27;
					if(theta01 >= 0 && theta01 > Math.PI) {
						f27 = theta01;
					} else {
						var a27 = theta01 % (2 * Math.PI);
						f27 = a27 >= 0 ? a27 : a27 + 2 * Math.PI;
					}
					var this79 = f27;
					var za13 = this79;
					var f28;
					if(theta16 >= 0 && theta16 > Math.PI) {
						f28 = theta16;
					} else {
						var a28 = theta16 % (2 * Math.PI);
						f28 = a28 >= 0 ? a28 : a28 + 2 * Math.PI;
					}
					var this80 = f28;
					var zb13 = this80;
					var fa13 = za13;
					var fb13 = zb13;
					var theta18 = Math.abs(theta01 - theta16);
					var clockwise13 = theta01 < theta16;
					var dif17 = clockwise13 ? theta18 : -theta18;
					dif15 = dif17 < 0 ? dif17 : -2 * Math.PI + dif17;
					break;
				case 2:
					var f29;
					if(theta01 >= 0 && theta01 > Math.PI) {
						f29 = theta01;
					} else {
						var a29 = theta01 % (2 * Math.PI);
						f29 = a29 >= 0 ? a29 : a29 + 2 * Math.PI;
					}
					var this81 = f29;
					var za14 = this81;
					var f30;
					if(theta16 >= 0 && theta16 > Math.PI) {
						f30 = theta16;
					} else {
						var a30 = theta16 % (2 * Math.PI);
						f30 = a30 >= 0 ? a30 : a30 + 2 * Math.PI;
					}
					var this82 = f30;
					var zb14 = this82;
					var fa14 = theta01;
					var fb14 = theta16;
					var theta19 = Math.abs(theta01 - theta16);
					var smallest3 = theta19 <= Math.PI;
					var clockwise14 = theta01 < theta16;
					var dif18 = clockwise14 ? theta19 : -theta19;
					dif15 = smallest3 ? dif18 : clockwise14 ? -(2 * Math.PI - theta19) : 2 * Math.PI - theta19;
					break;
				case 3:
					var f31;
					if(theta01 >= 0 && theta01 > Math.PI) {
						f31 = theta01;
					} else {
						var a31 = theta01 % (2 * Math.PI);
						f31 = a31 >= 0 ? a31 : a31 + 2 * Math.PI;
					}
					var this83 = f31;
					var za15 = this83;
					var f32;
					if(theta16 >= 0 && theta16 > Math.PI) {
						f32 = theta16;
					} else {
						var a32 = theta16 % (2 * Math.PI);
						f32 = a32 >= 0 ? a32 : a32 + 2 * Math.PI;
					}
					var this84 = f32;
					var zb15 = this84;
					var fa15 = theta01;
					var fb15 = theta16;
					var theta20 = Math.abs(theta01 - theta16);
					var largest3 = theta20 > Math.PI;
					var clockwise15 = theta01 < theta16;
					var dif19 = clockwise15 ? theta20 : -theta20;
					dif15 = largest3 ? dif19 : clockwise15 ? -(2 * Math.PI - theta20) : 2 * Math.PI - theta20;
					break;
				}
				if(_this7.count != 0) {
					var gamma3 = Math.abs(dif15) / 2;
					var h1 = width_1 / 2 / Math.cos(gamma3);
					var f33;
					if(theta01 <= Math.PI && theta01 > -Math.PI) {
						f33 = theta01;
					} else {
						var a33 = (theta01 + Math.PI) % (2 * Math.PI);
						f33 = a33 >= 0 ? a33 - Math.PI : a33 + Math.PI;
					}
					var this85 = f33;
					var start1 = this85;
					var start21 = start1;
					var delta1 = start21 + dif15 / 2 + Math.PI;
					_this7.jx = _this7.ax + h1 * Math.sin(delta1);
					_this7.jy = _this7.ay + h1 * Math.cos(delta1);
				}
				if(_this7.count == 0 && (_this7.endLine == 1 || _this7.endLine == 3)) {
					var ax1 = _this7.ax;
					var ay1 = _this7.ay;
					var radius7 = width_1 / 2;
					var beta1 = -_this7.angle1 - Math.PI / 2;
					var gamma4 = -_this7.angle1 - Math.PI / 2 + Math.PI;
					var temp1 = [];
					var this86 = _this7.triArr;
					var t31 = [];
					var this87;
					if(t31 == null) {
						var t32 = [];
						var this88 = t32 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t32;
						this87 = this88;
					} else {
						this87 = t31;
					}
					var this89 = this87;
					var out7 = this89;
					var pi7 = Math.PI;
					var step11 = pi7 * 2 / 36;
					var dif20;
					switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
					case 0:
						var f34;
						if(beta1 >= 0 && beta1 > Math.PI) {
							f34 = beta1;
						} else {
							var a34 = beta1 % (2 * Math.PI);
							f34 = a34 >= 0 ? a34 : a34 + 2 * Math.PI;
						}
						var this90 = f34;
						var za16 = this90;
						var f35;
						if(gamma4 >= 0 && gamma4 > Math.PI) {
							f35 = gamma4;
						} else {
							var a35 = gamma4 % (2 * Math.PI);
							f35 = a35 >= 0 ? a35 : a35 + 2 * Math.PI;
						}
						var this91 = f35;
						var zb16 = this91;
						var fa16 = za16;
						var fb16 = zb16;
						var theta21 = Math.abs(beta1 - gamma4);
						var clockwise16 = beta1 < gamma4;
						var dif21 = clockwise16 ? theta21 : -theta21;
						dif20 = dif21 > 0 ? dif21 : 2 * Math.PI + dif21;
						break;
					case 1:
						var f36;
						if(beta1 >= 0 && beta1 > Math.PI) {
							f36 = beta1;
						} else {
							var a36 = beta1 % (2 * Math.PI);
							f36 = a36 >= 0 ? a36 : a36 + 2 * Math.PI;
						}
						var this92 = f36;
						var za17 = this92;
						var f37;
						if(gamma4 >= 0 && gamma4 > Math.PI) {
							f37 = gamma4;
						} else {
							var a37 = gamma4 % (2 * Math.PI);
							f37 = a37 >= 0 ? a37 : a37 + 2 * Math.PI;
						}
						var this93 = f37;
						var zb17 = this93;
						var fa17 = za17;
						var fb17 = zb17;
						var theta22 = Math.abs(beta1 - gamma4);
						var clockwise17 = beta1 < gamma4;
						var dif22 = clockwise17 ? theta22 : -theta22;
						dif20 = dif22 < 0 ? dif22 : -2 * Math.PI + dif22;
						break;
					case 2:
						var f38;
						if(beta1 >= 0 && beta1 > Math.PI) {
							f38 = beta1;
						} else {
							var a38 = beta1 % (2 * Math.PI);
							f38 = a38 >= 0 ? a38 : a38 + 2 * Math.PI;
						}
						var this94 = f38;
						var za18 = this94;
						var f39;
						if(gamma4 >= 0 && gamma4 > Math.PI) {
							f39 = gamma4;
						} else {
							var a39 = gamma4 % (2 * Math.PI);
							f39 = a39 >= 0 ? a39 : a39 + 2 * Math.PI;
						}
						var this95 = f39;
						var zb18 = this95;
						var fa18 = beta1;
						var fb18 = gamma4;
						var theta23 = Math.abs(beta1 - gamma4);
						var smallest4 = theta23 <= Math.PI;
						var clockwise18 = beta1 < gamma4;
						var dif23 = clockwise18 ? theta23 : -theta23;
						dif20 = smallest4 ? dif23 : clockwise18 ? -(2 * Math.PI - theta23) : 2 * Math.PI - theta23;
						break;
					case 3:
						var f40;
						if(beta1 >= 0 && beta1 > Math.PI) {
							f40 = beta1;
						} else {
							var a40 = beta1 % (2 * Math.PI);
							f40 = a40 >= 0 ? a40 : a40 + 2 * Math.PI;
						}
						var this96 = f40;
						var za19 = this96;
						var f41;
						if(gamma4 >= 0 && gamma4 > Math.PI) {
							f41 = gamma4;
						} else {
							var a41 = gamma4 % (2 * Math.PI);
							f41 = a41 >= 0 ? a41 : a41 + 2 * Math.PI;
						}
						var this97 = f41;
						var zb19 = this97;
						var fa19 = beta1;
						var fb19 = gamma4;
						var theta24 = Math.abs(beta1 - gamma4);
						var largest4 = theta24 > Math.PI;
						var clockwise19 = beta1 < gamma4;
						var dif24 = clockwise19 ? theta24 : -theta24;
						dif20 = largest4 ? dif24 : clockwise19 ? -(2 * Math.PI - theta24) : 2 * Math.PI - theta24;
						break;
					}
					var positive4 = dif20 >= 0;
					var totalSteps4 = Math.ceil(Math.abs(dif20) / step11);
					var step12 = dif20 / totalSteps4;
					var angle4 = beta1;
					var cx7;
					var cy7;
					var bx7 = 0;
					var by7 = 0;
					var p23 = temp1.length;
					var _g30 = 0;
					var _g114 = totalSteps4 + 1;
					while(_g30 < _g114) {
						var i17 = _g30++;
						cx7 = ax1 + radius7 * Math.sin(angle4);
						cy7 = ay1 + radius7 * Math.cos(angle4);
						temp1[p23++] = cx7;
						temp1[p23++] = cy7;
						if(i17 != 0) {
							var t33 = new trilateral_tri_Trilateral(ax1,ay1,bx7,by7,cx7,cy7);
							out7[out7.length] = t33;
						}
						angle4 += step12;
						bx7 = cx7;
						by7 = cy7;
					}
					var triArr6 = out7;
					var _g33 = 0;
					while(_g33 < triArr6.length) {
						var t34 = triArr6[_g33];
						++_g33;
						this86[this86.length] = t34;
					}
					var pA1 = _this7.pointsAnti.length;
					var len1 = temp1.length / 2 | 0;
					var p41 = temp1.length / 4 | 0;
					var _g34 = 0;
					var _g115 = p41;
					while(_g34 < _g115) {
						var i18 = _g34++;
						_this7.pointsAnti[pA1++] = temp1[len1 - 2 * i18 + 1];
						_this7.pointsAnti[pA1++] = temp1[len1 - 2 * i18];
					}
					var pC1 = _this7.pointsClock.length;
					var _g210 = 0;
					var _g35 = p41;
					while(_g210 < _g35) {
						var i19 = _g210++;
						_this7.pointsClock[pC1++] = temp1[i19 * 2 + len1 + 1];
						_this7.pointsClock[pC1++] = temp1[i19 * 2 + len1];
					}
				}
				if(_this7.count != 0) {
					_this7.addQuads(clockWise1,width_1);
				}
				_this7.quadIndex = _this7.triArr.length;
				if(_this7.count == 0) {
					_this7.penultimateAX = _this7.dxPrev;
					_this7.penultimateAY = _this7.dyPrev;
					_this7.lastAntiX = _this7.ex;
					_this7.lastAntiY = _this7.ey;
					_this7.penultimateCX = _this7.dx;
					_this7.penultimateCY = _this7.dy;
					_this7.lastClockX = _this7.exPrev;
					_this7.lastClockY = _this7.eyPrev;
					var this98 = _this7.triArr;
					var tri22 = new trilateral_tri_Trilateral(_this7.dxPrev,_this7.dyPrev,_this7.dx,_this7.dy,_this7.ex,_this7.ey,0);
					this98[this98.length] = tri22;
					var this99 = _this7.triArr;
					var tri23 = new trilateral_tri_Trilateral(_this7.dxPrev,_this7.dyPrev,_this7.dx,_this7.dy,_this7.exPrev,_this7.eyPrev,0);
					this99[this99.length] = tri23;
				} else {
					if(clockWise1 && !_this7.lastClock) {
						_this7.penultimateAX = _this7.jx;
						_this7.penultimateAY = _this7.jy;
						_this7.lastAntiX = _this7.ex;
						_this7.lastAntiY = _this7.ey;
						_this7.penultimateCX = _this7.dx;
						_this7.penultimateCY = _this7.dy;
						_this7.lastClockX = _this7.exPrev;
						_this7.lastClockY = _this7.eyPrev;
						var this100 = _this7.triArr;
						var tri24 = new trilateral_tri_Trilateral(_this7.jx,_this7.jy,_this7.dx,_this7.dy,_this7.ex,_this7.ey,0);
						this100[this100.length] = tri24;
						var this101 = _this7.triArr;
						var tri25 = new trilateral_tri_Trilateral(_this7.jx,_this7.jy,_this7.dx,_this7.dy,_this7.exPrev,_this7.eyPrev,0);
						this101[this101.length] = tri25;
					}
					if(clockWise1 && _this7.lastClock) {
						_this7.penultimateAX = _this7.jx;
						_this7.penultimateAY = _this7.jy;
						_this7.lastAntiX = _this7.ex;
						_this7.lastAntiY = _this7.ey;
						_this7.penultimateCX = _this7.dx;
						_this7.penultimateCY = _this7.dy;
						_this7.lastClockX = _this7.exPrev;
						_this7.lastClockY = _this7.eyPrev;
						var this102 = _this7.triArr;
						var tri26 = new trilateral_tri_Trilateral(_this7.jx,_this7.jy,_this7.dx,_this7.dy,_this7.ex,_this7.ey,0);
						this102[this102.length] = tri26;
						var this103 = _this7.triArr;
						var tri27 = new trilateral_tri_Trilateral(_this7.jx,_this7.jy,_this7.dx,_this7.dy,_this7.exPrev,_this7.eyPrev,0);
						this103[this103.length] = tri27;
					}
					if(!clockWise1 && !_this7.lastClock) {
						_this7.penultimateCX = _this7.dx;
						_this7.penultimateCY = _this7.dy;
						_this7.lastClockX = _this7.jx;
						_this7.lastClockY = _this7.jy;
						_this7.penultimateAX = _this7.dxPrev;
						_this7.penultimateAY = _this7.dyPrev;
						_this7.lastAntiX = _this7.ex;
						_this7.lastAntiY = _this7.ey;
						var this104 = _this7.triArr;
						var tri28 = new trilateral_tri_Trilateral(_this7.dxPrev,_this7.dyPrev,_this7.dx,_this7.dy,_this7.jx,_this7.jy,0);
						this104[this104.length] = tri28;
						var this105 = _this7.triArr;
						var tri29 = new trilateral_tri_Trilateral(_this7.dxPrev,_this7.dyPrev,_this7.dx,_this7.dy,_this7.ex,_this7.ey,0);
						this105[this105.length] = tri29;
					}
					if(!clockWise1 && _this7.lastClock) {
						_this7.penultimateAX = _this7.dxPrev;
						_this7.penultimateAY = _this7.dyPrev;
						_this7.lastAntiX = _this7.ex;
						_this7.lastAntiY = _this7.ey;
						_this7.penultimateCX = _this7.jx;
						_this7.penultimateCY = _this7.jy;
						_this7.lastClockX = _this7.dx;
						_this7.lastClockY = _this7.dy;
						var this106 = _this7.triArr;
						var tri30 = new trilateral_tri_Trilateral(_this7.jx,_this7.jy,_this7.dx,_this7.dy,_this7.ex,_this7.ey,0);
						this106[this106.length] = tri30;
						var this107 = _this7.triArr;
						var tri31 = new trilateral_tri_Trilateral(_this7.dxPrev,_this7.dyPrev,_this7.jx,_this7.jy,_this7.ex,_this7.ey,0);
						this107[this107.length] = tri31;
					}
				}
				if(clockWise1) {
					var radius8 = width_1 / 2;
					var edgePoly2 = _this7.pointsClock;
					var t35 = [];
					var this108;
					if(t35 == null) {
						var t36 = [];
						var this109 = t36 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t36;
						this108 = this109;
					} else {
						this108 = t35;
					}
					var this110 = this108;
					var out8 = this110;
					var pi8 = Math.PI;
					var step13 = pi8 * 2 / 36;
					var positive5 = dif15 >= 0;
					var totalSteps5 = Math.ceil(Math.abs(dif15) / step13);
					var step14 = dif15 / totalSteps5;
					var angle5 = theta01;
					var cx8;
					var cy8;
					var bx8 = 0;
					var by8 = 0;
					var p24 = edgePoly2.length;
					var count2 = 0;
					var _g36 = 0;
					var _g116 = totalSteps5 + 1;
					while(_g36 < _g116) {
						var i20 = _g36++;
						cx8 = ax_1 + radius8 * Math.sin(angle5);
						cy8 = ay_1 + radius8 * Math.cos(angle5);
						if(i20 != 0) {
							var t37 = new trilateral_tri_Trilateral(ax_1,ay_1,bx8,by8,cx8,cy8);
							out8[out8.length] = t37;
							edgePoly2[p24++] = cx8;
							edgePoly2[p24++] = cy8;
						}
						angle5 += step14;
						bx8 = cx8;
						by8 = cy8;
					}
					var trilateralArray2 = out8;
					var this111 = _this7.triArr;
					var _g37 = 0;
					while(_g37 < trilateralArray2.length) {
						var t38 = trilateralArray2[_g37];
						++_g37;
						this111[this111.length] = t38;
					}
				} else {
					var radius9 = width_1 / 2;
					var edgePoly3 = _this7.pointsAnti;
					var t39 = [];
					var this112;
					if(t39 == null) {
						var t40 = [];
						var this113 = t40 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t40;
						this112 = this113;
					} else {
						this112 = t39;
					}
					var this114 = this112;
					var out9 = this114;
					var pi9 = Math.PI;
					var step15 = pi9 * 2 / 36;
					var positive6 = dif15 >= 0;
					var totalSteps6 = Math.ceil(Math.abs(dif15) / step15);
					var step16 = dif15 / totalSteps6;
					var angle6 = theta01;
					var cx9;
					var cy9;
					var bx9 = 0;
					var by9 = 0;
					var p25 = edgePoly3.length;
					var count3 = 0;
					var _g38 = 0;
					var _g117 = totalSteps6 + 1;
					while(_g38 < _g117) {
						var i21 = _g38++;
						cx9 = ax_1 + radius9 * Math.sin(angle6);
						cy9 = ay_1 + radius9 * Math.cos(angle6);
						if(i21 != 0) {
							var t41 = new trilateral_tri_Trilateral(ax_1,ay_1,bx9,by9,cx9,cy9);
							out9[out9.length] = t41;
							edgePoly3[p25++] = cx9;
							edgePoly3[p25++] = cy9;
						}
						angle6 += step16;
						bx9 = cx9;
						by9 = cy9;
					}
					var trilateralArray3 = out9;
					var this115 = _this7.triArr;
					var _g39 = 0;
					while(_g39 < trilateralArray3.length) {
						var t42 = trilateralArray3[_g39];
						++_g39;
						this115[this115.length] = t42;
					}
				}
				_this7.kax = _this7.dxPrev;
				_this7.kay = _this7.dyPrev;
				_this7.kbx = _this7.dx;
				_this7.kby = _this7.dy;
				_this7.ncx = _this7.exPrev;
				_this7.ncy = _this7.eyPrev;
				_this7.kcx = _this7.ex;
				_this7.kcy = _this7.ey;
				if(_this7.count != 0) {
					if(clockWise1) {
						var this116 = _this7.triArr;
						var tri32 = new trilateral_tri_Trilateral(_this7.ax,_this7.ay,_this7.dxOld,_this7.dyOld,_this7.jx,_this7.jy,0);
						this116[this116.length] = tri32;
						var this117 = _this7.triArr;
						var tri33 = new trilateral_tri_Trilateral(_this7.ax,_this7.ay,_this7.exPrev,_this7.eyPrev,_this7.jx,_this7.jy,0);
						this117[this117.length] = tri33;
					} else {
						var this118 = _this7.triArr;
						var tri34 = new trilateral_tri_Trilateral(_this7.ax,_this7.ay,_this7.exOld,_this7.eyOld,_this7.jx,_this7.jy,0);
						this118[this118.length] = tri34;
						var this119 = _this7.triArr;
						var tri35 = new trilateral_tri_Trilateral(_this7.ax,_this7.ay,_this7.dxPrev,_this7.dyPrev,_this7.jx,_this7.jy,0);
						this119[this119.length] = tri35;
					}
				}
				_this7.jxOld = _this7.jx;
				_this7.jyOld = _this7.jy;
				_this7.lastClock = clockWise1;
				_this7.count++;
				var l1 = path1.points.length;
				var p1 = path1.points[l1 - 1];
				var l21 = p1.length;
				p1[l21] = x_1;
				p1[l21 + 1] = y_1;
				var d1 = path1.dim[path1.dim.length - 1];
				if(x_1 < d1.minX) {
					d1.minX = x_1;
				}
				if(x_1 > d1.maxX) {
					d1.maxX = x_1;
				}
				if(y_1 < d1.minY) {
					d1.minY = y_1;
				}
				if(y_1 > d1.maxY) {
					d1.maxY = y_1;
				}
				path1.x = x_1;
				path1.y = y_1;
			}
		}
		var this120 = this.triangles;
		var triArr7 = path1.trilateralArray;
		var colorID2 = this.appColors.indexOf(4473924);
		var tri36;
		var _g40 = 0;
		while(_g40 < triArr7.length) {
			var t43 = triArr7[_g40];
			++_g40;
			if(t43 != null) {
				var t44 = Object.create(trilateral_tri_Triangle.prototype);
				t44.id = 11;
				t44.ax = t43.ax;
				t44.ay = t43.ay;
				t44.bx = t43.bx;
				t44.by = t43.by;
				t44.cx = t43.cx;
				t44.cy = t43.cy;
				t44.mark = t43.mark;
				t44.depth = 0;
				t44.alpha = 1.;
				t44.colorID = colorID2;
				t44.colorA = colorID2;
				t44.colorB = colorID2;
				t44.colorC = colorID2;
				t44.windingAdjusted = t43.windingAdjusted;
				tri36 = t44;
				this120[this120.length] = tri36;
			}
		}
		var _gthis2 = this;
		var jointRender2 = function(i22,joint5) {
			var col = _gthis2.appColors.indexOf(16711680) + i22;
			if(col > 7) {
				col -= 7;
			}
			var _this8 = _gthis2.shapes;
			var x8 = joint5.x;
			var y8 = joint5.y;
			var radius10 = _gthis2.circleSize;
			var this121 = _this8.triangles;
			var id3 = _this8.refCount++;
			var t45 = [];
			var this122;
			if(t45 == null) {
				var t46 = [];
				var this123 = t46 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t46;
				this122 = this123;
			} else {
				this122 = t45;
			}
			var this124 = this122;
			var out10 = this124;
			var pi10 = Math.PI;
			var theta25 = pi10 / 2;
			var step17 = pi10 * 2 / 36;
			var bx10;
			var by10;
			var cx10;
			var cy10;
			var _g41 = 0;
			var _g118 = 36;
			while(_g41 < _g118) {
				var i23 = _g41++;
				bx10 = x8 + radius10 * Math.sin(theta25);
				by10 = y8 + radius10 * Math.cos(theta25);
				theta25 += step17;
				cx10 = x8 + radius10 * Math.sin(theta25);
				cy10 = y8 + radius10 * Math.cos(theta25);
				var tri37 = new trilateral_tri_Trilateral(x8,y8,bx10,by10,cx10,cy10);
				out10[out10.length] = tri37;
			}
			var triArr8 = out10;
			var tri38;
			var _g42 = 0;
			while(_g42 < triArr8.length) {
				var t47 = triArr8[_g42];
				++_g42;
				if(t47 != null) {
					var t48 = Object.create(trilateral_tri_Triangle.prototype);
					t48.id = id3;
					t48.ax = t47.ax;
					t48.ay = t47.ay;
					t48.bx = t47.bx;
					t48.by = t47.by;
					t48.cx = t47.cx;
					t48.cy = t47.cy;
					t48.mark = t47.mark;
					t48.depth = 0;
					t48.alpha = 1.;
					t48.colorID = col;
					t48.colorA = col;
					t48.colorB = col;
					t48.colorC = col;
					t48.windingAdjusted = t47.windingAdjusted;
					tri38 = t48;
					this121[this121.length] = tri38;
				}
			}
			return _this8.refCount - 1;
		};
		var _this9 = this.collisionDemo;
		var anchor6 = this.mousePos;
		var joint6;
		var mouseEdge = 2;
		var radius11 = _this9.distance + mouseEdge + _this9.circleSize / 2;
		var _g43 = 0;
		var _g119 = _this9.points;
		while(_g43 < _g119) {
			var i24 = _g43++;
			joint6 = _this9.joints[i24];
			var toNext_x1 = anchor6.x - joint6.x;
			var toNext_y1 = anchor6.y - joint6.y;
			var toNext_z1 = anchor6.z - joint6.z;
			var toNext_w1 = anchor6.w - joint6.w;
			if(Math.sqrt(toNext_x1 * toNext_x1 + toNext_y1 * toNext_y1 + toNext_z1 * toNext_z1 + toNext_w1 * toNext_w1) < radius11) {
				var currentLength4 = Math.sqrt(toNext_x1 * toNext_x1 + toNext_y1 * toNext_y1 + toNext_z1 * toNext_z1 + toNext_w1 * toNext_w1);
				if(currentLength4 != 0.) {
					var mul4 = radius11 / currentLength4;
					toNext_x1 *= mul4;
					toNext_y1 *= mul4;
					toNext_z1 *= mul4;
					toNext_w1 *= mul4;
					var tmp4 = toNext_x1 * toNext_x1 + toNext_y1 * toNext_y1 + toNext_z1 * toNext_z1 + toNext_w1 * toNext_w1;
				}
				var a_x8 = anchor6.x - joint6.x;
				var a_y8 = anchor6.y - joint6.y;
				var a_z8 = anchor6.z - joint6.z;
				var a_w8 = anchor6.w - joint6.w;
				var offset_x = a_x8 - toNext_x1;
				var offset_y = a_y8 - toNext_y1;
				var offset_z = a_z8 - toNext_z1;
				var offset_w = a_w8 - toNext_w1;
				var this125 = { x : joint6.x + offset_x, y : joint6.y + offset_y, z : joint6.z + offset_z, w : joint6.w + offset_w};
				_this9.joints[i24] = this125;
			}
		}
		var other;
		var _g211 = 0;
		var _g310 = _this9.points;
		while(_g211 < _g310) {
			var i25 = _g211++;
			var _g212 = i25;
			var _g311 = _this9.points;
			while(_g212 < _g311) {
				var j1 = _g212++;
				joint6 = _this9.joints[i25];
				other = _this9.joints[j1];
				var toNext_x2 = other.x - joint6.x;
				var toNext_y2 = other.y - joint6.y;
				var toNext_z2 = other.z - joint6.z;
				var toNext_w2 = other.w - joint6.w;
				if(Math.sqrt(toNext_x2 * toNext_x2 + toNext_y2 * toNext_y2 + toNext_z2 * toNext_z2 + toNext_w2 * toNext_w2) < _this9.circleSize * 2) {
					var currentLength5 = Math.sqrt(toNext_x2 * toNext_x2 + toNext_y2 * toNext_y2 + toNext_z2 * toNext_z2 + toNext_w2 * toNext_w2);
					if(currentLength5 != 0.) {
						var mul5 = _this9.circleSize * 2 / currentLength5;
						toNext_x2 *= mul5;
						toNext_y2 *= mul5;
						toNext_z2 *= mul5;
						toNext_w2 *= mul5;
						var tmp5 = toNext_x2 * toNext_x2 + toNext_y2 * toNext_y2 + toNext_z2 * toNext_z2 + toNext_w2 * toNext_w2;
					}
					var a_x9 = other.x - joint6.x;
					var a_y9 = other.y - joint6.y;
					var a_z9 = other.z - joint6.z;
					var a_w9 = other.w - joint6.w;
					var b_x = toNext_x2 * 0.5;
					var b_y = toNext_y2 * 0.5;
					var b_z = toNext_z2 * 0.5;
					var b_w = toNext_w2 * 0.5;
					var offset_x1 = a_x9 - b_x;
					var offset_y1 = a_y9 - b_y;
					var offset_z1 = a_z9 - b_z;
					var offset_w1 = a_w9 - b_w;
					var this126 = { x : joint6.x + offset_x1, y : joint6.y + offset_y1, z : joint6.z + offset_z1, w : joint6.w + offset_w1};
					_this9.joints[i25] = this126;
					var this127 = { x : other.x - offset_x1, y : other.y - offset_y1, z : other.z - offset_z1, w : other.w - offset_w1};
					_this9.joints[j1] = this127;
				}
			}
		}
		var _g44 = 0;
		var _g51 = _this9.points;
		while(_g44 < _g51) {
			var i26 = _g44++;
			jointRender2(i26,_this9.joints[i26]);
		}
		var tri39;
		var s = 1.;
		var ox = 0.;
		var oy = 0.;
		var g = this.surface;
		g.beginFill(1579032,1.);
		g.lineStyle(0.,0,0.);
		g.drawRect(1,1,2046,1534);
		g.endFill();
		var triangles = this.triangles;
		var triangleColors = this.appColors;
		var _g45 = 0;
		var _g120 = triangles.length;
		while(_g45 < _g120) {
			var i27 = _g45++;
			tri39 = triangles[i27];
			if(tri39.mark != 0) {
				g.beginFill(triangleColors[tri39.mark]);
			} else {
				g.beginFill(triangleColors[tri39.colorID]);
				g.lineStyle(0.,triangleColors[tri39.colorID],1.);
			}
			g.drawTri([ox + tri39.ax * s,oy + tri39.ay * s,ox + tri39.bx * s,oy + tri39.by * s,ox + tri39.cx * s,oy + tri39.cy * s]);
			g.endFill();
		}
	}
	,plotMousePos: function() {
		var x = this.mousePos.x;
		var y = this.mousePos.y;
		var radius = this.distance;
		var this1 = this.triangles;
		var gamma = 2 * Math.PI;
		var t = [];
		var this2;
		if(t == null) {
			var t1 = [];
			var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this2 = this3;
		} else {
			this2 = t;
		}
		var this4 = this2;
		var out = this4;
		var pi = Math.PI;
		var step = pi * 2 / 36;
		var dif;
		switch(trilateral_angle_DifferencePreference.CLOCKWISE._hx_index) {
		case 0:
			var f;
			if(0 > Math.PI) {
				f = 0;
			} else {
				var a = 0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this5 = f;
			var za = this5;
			var f1;
			if(gamma >= 0 && gamma > Math.PI) {
				f1 = gamma;
			} else {
				var a1 = gamma % (2 * Math.PI);
				f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
			}
			var this6 = f1;
			var zb = this6;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(0 - gamma);
			var clockwise = 0 < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f2;
			if(0 > Math.PI) {
				f2 = 0;
			} else {
				var a2 = 0 % (2 * Math.PI);
				f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
			}
			var this7 = f2;
			var za1 = this7;
			var f3;
			if(gamma >= 0 && gamma > Math.PI) {
				f3 = gamma;
			} else {
				var a3 = gamma % (2 * Math.PI);
				f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
			}
			var this8 = f3;
			var zb1 = this8;
			var fa1 = za1;
			var fb1 = zb1;
			var theta1 = Math.abs(0 - gamma);
			var clockwise1 = 0 < gamma;
			var dif2 = clockwise1 ? theta1 : -theta1;
			dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
			break;
		case 2:
			var f4;
			if(0 > Math.PI) {
				f4 = 0;
			} else {
				var a4 = 0 % (2 * Math.PI);
				f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
			}
			var this9 = f4;
			var za2 = this9;
			var f5;
			if(gamma >= 0 && gamma > Math.PI) {
				f5 = gamma;
			} else {
				var a5 = gamma % (2 * Math.PI);
				f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
			}
			var this10 = f5;
			var zb2 = this10;
			var fa2 = 0;
			var fb2 = gamma;
			var theta2 = Math.abs(0 - gamma);
			var smallest = theta2 <= Math.PI;
			var clockwise2 = 0 < gamma;
			var dif3 = clockwise2 ? theta2 : -theta2;
			dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
			break;
		case 3:
			var f6;
			if(0 > Math.PI) {
				f6 = 0;
			} else {
				var a6 = 0 % (2 * Math.PI);
				f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
			}
			var this11 = f6;
			var za3 = this11;
			var f7;
			if(gamma >= 0 && gamma > Math.PI) {
				f7 = gamma;
			} else {
				var a7 = gamma % (2 * Math.PI);
				f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
			}
			var this12 = f7;
			var zb3 = this12;
			var fa3 = 0;
			var fb3 = gamma;
			var theta3 = Math.abs(0 - gamma);
			var largest = theta3 > Math.PI;
			var clockwise3 = 0 < gamma;
			var dif4 = clockwise3 ? theta3 : -theta3;
			dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step1 = dif / totalSteps;
		var angle = 0;
		var cx;
		var cy;
		var bx = 0;
		var by = 0;
		var dx = 0;
		var dy = 0;
		var ex = 0;
		var ey = 0;
		var r2 = radius - 1;
		var _g = 0;
		var _g1 = totalSteps + 1;
		while(_g < _g1) {
			var i = _g++;
			cx = x + radius * Math.sin(angle);
			cy = y + radius * Math.cos(angle);
			ex = x + r2 * Math.sin(angle);
			ey = y + r2 * Math.cos(angle);
			if(i != 0) {
				var t0 = new trilateral_tri_Trilateral(dx,dy,bx,by,cx,cy);
				var t11 = new trilateral_tri_Trilateral(dx,dy,cx,cy,ex,ey);
				out[out.length] = t0;
				out[out.length] = t11;
			}
			angle += step1;
			bx = cx;
			by = cy;
			dx = ex;
			dy = ey;
		}
		var triArr = out;
		var colorID = this.appColors.indexOf(3355443);
		var tri;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t2 = triArr[_g2];
			++_g2;
			if(t2 != null) {
				var t3 = Object.create(trilateral_tri_Triangle.prototype);
				t3.id = 0;
				t3.ax = t2.ax;
				t3.ay = t2.ay;
				t3.bx = t2.bx;
				t3.by = t2.by;
				t3.cx = t2.cx;
				t3.cy = t2.cy;
				t3.mark = t2.mark;
				t3.depth = 0;
				t3.alpha = 1.;
				t3.colorID = colorID;
				t3.colorA = colorID;
				t3.colorB = colorID;
				t3.colorC = colorID;
				t3.windingAdjusted = t2.windingAdjusted;
				tri = t3;
				this1[this1.length] = tri;
			}
		}
	}
	,drawTriangles: function() {
		var tri;
		var s = 1.;
		var ox = 0.;
		var oy = 0.;
		var g = this.surface;
		g.beginFill(1579032,1.);
		g.lineStyle(0.,0,0.);
		g.drawRect(1,1,2046,1534);
		g.endFill();
		var triangles = this.triangles;
		var triangleColors = this.appColors;
		var _g = 0;
		var _g1 = triangles.length;
		while(_g < _g1) {
			var i = _g++;
			tri = triangles[i];
			if(tri.mark != 0) {
				g.beginFill(triangleColors[tri.mark]);
			} else {
				g.beginFill(triangleColors[tri.colorID]);
				g.lineStyle(0.,triangleColors[tri.colorID],1.);
			}
			g.drawTri([ox + tri.ax * s,oy + tri.ay * s,ox + tri.bx * s,oy + tri.by * s,ox + tri.cx * s,oy + tri.cy * s]);
			g.endFill();
		}
	}
	,linkSpots: function(index,spots,width,color) {
		var path = new trilateral_path_Fine(null,null,3);
		path.width = width;
		path.moveTo(spots[0].x,spots[0].y);
		var _g = 1;
		var _g1 = this.points;
		while(_g < _g1) {
			var i = _g++;
			var x_ = spots[i].x;
			var y_ = spots[i].y;
			var repeat = path.x == x_ && path.y == y_;
			if(!repeat) {
				if(path.widthFunction != null) {
					path.width = path.widthFunction(path.width,path.x,path.x,x_,y_);
				}
				var _this = path.contour;
				var ax_ = path.x;
				var ay_ = path.y;
				var width_ = path.width;
				var oldAngle = _this.dx != null ? _this.angle1 : null;
				_this.halfA = Math.PI / 2;
				_this.ax = x_;
				_this.ay = y_;
				_this.bx = ax_;
				_this.by = ay_;
				_this.beta = Math.PI / 2 - _this.halfA;
				_this.r = width_ / 2 * Math.cos(_this.beta);
				_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
				if(_this.theta > 0) {
					if(_this.halfA < 0) {
						_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
						_this.angle1 = _this.theta - _this.halfA;
					} else {
						_this.angle1 = _this.theta + _this.halfA - Math.PI;
						_this.angle2 = _this.theta + _this.halfA;
					}
				} else if(_this.halfA > 0) {
					_this.angle1 = _this.theta + _this.halfA - Math.PI;
					_this.angle2 = _this.theta + _this.halfA;
				} else {
					_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
					_this.angle1 = _this.theta - _this.halfA;
				}
				if(_this.dxPrev != null) {
					_this.dxOld = _this.dxPrev;
				}
				if(_this.dyPrev != null) {
					_this.dyOld = _this.dyPrev;
				}
				if(_this.exPrev != null) {
					_this.exOld = _this.exPrev;
				}
				if(_this.eyPrev != null) {
					_this.eyOld = _this.eyPrev;
				}
				if(_this.dx != null) {
					_this.dxPrev = _this.dx;
				}
				if(_this.dy != null) {
					_this.dyPrev = _this.dy;
				}
				if(_this.ex != null) {
					_this.exPrev = _this.ex;
				}
				if(_this.ey != null) {
					_this.eyPrev = _this.ey;
				}
				_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
				_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
				_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
				_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
				_this.ax = ax_;
				_this.ay = ay_;
				_this.bx = x_;
				_this.by = y_;
				_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
				if(_this.theta > 0) {
					if(_this.halfA < 0) {
						_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
						_this.angle1 = _this.theta - _this.halfA;
					} else {
						_this.angle1 = _this.theta + _this.halfA - Math.PI;
						_this.angle2 = _this.theta + _this.halfA;
					}
				} else if(_this.halfA > 0) {
					_this.angle1 = _this.theta + _this.halfA - Math.PI;
					_this.angle2 = _this.theta + _this.halfA;
				} else {
					_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
					_this.angle1 = _this.theta - _this.halfA;
				}
				if(_this.dxPrev != null) {
					_this.dxOld = _this.dxPrev;
				}
				if(_this.dyPrev != null) {
					_this.dyOld = _this.dyPrev;
				}
				if(_this.exPrev != null) {
					_this.exOld = _this.exPrev;
				}
				if(_this.eyPrev != null) {
					_this.eyOld = _this.eyPrev;
				}
				if(_this.dx != null) {
					_this.dxPrev = _this.dx;
				}
				if(_this.dy != null) {
					_this.dyPrev = _this.dy;
				}
				if(_this.ex != null) {
					_this.exPrev = _this.ex;
				}
				if(_this.ey != null) {
					_this.eyPrev = _this.ey;
				}
				_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
				_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
				_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
				_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
				var x = _this.dxOld - x_;
				var y = _this.dyOld - y_;
				var x1 = _this.exOld - x_;
				var y1 = _this.eyOld - y_;
				var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
				var theta0;
				var theta1;
				if(clockWise) {
					theta0 = -Math.atan2(_this.ay - _this.dyOld,_this.ax - _this.dxOld) - Math.PI / 2;
					theta1 = -Math.atan2(_this.ay - _this.eyPrev,_this.ax - _this.exPrev) - Math.PI / 2;
				} else {
					theta0 = -Math.atan2(_this.ay - _this.eyOld,_this.ax - _this.exOld) - Math.PI / 2;
					theta1 = -Math.atan2(_this.ay - _this.dyPrev,_this.ax - _this.dxPrev) - Math.PI / 2;
				}
				var dif;
				switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
				case 0:
					var f;
					if(theta0 >= 0 && theta0 > Math.PI) {
						f = theta0;
					} else {
						var a = theta0 % (2 * Math.PI);
						f = a >= 0 ? a : a + 2 * Math.PI;
					}
					var this1 = f;
					var za = this1;
					var f1;
					if(theta1 >= 0 && theta1 > Math.PI) {
						f1 = theta1;
					} else {
						var a1 = theta1 % (2 * Math.PI);
						f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
					}
					var this2 = f1;
					var zb = this2;
					var fa = za;
					var fb = zb;
					var theta = Math.abs(theta0 - theta1);
					var clockwise = theta0 < theta1;
					var dif1 = clockwise ? theta : -theta;
					dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
					break;
				case 1:
					var f2;
					if(theta0 >= 0 && theta0 > Math.PI) {
						f2 = theta0;
					} else {
						var a2 = theta0 % (2 * Math.PI);
						f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
					}
					var this3 = f2;
					var za1 = this3;
					var f3;
					if(theta1 >= 0 && theta1 > Math.PI) {
						f3 = theta1;
					} else {
						var a3 = theta1 % (2 * Math.PI);
						f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
					}
					var this4 = f3;
					var zb1 = this4;
					var fa1 = za1;
					var fb1 = zb1;
					var theta2 = Math.abs(theta0 - theta1);
					var clockwise1 = theta0 < theta1;
					var dif2 = clockwise1 ? theta2 : -theta2;
					dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
					break;
				case 2:
					var f4;
					if(theta0 >= 0 && theta0 > Math.PI) {
						f4 = theta0;
					} else {
						var a4 = theta0 % (2 * Math.PI);
						f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
					}
					var this5 = f4;
					var za2 = this5;
					var f5;
					if(theta1 >= 0 && theta1 > Math.PI) {
						f5 = theta1;
					} else {
						var a5 = theta1 % (2 * Math.PI);
						f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
					}
					var this6 = f5;
					var zb2 = this6;
					var fa2 = theta0;
					var fb2 = theta1;
					var theta3 = Math.abs(theta0 - theta1);
					var smallest = theta3 <= Math.PI;
					var clockwise2 = theta0 < theta1;
					var dif3 = clockwise2 ? theta3 : -theta3;
					dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
					break;
				case 3:
					var f6;
					if(theta0 >= 0 && theta0 > Math.PI) {
						f6 = theta0;
					} else {
						var a6 = theta0 % (2 * Math.PI);
						f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
					}
					var this7 = f6;
					var za3 = this7;
					var f7;
					if(theta1 >= 0 && theta1 > Math.PI) {
						f7 = theta1;
					} else {
						var a7 = theta1 % (2 * Math.PI);
						f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
					}
					var this8 = f7;
					var zb3 = this8;
					var fa3 = theta0;
					var fb3 = theta1;
					var theta4 = Math.abs(theta0 - theta1);
					var largest = theta4 > Math.PI;
					var clockwise3 = theta0 < theta1;
					var dif4 = clockwise3 ? theta4 : -theta4;
					dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta4) : 2 * Math.PI - theta4;
					break;
				}
				if(_this.count != 0) {
					var gamma = Math.abs(dif) / 2;
					var h = width_ / 2 / Math.cos(gamma);
					var f8;
					if(theta0 <= Math.PI && theta0 > -Math.PI) {
						f8 = theta0;
					} else {
						var a8 = (theta0 + Math.PI) % (2 * Math.PI);
						f8 = a8 >= 0 ? a8 - Math.PI : a8 + Math.PI;
					}
					var this9 = f8;
					var start = this9;
					var start2 = start;
					var delta = start2 + dif / 2 + Math.PI;
					_this.jx = _this.ax + h * Math.sin(delta);
					_this.jy = _this.ay + h * Math.cos(delta);
				}
				if(_this.count == 0 && (_this.endLine == 1 || _this.endLine == 3)) {
					var ax = _this.ax;
					var ay = _this.ay;
					var radius = width_ / 2;
					var beta = -_this.angle1 - Math.PI / 2;
					var gamma1 = -_this.angle1 - Math.PI / 2 + Math.PI;
					var temp = [];
					var this10 = _this.triArr;
					var t = [];
					var this11;
					if(t == null) {
						var t1 = [];
						var this12 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
						this11 = this12;
					} else {
						this11 = t;
					}
					var this13 = this11;
					var out = this13;
					var pi = Math.PI;
					var step = pi * 2 / 36;
					var dif5;
					switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
					case 0:
						var f9;
						if(beta >= 0 && beta > Math.PI) {
							f9 = beta;
						} else {
							var a9 = beta % (2 * Math.PI);
							f9 = a9 >= 0 ? a9 : a9 + 2 * Math.PI;
						}
						var this14 = f9;
						var za4 = this14;
						var f10;
						if(gamma1 >= 0 && gamma1 > Math.PI) {
							f10 = gamma1;
						} else {
							var a10 = gamma1 % (2 * Math.PI);
							f10 = a10 >= 0 ? a10 : a10 + 2 * Math.PI;
						}
						var this15 = f10;
						var zb4 = this15;
						var fa4 = za4;
						var fb4 = zb4;
						var theta5 = Math.abs(beta - gamma1);
						var clockwise4 = beta < gamma1;
						var dif6 = clockwise4 ? theta5 : -theta5;
						dif5 = dif6 > 0 ? dif6 : 2 * Math.PI + dif6;
						break;
					case 1:
						var f11;
						if(beta >= 0 && beta > Math.PI) {
							f11 = beta;
						} else {
							var a11 = beta % (2 * Math.PI);
							f11 = a11 >= 0 ? a11 : a11 + 2 * Math.PI;
						}
						var this16 = f11;
						var za5 = this16;
						var f12;
						if(gamma1 >= 0 && gamma1 > Math.PI) {
							f12 = gamma1;
						} else {
							var a12 = gamma1 % (2 * Math.PI);
							f12 = a12 >= 0 ? a12 : a12 + 2 * Math.PI;
						}
						var this17 = f12;
						var zb5 = this17;
						var fa5 = za5;
						var fb5 = zb5;
						var theta6 = Math.abs(beta - gamma1);
						var clockwise5 = beta < gamma1;
						var dif7 = clockwise5 ? theta6 : -theta6;
						dif5 = dif7 < 0 ? dif7 : -2 * Math.PI + dif7;
						break;
					case 2:
						var f13;
						if(beta >= 0 && beta > Math.PI) {
							f13 = beta;
						} else {
							var a13 = beta % (2 * Math.PI);
							f13 = a13 >= 0 ? a13 : a13 + 2 * Math.PI;
						}
						var this18 = f13;
						var za6 = this18;
						var f14;
						if(gamma1 >= 0 && gamma1 > Math.PI) {
							f14 = gamma1;
						} else {
							var a14 = gamma1 % (2 * Math.PI);
							f14 = a14 >= 0 ? a14 : a14 + 2 * Math.PI;
						}
						var this19 = f14;
						var zb6 = this19;
						var fa6 = beta;
						var fb6 = gamma1;
						var theta7 = Math.abs(beta - gamma1);
						var smallest1 = theta7 <= Math.PI;
						var clockwise6 = beta < gamma1;
						var dif8 = clockwise6 ? theta7 : -theta7;
						dif5 = smallest1 ? dif8 : clockwise6 ? -(2 * Math.PI - theta7) : 2 * Math.PI - theta7;
						break;
					case 3:
						var f15;
						if(beta >= 0 && beta > Math.PI) {
							f15 = beta;
						} else {
							var a15 = beta % (2 * Math.PI);
							f15 = a15 >= 0 ? a15 : a15 + 2 * Math.PI;
						}
						var this20 = f15;
						var za7 = this20;
						var f16;
						if(gamma1 >= 0 && gamma1 > Math.PI) {
							f16 = gamma1;
						} else {
							var a16 = gamma1 % (2 * Math.PI);
							f16 = a16 >= 0 ? a16 : a16 + 2 * Math.PI;
						}
						var this21 = f16;
						var zb7 = this21;
						var fa7 = beta;
						var fb7 = gamma1;
						var theta8 = Math.abs(beta - gamma1);
						var largest1 = theta8 > Math.PI;
						var clockwise7 = beta < gamma1;
						var dif9 = clockwise7 ? theta8 : -theta8;
						dif5 = largest1 ? dif9 : clockwise7 ? -(2 * Math.PI - theta8) : 2 * Math.PI - theta8;
						break;
					}
					var positive = dif5 >= 0;
					var totalSteps = Math.ceil(Math.abs(dif5) / step);
					var step1 = dif5 / totalSteps;
					var angle = beta;
					var cx;
					var cy;
					var bx = 0;
					var by = 0;
					var p2 = temp.length;
					var _g2 = 0;
					var _g11 = totalSteps + 1;
					while(_g2 < _g11) {
						var i1 = _g2++;
						cx = ax + radius * Math.sin(angle);
						cy = ay + radius * Math.cos(angle);
						temp[p2++] = cx;
						temp[p2++] = cy;
						if(i1 != 0) {
							var t2 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
							out[out.length] = t2;
						}
						angle += step1;
						bx = cx;
						by = cy;
					}
					var triArr = out;
					var _g3 = 0;
					while(_g3 < triArr.length) {
						var t3 = triArr[_g3];
						++_g3;
						this10[this10.length] = t3;
					}
					var pA = _this.pointsAnti.length;
					var len = temp.length / 2 | 0;
					var p4 = temp.length / 4 | 0;
					var _g4 = 0;
					var _g12 = p4;
					while(_g4 < _g12) {
						var i2 = _g4++;
						_this.pointsAnti[pA++] = temp[len - 2 * i2 + 1];
						_this.pointsAnti[pA++] = temp[len - 2 * i2];
					}
					var pC = _this.pointsClock.length;
					var _g21 = 0;
					var _g31 = p4;
					while(_g21 < _g31) {
						var i3 = _g21++;
						_this.pointsClock[pC++] = temp[i3 * 2 + len + 1];
						_this.pointsClock[pC++] = temp[i3 * 2 + len];
					}
				}
				if(_this.count != 0) {
					_this.addQuads(clockWise,width_);
				}
				_this.quadIndex = _this.triArr.length;
				if(_this.count == 0) {
					_this.penultimateAX = _this.dxPrev;
					_this.penultimateAY = _this.dyPrev;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					_this.penultimateCX = _this.dx;
					_this.penultimateCY = _this.dy;
					_this.lastClockX = _this.exPrev;
					_this.lastClockY = _this.eyPrev;
					var this22 = _this.triArr;
					var tri = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.dx,_this.dy,_this.ex,_this.ey,0);
					this22[this22.length] = tri;
					var this23 = _this.triArr;
					var tri1 = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.dx,_this.dy,_this.exPrev,_this.eyPrev,0);
					this23[this23.length] = tri1;
				} else {
					if(clockWise && !_this.lastClock) {
						_this.penultimateAX = _this.jx;
						_this.penultimateAY = _this.jy;
						_this.lastAntiX = _this.ex;
						_this.lastAntiY = _this.ey;
						_this.penultimateCX = _this.dx;
						_this.penultimateCY = _this.dy;
						_this.lastClockX = _this.exPrev;
						_this.lastClockY = _this.eyPrev;
						var this24 = _this.triArr;
						var tri2 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.ex,_this.ey,0);
						this24[this24.length] = tri2;
						var this25 = _this.triArr;
						var tri3 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.exPrev,_this.eyPrev,0);
						this25[this25.length] = tri3;
					}
					if(clockWise && _this.lastClock) {
						_this.penultimateAX = _this.jx;
						_this.penultimateAY = _this.jy;
						_this.lastAntiX = _this.ex;
						_this.lastAntiY = _this.ey;
						_this.penultimateCX = _this.dx;
						_this.penultimateCY = _this.dy;
						_this.lastClockX = _this.exPrev;
						_this.lastClockY = _this.eyPrev;
						var this26 = _this.triArr;
						var tri4 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.ex,_this.ey,0);
						this26[this26.length] = tri4;
						var this27 = _this.triArr;
						var tri5 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.exPrev,_this.eyPrev,0);
						this27[this27.length] = tri5;
					}
					if(!clockWise && !_this.lastClock) {
						_this.penultimateCX = _this.dx;
						_this.penultimateCY = _this.dy;
						_this.lastClockX = _this.jx;
						_this.lastClockY = _this.jy;
						_this.penultimateAX = _this.dxPrev;
						_this.penultimateAY = _this.dyPrev;
						_this.lastAntiX = _this.ex;
						_this.lastAntiY = _this.ey;
						var this28 = _this.triArr;
						var tri6 = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.dx,_this.dy,_this.jx,_this.jy,0);
						this28[this28.length] = tri6;
						var this29 = _this.triArr;
						var tri7 = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.dx,_this.dy,_this.ex,_this.ey,0);
						this29[this29.length] = tri7;
					}
					if(!clockWise && _this.lastClock) {
						_this.penultimateAX = _this.dxPrev;
						_this.penultimateAY = _this.dyPrev;
						_this.lastAntiX = _this.ex;
						_this.lastAntiY = _this.ey;
						_this.penultimateCX = _this.jx;
						_this.penultimateCY = _this.jy;
						_this.lastClockX = _this.dx;
						_this.lastClockY = _this.dy;
						var this30 = _this.triArr;
						var tri8 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.ex,_this.ey,0);
						this30[this30.length] = tri8;
						var this31 = _this.triArr;
						var tri9 = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.jx,_this.jy,_this.ex,_this.ey,0);
						this31[this31.length] = tri9;
					}
				}
				if(clockWise) {
					var radius1 = width_ / 2;
					var edgePoly = _this.pointsClock;
					var t4 = [];
					var this32;
					if(t4 == null) {
						var t5 = [];
						var this33 = t5 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t5;
						this32 = this33;
					} else {
						this32 = t4;
					}
					var this34 = this32;
					var out1 = this34;
					var pi1 = Math.PI;
					var step2 = pi1 * 2 / 36;
					var positive1 = dif >= 0;
					var totalSteps1 = Math.ceil(Math.abs(dif) / step2);
					var step3 = dif / totalSteps1;
					var angle1 = theta0;
					var cx1;
					var cy1;
					var bx1 = 0;
					var by1 = 0;
					var p21 = edgePoly.length;
					var count = 0;
					var _g5 = 0;
					var _g13 = totalSteps1 + 1;
					while(_g5 < _g13) {
						var i4 = _g5++;
						cx1 = ax_ + radius1 * Math.sin(angle1);
						cy1 = ay_ + radius1 * Math.cos(angle1);
						if(i4 != 0) {
							var t6 = new trilateral_tri_Trilateral(ax_,ay_,bx1,by1,cx1,cy1);
							out1[out1.length] = t6;
							edgePoly[p21++] = cx1;
							edgePoly[p21++] = cy1;
						}
						angle1 += step3;
						bx1 = cx1;
						by1 = cy1;
					}
					var trilateralArray = out1;
					var this35 = _this.triArr;
					var _g6 = 0;
					while(_g6 < trilateralArray.length) {
						var t7 = trilateralArray[_g6];
						++_g6;
						this35[this35.length] = t7;
					}
				} else {
					var radius2 = width_ / 2;
					var edgePoly1 = _this.pointsAnti;
					var t8 = [];
					var this36;
					if(t8 == null) {
						var t9 = [];
						var this37 = t9 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t9;
						this36 = this37;
					} else {
						this36 = t8;
					}
					var this38 = this36;
					var out2 = this38;
					var pi2 = Math.PI;
					var step4 = pi2 * 2 / 36;
					var positive2 = dif >= 0;
					var totalSteps2 = Math.ceil(Math.abs(dif) / step4);
					var step5 = dif / totalSteps2;
					var angle2 = theta0;
					var cx2;
					var cy2;
					var bx2 = 0;
					var by2 = 0;
					var p22 = edgePoly1.length;
					var count1 = 0;
					var _g7 = 0;
					var _g14 = totalSteps2 + 1;
					while(_g7 < _g14) {
						var i5 = _g7++;
						cx2 = ax_ + radius2 * Math.sin(angle2);
						cy2 = ay_ + radius2 * Math.cos(angle2);
						if(i5 != 0) {
							var t10 = new trilateral_tri_Trilateral(ax_,ay_,bx2,by2,cx2,cy2);
							out2[out2.length] = t10;
							edgePoly1[p22++] = cx2;
							edgePoly1[p22++] = cy2;
						}
						angle2 += step5;
						bx2 = cx2;
						by2 = cy2;
					}
					var trilateralArray1 = out2;
					var this39 = _this.triArr;
					var _g8 = 0;
					while(_g8 < trilateralArray1.length) {
						var t11 = trilateralArray1[_g8];
						++_g8;
						this39[this39.length] = t11;
					}
				}
				_this.kax = _this.dxPrev;
				_this.kay = _this.dyPrev;
				_this.kbx = _this.dx;
				_this.kby = _this.dy;
				_this.ncx = _this.exPrev;
				_this.ncy = _this.eyPrev;
				_this.kcx = _this.ex;
				_this.kcy = _this.ey;
				if(_this.count != 0) {
					if(clockWise) {
						var this40 = _this.triArr;
						var tri10 = new trilateral_tri_Trilateral(_this.ax,_this.ay,_this.dxOld,_this.dyOld,_this.jx,_this.jy,0);
						this40[this40.length] = tri10;
						var this41 = _this.triArr;
						var tri11 = new trilateral_tri_Trilateral(_this.ax,_this.ay,_this.exPrev,_this.eyPrev,_this.jx,_this.jy,0);
						this41[this41.length] = tri11;
					} else {
						var this42 = _this.triArr;
						var tri12 = new trilateral_tri_Trilateral(_this.ax,_this.ay,_this.exOld,_this.eyOld,_this.jx,_this.jy,0);
						this42[this42.length] = tri12;
						var this43 = _this.triArr;
						var tri13 = new trilateral_tri_Trilateral(_this.ax,_this.ay,_this.dxPrev,_this.dyPrev,_this.jx,_this.jy,0);
						this43[this43.length] = tri13;
					}
				}
				_this.jxOld = _this.jx;
				_this.jyOld = _this.jy;
				_this.lastClock = clockWise;
				_this.count++;
				var l = path.points.length;
				var p = path.points[l - 1];
				var l2 = p.length;
				p[l2] = x_;
				p[l2 + 1] = y_;
				var d = path.dim[path.dim.length - 1];
				if(x_ < d.minX) {
					d.minX = x_;
				}
				if(x_ > d.maxX) {
					d.maxX = x_;
				}
				if(y_ < d.minY) {
					d.minY = y_;
				}
				if(y_ > d.maxY) {
					d.maxY = y_;
				}
				path.x = x_;
				path.y = y_;
			}
		}
		var this44 = this.triangles;
		var triArr1 = path.trilateralArray;
		var colorID = this.appColors.indexOf(color);
		var tri14;
		var _g9 = 0;
		while(_g9 < triArr1.length) {
			var t12 = triArr1[_g9];
			++_g9;
			if(t12 != null) {
				var t13 = Object.create(trilateral_tri_Triangle.prototype);
				t13.id = index;
				t13.ax = t12.ax;
				t13.ay = t12.ay;
				t13.bx = t12.bx;
				t13.by = t12.by;
				t13.cx = t12.cx;
				t13.cy = t12.cy;
				t13.mark = t12.mark;
				t13.depth = 0;
				t13.alpha = 1.;
				t13.colorID = colorID;
				t13.colorA = colorID;
				t13.colorB = colorID;
				t13.colorC = colorID;
				t13.windingAdjusted = t12.windingAdjusted;
				tri14 = t13;
				this44[this44.length] = tri14;
			}
		}
	}
};
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x, x && x[0]=="0" && (x[1]=="x" || x[1]=="X") ? 16 : 10);
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.hex = function(n,digits) {
	var s = "";
	var hexChars = "0123456789ABCDEF";
	while(true) {
		s = hexChars.charAt(n & 15) + s;
		n >>>= 4;
		if(!(n > 0)) {
			break;
		}
	}
	if(digits != null) {
		while(s.length < digits) s = "0" + s;
	}
	return s;
};
var constraints_demo_Chain = function(x,y,points_,distance_) {
	this.joints = [];
	this.distance = distance_;
	this.points = points_;
	var _g = 0;
	var _g1 = this.points;
	while(_g < _g1) {
		var i = _g++;
		var this1 = { x : x + i * this.distance, y : y, z : 0., w : 1.};
		this.joints[i] = this1;
	}
};
constraints_demo_Chain.__name__ = true;
constraints_demo_Chain.prototype = {
	update: function(anchor,render) {
		var joint = this.joints[0];
		joint.x = anchor.x;
		joint.y = anchor.y;
		render(0,joint);
		var _g = 1;
		var _g1 = this.points;
		while(_g < _g1) {
			var i = _g++;
			var this1 = this.joints[i];
			var anchor1 = this.joints[i - 1];
			var distance = this.distance;
			var a_x = this1.x - anchor1.x;
			var a_y = this1.y - anchor1.y;
			var a_z = this1.z - anchor1.z;
			var a_w = this1.w - anchor1.w;
			var currentLength = Math.sqrt(a_x * a_x + a_y * a_y + a_z * a_z + a_w * a_w);
			if(currentLength != 0.) {
				var mul = 1. / currentLength;
				a_x *= mul;
				a_y *= mul;
				a_z *= mul;
				a_w *= mul;
				var tmp = a_x * a_x + a_y * a_y + a_z * a_z + a_w * a_w;
			}
			var a_x1 = a_x * distance;
			var a_y1 = a_y * distance;
			var a_z1 = a_z * distance;
			var a_w1 = a_w * distance;
			var this2 = { x : a_x1 + anchor1.x, y : a_y1 + anchor1.y, z : a_z1 + anchor1.z, w : a_w1 + anchor1.w};
			this.joints[i] = this2;
			joint = this.joints[i];
			render(i,joint);
		}
	}
};
var constraints_demo_Collision = function(x_,y_,points_,circleSize_,collisionArea,distance_) {
	this.joints = [];
	this.x = x_;
	this.y = y_;
	this.distance = distance_;
	this.points = points_;
	this.circleSize = circleSize_;
	var _g = 0;
	var _g1 = this.points;
	while(_g < _g1) {
		var i = _g++;
		var x0 = this.x / 2 + collisionArea * Math.random();
		var y0 = this.y / 2 + collisionArea * Math.random();
		var this1 = { x : x0, y : y0, z : 0., w : 1.};
		this.joints[i] = this1;
	}
};
constraints_demo_Collision.__name__ = true;
constraints_demo_Collision.prototype = {
	update: function(anchor,render) {
		var joint;
		var mouseEdge = 2;
		var radius = this.distance + mouseEdge + this.circleSize / 2;
		var _g = 0;
		var _g1 = this.points;
		while(_g < _g1) {
			var i = _g++;
			joint = this.joints[i];
			var toNext_x = anchor.x - joint.x;
			var toNext_y = anchor.y - joint.y;
			var toNext_z = anchor.z - joint.z;
			var toNext_w = anchor.w - joint.w;
			if(Math.sqrt(toNext_x * toNext_x + toNext_y * toNext_y + toNext_z * toNext_z + toNext_w * toNext_w) < radius) {
				var currentLength = Math.sqrt(toNext_x * toNext_x + toNext_y * toNext_y + toNext_z * toNext_z + toNext_w * toNext_w);
				if(currentLength != 0.) {
					var mul = radius / currentLength;
					toNext_x *= mul;
					toNext_y *= mul;
					toNext_z *= mul;
					toNext_w *= mul;
					var tmp = toNext_x * toNext_x + toNext_y * toNext_y + toNext_z * toNext_z + toNext_w * toNext_w;
				}
				var a_x = anchor.x - joint.x;
				var a_y = anchor.y - joint.y;
				var a_z = anchor.z - joint.z;
				var a_w = anchor.w - joint.w;
				var offset_x = a_x - toNext_x;
				var offset_y = a_y - toNext_y;
				var offset_z = a_z - toNext_z;
				var offset_w = a_w - toNext_w;
				var this1 = { x : joint.x + offset_x, y : joint.y + offset_y, z : joint.z + offset_z, w : joint.w + offset_w};
				this.joints[i] = this1;
			}
		}
		var other;
		var _g2 = 0;
		var _g3 = this.points;
		while(_g2 < _g3) {
			var i1 = _g2++;
			var _g21 = i1;
			var _g31 = this.points;
			while(_g21 < _g31) {
				var j = _g21++;
				joint = this.joints[i1];
				other = this.joints[j];
				var toNext_x1 = other.x - joint.x;
				var toNext_y1 = other.y - joint.y;
				var toNext_z1 = other.z - joint.z;
				var toNext_w1 = other.w - joint.w;
				if(Math.sqrt(toNext_x1 * toNext_x1 + toNext_y1 * toNext_y1 + toNext_z1 * toNext_z1 + toNext_w1 * toNext_w1) < this.circleSize * 2) {
					var currentLength1 = Math.sqrt(toNext_x1 * toNext_x1 + toNext_y1 * toNext_y1 + toNext_z1 * toNext_z1 + toNext_w1 * toNext_w1);
					if(currentLength1 != 0.) {
						var mul1 = this.circleSize * 2 / currentLength1;
						toNext_x1 *= mul1;
						toNext_y1 *= mul1;
						toNext_z1 *= mul1;
						toNext_w1 *= mul1;
						var tmp1 = toNext_x1 * toNext_x1 + toNext_y1 * toNext_y1 + toNext_z1 * toNext_z1 + toNext_w1 * toNext_w1;
					}
					var a_x1 = other.x - joint.x;
					var a_y1 = other.y - joint.y;
					var a_z1 = other.z - joint.z;
					var a_w1 = other.w - joint.w;
					var b_x = toNext_x1 * 0.5;
					var b_y = toNext_y1 * 0.5;
					var b_z = toNext_z1 * 0.5;
					var b_w = toNext_w1 * 0.5;
					var offset_x1 = a_x1 - b_x;
					var offset_y1 = a_y1 - b_y;
					var offset_z1 = a_z1 - b_z;
					var offset_w1 = a_w1 - b_w;
					var this2 = { x : joint.x + offset_x1, y : joint.y + offset_y1, z : joint.z + offset_z1, w : joint.w + offset_w1};
					this.joints[i1] = this2;
					var this3 = { x : other.x - offset_x1, y : other.y - offset_y1, z : other.z - offset_z1, w : other.w - offset_w1};
					this.joints[j] = this3;
				}
			}
		}
		var _g4 = 0;
		var _g5 = this.points;
		while(_g4 < _g5) {
			var i2 = _g4++;
			render(i2,this.joints[i2]);
		}
	}
};
var constraints_demo_Fabrik = function(x_,y_,points_,distance_) {
	this.joints = [];
	this.x = x_;
	this.y = y_;
	this.distance = distance_;
	this.points = points_;
	var _g = 0;
	var _g1 = this.points;
	while(_g < _g1) {
		var i = _g++;
		var this1 = { x : this.x + i * this.distance, y : this.y, z : 0., w : 1.};
		this.joints[i] = this1;
	}
};
constraints_demo_Fabrik.__name__ = true;
constraints_demo_Fabrik.prototype = {
	update: function(anchor,render) {
		var joint = this.joints[0];
		joint.x = anchor.x;
		joint.y = anchor.y;
		render(0,joint);
		var _g = 1;
		var _g1 = this.points;
		while(_g < _g1) {
			var i = _g++;
			var this1 = this.joints[i];
			var anchor1 = this.joints[i - 1];
			var distance = this.distance;
			var a_x = this1.x - anchor1.x;
			var a_y = this1.y - anchor1.y;
			var a_z = this1.z - anchor1.z;
			var a_w = this1.w - anchor1.w;
			var currentLength = Math.sqrt(a_x * a_x + a_y * a_y + a_z * a_z + a_w * a_w);
			if(currentLength != 0.) {
				var mul = 1. / currentLength;
				a_x *= mul;
				a_y *= mul;
				a_z *= mul;
				a_w *= mul;
				var tmp = a_x * a_x + a_y * a_y + a_z * a_z + a_w * a_w;
			}
			var a_x1 = a_x * distance;
			var a_y1 = a_y * distance;
			var a_z1 = a_z * distance;
			var a_w1 = a_w * distance;
			var this2 = { x : a_x1 + anchor1.x, y : a_y1 + anchor1.y, z : a_z1 + anchor1.z, w : a_w1 + anchor1.w};
			this.joints[i] = this2;
		}
		var j;
		var joint1 = this.joints[this.points - 1];
		joint1.x = this.x;
		joint1.y = this.y;
		render(this.points - 1,joint1);
		var _g2 = 1;
		var _g3 = this.points;
		while(_g2 < _g3) {
			var i1 = _g2++;
			j = this.points - i1;
			var this3 = this.joints[j - 1];
			var anchor2 = this.joints[j];
			var distance1 = this.distance;
			var a_x2 = this3.x - anchor2.x;
			var a_y2 = this3.y - anchor2.y;
			var a_z2 = this3.z - anchor2.z;
			var a_w2 = this3.w - anchor2.w;
			var currentLength1 = Math.sqrt(a_x2 * a_x2 + a_y2 * a_y2 + a_z2 * a_z2 + a_w2 * a_w2);
			if(currentLength1 != 0.) {
				var mul1 = 1. / currentLength1;
				a_x2 *= mul1;
				a_y2 *= mul1;
				a_z2 *= mul1;
				a_w2 *= mul1;
				var tmp1 = a_x2 * a_x2 + a_y2 * a_y2 + a_z2 * a_z2 + a_w2 * a_w2;
			}
			var a_x3 = a_x2 * distance1;
			var a_y3 = a_y2 * distance1;
			var a_z3 = a_z2 * distance1;
			var a_w3 = a_w2 * distance1;
			var this4 = { x : a_x3 + anchor2.x, y : a_y3 + anchor2.y, z : a_z3 + anchor2.z, w : a_w3 + anchor2.w};
			this.joints[j - 1] = this4;
			joint1 = this.joints[j - 1];
			render(j,joint1);
		}
	}
};
var constraints_demo_Inner = function(x,y,distance_) {
	var this1 = { x : x, y : y, z : 0., w : 1.};
	this.point = this1;
	this.distance = distance_;
};
constraints_demo_Inner.__name__ = true;
constraints_demo_Inner.prototype = {
	update: function(anchor) {
		var b = this.point;
		var toNext_x = anchor.x - b.x;
		var toNext_y = anchor.y - b.y;
		var toNext_z = anchor.z - b.z;
		var toNext_w = anchor.w - b.w;
		if(Math.sqrt(toNext_x * toNext_x + toNext_y * toNext_y + toNext_z * toNext_z + toNext_w * toNext_w) > this.distance) {
			var this1 = this.point;
			var distance = this.distance;
			var a_x = this1.x - anchor.x;
			var a_y = this1.y - anchor.y;
			var a_z = this1.z - anchor.z;
			var a_w = this1.w - anchor.w;
			var currentLength = Math.sqrt(a_x * a_x + a_y * a_y + a_z * a_z + a_w * a_w);
			if(currentLength != 0.) {
				var mul = 1. / currentLength;
				a_x *= mul;
				a_y *= mul;
				a_z *= mul;
				a_w *= mul;
				var tmp = a_x * a_x + a_y * a_y + a_z * a_z + a_w * a_w;
			}
			var a_x1 = a_x * distance;
			var a_y1 = a_y * distance;
			var a_z1 = a_z * distance;
			var a_w1 = a_w * distance;
			var this2 = { x : a_x1 + anchor.x, y : a_y1 + anchor.y, z : a_z1 + anchor.z, w : a_w1 + anchor.w};
			this.point = this2;
			console.log("constraints/demo/Inner.hx:19:",this.point.x + " " + this.point.y);
		}
	}
};
var geom_Cpoint = function(x_,y_) {
	if(y_ == null) {
		y_ = 0;
	}
	if(x_ == null) {
		x_ = 0;
	}
	this.x = x_;
	this.y = y_;
};
geom_Cpoint.__name__ = true;
var geom_Cpoint4 = function(x_,y_,z_,w_) {
	if(w_ == null) {
		w_ = 1.;
	}
	if(z_ == null) {
		z_ = 0;
	}
	if(y_ == null) {
		y_ = 0;
	}
	if(x_ == null) {
		x_ = 0;
	}
	this.x = x_;
	this.y = y_;
	this.z = z_;
	this.w = w_;
};
geom_Cpoint4.__name__ = true;
var geom__$Tpoint_Apoint_$Impl_$ = {};
geom__$Tpoint_Apoint_$Impl_$.__name__ = true;
geom__$Tpoint_Apoint_$Impl_$._new = function(p) {
	var this1 = p;
	return this1;
};
geom__$Tpoint_Apoint_$Impl_$.get_magnitude = function(this1) {
	return Math.sqrt(this1.x * this1.x + this1.y * this1.y);
};
geom__$Tpoint_Apoint_$Impl_$.set_magnitude = function(this1,length) {
	var currentLength = Math.sqrt(this1.x * this1.x + this1.y * this1.y);
	if(currentLength == 0) {
		return 0;
	} else {
		var mul = length / currentLength;
		this1.x *= mul;
		this1.y *= mul;
		return Math.sqrt(this1.x * this1.x + this1.y * this1.y);
	}
};
geom__$Tpoint_Apoint_$Impl_$.topLeft = function(this1) {
	var this2 = { x : -1., y : -1.};
	return this2;
};
geom__$Tpoint_Apoint_$Impl_$.topRight = function(this1) {
	var this2 = { x : 1., y : -1.};
	return this2;
};
geom__$Tpoint_Apoint_$Impl_$.bottomLeft = function(this1) {
	var this2 = { x : -1., y : 1.};
	return this2;
};
geom__$Tpoint_Apoint_$Impl_$.bottomRight = function(this1) {
	var this2 = { x : 1., y : 1.};
	return this2;
};
geom__$Tpoint_Apoint_$Impl_$.north = function(this1) {
	var this2 = { x : 0., y : -1.};
	return this2;
};
geom__$Tpoint_Apoint_$Impl_$.south = function(this1) {
	var this2 = { x : 0., y : 1.};
	return this2;
};
geom__$Tpoint_Apoint_$Impl_$.west = function(this1) {
	var this2 = { x : -1., y : 0.};
	return this2;
};
geom__$Tpoint_Apoint_$Impl_$.east = function(this1) {
	var this2 = { x : 1., y : 0.};
	return this2;
};
geom__$Tpoint_Apoint_$Impl_$.add = function(a,b) {
	var this1 = { x : a.x + b.x, y : a.y + b.y};
	return this1;
};
geom__$Tpoint_Apoint_$Impl_$.subtract = function(a,b) {
	var this1 = { x : a.x - b.x, y : a.y - b.y};
	return this1;
};
geom__$Tpoint_Apoint_$Impl_$.dot = function(a,b) {
	var this1 = { x : a.x * b.x, y : a.y * b.y};
	return this1;
};
geom__$Tpoint_Apoint_$Impl_$.scaleMultiply = function(a,v) {
	var this1 = { x : a.x * v, y : a.y * v};
	return this1;
};
geom__$Tpoint_Apoint_$Impl_$.divide = function(a,v) {
	var v1 = 1 / v;
	var this1 = { x : a.x * v1, y : a.y * v1};
	return this1;
};
geom__$Tpoint_Apoint_$Impl_$.perp = function(this1,b) {
	return this1.x * b.y - this1.y * b.x;
};
geom__$Tpoint_Apoint_$Impl_$.mid = function(this1,a,b) {
	var this2 = { x : (a.x + b.x) / 2, y : (a.y + b.y) / 2};
	return this2;
};
geom__$Tpoint_Apoint_$Impl_$.distance = function(this1,b) {
	var dx = this1.x - b.x;
	var dy = this1.y - b.y;
	return dx * dx + dy * dy;
};
geom__$Tpoint_Apoint_$Impl_$.span = function(this1,b) {
	var this2 = { x : this1.x - b.x, y : this1.y - b.y};
	return this2;
};
geom__$Tpoint_Apoint_$Impl_$.normalize = function(this1) {
	var currentLength = Math.sqrt(this1.x * this1.x + this1.y * this1.y);
	if(currentLength != 0) {
		var mul = 1. / currentLength;
		this1.x *= mul;
		this1.y *= mul;
		var tmp = this1.x * this1.x + this1.y * this1.y;
	}
	return Math.sqrt(this1.x * this1.x + this1.y * this1.y);
};
geom__$Tpoint_Apoint_$Impl_$.lenSq = function(this1) {
	return this1.x * this1.x + this1.y * this1.y;
};
geom__$Tpoint_Apoint_$Impl_$.isLeft = function(this1,a,b) {
	return (b.x - a.x) * (this1.y - a.y) - (this1.x - a.x) * (b.y - a.y);
};
geom__$Tpoint_Apoint_$Impl_$.triangleArea = function(a,b,c) {
	return Math.abs(((c.x - b.x) * (a.y - b.y) - (a.x - b.x) * (c.y - b.y)) / 2.);
};
geom__$Tpoint_Apoint_$Impl_$.sign = function(n) {
	return Math.abs(n) / n | 0;
};
geom__$Tpoint_Apoint_$Impl_$.thetaDifference = function(a,b) {
	var dx = a.x - b.x;
	var dy = a.y - b.y;
	return Math.atan2(dy,dx);
};
geom__$Tpoint_Apoint_$Impl_$.inTri = function(this1,a,b,c) {
	var planeAB = (a.x - this1.x) * (b.y - this1.y) - (b.x - this1.x) * (a.y - this1.y);
	var planeBC = (b.x - this1.x) * (c.y - this1.y) - (c.x - this1.x) * (b.y - this1.y);
	var planeCA = (c.x - this1.x) * (a.y - this1.y) - (a.x - this1.x) * (c.y - this1.y);
	if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0)) {
		return (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0);
	} else {
		return false;
	}
};
geom__$Tpoint_Apoint_$Impl_$.inTri2 = function(this1,a,b,c) {
	var v0x = c.x - a.x;
	var v0y = c.y - a.y;
	var v1x = b.x - a.x;
	var v1y = b.y - a.y;
	var v2x = this1.x - a.x;
	var v2y = this1.y - a.y;
	var dot00 = v0x * v0x + v0y * v0y;
	var dot01 = v0x * v1x + v0y * v1y;
	var dot02 = v0x * v2x + v0y * v2y;
	var dot11 = v1x * v1x + v1y * v1y;
	var dot12 = v1x * v2x + v1y * v2y;
	var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
	var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
	var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
	if(u >= 0 && v >= 0) {
		return u + v < 1;
	} else {
		return false;
	}
};
geom__$Tpoint_Apoint_$Impl_$.inRect = function(this1,b,c) {
	var small = 0.0000000001;
	var minx = Math.min(b.x,c.x);
	var maxx = Math.max(b.x,c.x);
	var miny = Math.min(b.y,c.y);
	var maxy = Math.max(b.y,c.y);
	if(minx == maxx) {
		if(miny <= this1.y) {
			return this1.y <= maxy;
		} else {
			return false;
		}
	} else if(miny == maxy) {
		if(minx <= this1.x) {
			return this1.x <= maxx;
		} else {
			return false;
		}
	} else if(minx <= this1.x + small && this1.x - small <= maxx && miny <= this1.y + small) {
		return this1.y - small <= maxy;
	} else {
		return false;
	}
};
geom__$Tpoint_Apoint_$Impl_$.convex = function(a,b,c) {
	return (a.y - b.y) * (c.x - b.x) + (b.x - a.x) * (c.y - b.y) >= 0;
};
geom__$Tpoint_Apoint_$Impl_$.cross = function(a,b) {
	return a.x * b.y - a.y * b.x;
};
geom__$Tpoint_Apoint_$Impl_$.theta = function(this1) {
	return Math.atan2(this1.y,this1.x);
};
geom__$Tpoint_Apoint_$Impl_$.pivotAround = function(this1,omega,pivot) {
	var px = this1.x - pivot.x;
	var py = this1.y - pivot.y;
	var px2 = px * Math.cos(omega) - py * Math.sin(omega);
	py = py * Math.cos(omega) + px * Math.sin(omega);
	var this2 = { x : px2 + pivot.x, y : py + pivot.y};
	return this2;
};
var geom__$Tpoint_Apoint4_$Impl_$ = {};
geom__$Tpoint_Apoint4_$Impl_$.__name__ = true;
geom__$Tpoint_Apoint4_$Impl_$._new = function(p) {
	var this1 = p;
	return this1;
};
geom__$Tpoint_Apoint4_$Impl_$.unit = function() {
	var this1 = { x : 0., y : 0., z : 0., w : 1.};
	return this1;
};
geom__$Tpoint_Apoint4_$Impl_$.identity = function(out) {
	out.x = 0.;
	out.y = 0.;
	out.z = 0.;
	out.w = 1.;
	return out;
};
geom__$Tpoint_Apoint4_$Impl_$.copy = function(pin,pout) {
	pin.x = pout.x;
	pin.y = pout.y;
	pin.z = pout.z;
	pin.w = pout.w;
	return pout;
};
geom__$Tpoint_Apoint4_$Impl_$.getTPoint = function(this1) {
	var this2 = { x : this1.x, y : this1.y, z : this1.z, w : this1.w};
	return this2;
};
geom__$Tpoint_Apoint4_$Impl_$.get_magnitude = function(this1) {
	return Math.sqrt(this1.x * this1.x + this1.y * this1.y + this1.z * this1.z + this1.w * this1.w);
};
geom__$Tpoint_Apoint4_$Impl_$.set_magnitude = function(this1,length) {
	var currentLength = Math.sqrt(this1.x * this1.x + this1.y * this1.y + this1.z * this1.z + this1.w * this1.w);
	if(currentLength == 0.) {
		return 0.;
	} else {
		var mul = length / currentLength;
		this1.x *= mul;
		this1.y *= mul;
		this1.z *= mul;
		this1.w *= mul;
		return Math.sqrt(this1.x * this1.x + this1.y * this1.y + this1.z * this1.z + this1.w * this1.w);
	}
};
geom__$Tpoint_Apoint4_$Impl_$.equals = function(a,b) {
	var delta = 0.0000001;
	return !(Math.abs(a.x - b.x) >= delta || Math.abs(a.y - b.y) >= delta || Math.abs(a.z - b.z) >= delta || Math.abs(a.w - b.w) >= delta);
};
geom__$Tpoint_Apoint4_$Impl_$.magnitudeSquared = function(this1) {
	return this1.x * this1.x + this1.y * this1.y + this1.z * this1.z + this1.w * this1.w;
};
geom__$Tpoint_Apoint4_$Impl_$.add = function(a,b) {
	var this1 = { x : a.x + b.x, y : a.y + b.y, z : a.z + b.z, w : a.w + b.w};
	return this1;
};
geom__$Tpoint_Apoint4_$Impl_$.subtract = function(a,b) {
	var this1 = { x : a.x - b.x, y : a.y - b.y, z : a.z - b.z, w : a.w - b.w};
	return this1;
};
geom__$Tpoint_Apoint4_$Impl_$.dot = function(a,b) {
	var this1 = { x : a.x * b.x, y : a.y * b.y, z : a.z * b.z, w : a.w * b.w};
	return this1;
};
geom__$Tpoint_Apoint4_$Impl_$.dotProduct = function(a,b) {
	return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
};
geom__$Tpoint_Apoint4_$Impl_$.scaleMultiply = function(a,v) {
	var this1 = { x : a.x * v, y : a.y * v, z : a.z * v, w : a.w * v};
	return this1;
};
geom__$Tpoint_Apoint4_$Impl_$.divide = function(a,v) {
	var v1 = 1 / v;
	var this1 = { x : a.x * v1, y : a.y * v1, z : a.z * v1, w : a.w * v1};
	return this1;
};
geom__$Tpoint_Apoint4_$Impl_$.conjugate = function(a) {
	var this1 = { x : -a.x, y : -a.y, z : -a.z, w : a.w};
	return this1;
};
geom__$Tpoint_Apoint4_$Impl_$.negate = function(a) {
	var this1 = { x : -a.x, y : -a.y, z : -a.z, w : -a.w};
	return this1;
};
geom__$Tpoint_Apoint4_$Impl_$.multiplyQ = function(a,b,out) {
	var ax = a.x;
	var ay = a.y;
	var az = a.z;
	var aw = a.w;
	var bx = b.x;
	var by = b.y;
	var bz = b.z;
	var bw = b.w;
	out.x = ax * bw + aw * bx + ay * bz - az * by;
	out.y = ay * bw + aw * by + az * bx - ax * bz;
	out.z = az * bw + aw * bz + ax * by - ay * bx;
	out.w = aw * bw - ax * bx - ay * by - az * bz;
	return out;
};
geom__$Tpoint_Apoint4_$Impl_$.multiplyV = function(q,v,out) {
	var vx = v.x;
	var vy = v.y;
	var vz = v.z;
	var qx = q.x;
	var qy = q.y;
	var qz = q.z;
	var qw = q.w;
	out.w = -qx * vx - qy * vy - qz * vz;
	out.x = qw * vx + qy * vz - qz * vy;
	out.y = qw * vy - qx * vz + qz * vx;
	out.z = qw * vz + qx * vy - qy * vx;
	return out;
};
geom__$Tpoint_Apoint4_$Impl_$.fromAxisAngle = function(theta,axis) {
	var half = theta / 2.;
	var c = Math.cos(half);
	var s = Math.sin(half);
	var this1 = { x : s * axis.x, y : s * axis.y, z : s * axis.z, w : c};
	return this1;
};
geom__$Tpoint_Apoint4_$Impl_$.lerp = function(a,b,t) {
	var v = 1.0 - t;
	var a_x = a.x * v;
	var a_y = a.y * v;
	var a_z = a.z * v;
	var a_w = a.w * v;
	var b_x = b.x * t;
	var b_y = b.y * t;
	var b_z = b.z * t;
	var b_w = b.w * t;
	var this1 = { x : a_x + b_x, y : a_y + b_y, z : a_z + b_z, w : a_w + b_w};
	return this1;
};
geom__$Tpoint_Apoint4_$Impl_$.set_euler = function(this1,a) {
	var x5 = a.x * .5;
	var y5 = a.y * .5;
	var z5 = a.z * .5;
	var cx = Math.cos(x5);
	var sx = Math.sin(x5);
	var cy = Math.cos(y5);
	var sy = Math.sin(y5);
	var cz = Math.cos(z5);
	var sz = Math.sin(z5);
	this1.w = cx * cy * cz + sx * sy * sz;
	this1.x = sx * cy * cz - cx * sy * sz;
	this1.y = cx * sy * cz + sx * cy * sz;
	this1.z = cx * cy * sz - sx * sy * cz;
	return this1;
};
geom__$Tpoint_Apoint4_$Impl_$.get_euler = function(this1) {
	var this2 = { x : Math.atan2(2 * (this1.w * this1.x + this1.y * this1.z),1 - 2 * (this1.x * this1.x + this1.y * this1.y)), y : Math.asin(2 * (this1.w * this1.y - this1.z * this1.x)), z : Math.atan2(2 * (this1.w * this1.z + this1.x * this1.y),1 - 2 * (this1.y * this1.y + this1.z * this1.z)), w : 1.};
	return this2;
};
geom__$Tpoint_Apoint4_$Impl_$.slerp = function(this1,a,b,t) {
	var w1 = a.w;
	var x1 = a.x;
	var y1 = a.y;
	var z1 = a.z;
	var w2 = b.w;
	var x2 = b.x;
	var y2 = b.y;
	var z2 = b.z;
	var dot = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
	var this2 = { x : 0., y : 0., z : 0., w : 1.};
	var p = this2;
	if(dot < 0) {
		dot = -dot;
		w2 = -w2;
		x2 = -x2;
		y2 = -y2;
		z2 = -z2;
	}
	if(dot < 0.95) {
		var angle = Math.acos(dot);
		var s = 1. / Math.sin(angle);
		var s1 = Math.sin(angle * (1 - t)) * s;
		var s2 = Math.sin(angle * t) * s;
		p.w = w1 * s1 + w2 * s2;
		p.x = x1 * s1 + x2 * s2;
		p.y = y1 * s1 + y2 * s2;
		p.z = z1 * s1 + z2 * s2;
	} else {
		p.w = w1 + t * (w2 - w1);
		p.x = x1 + t * (x2 - x1);
		p.y = y1 + t * (y2 - y1);
		p.z = z1 + t * (z2 - z1);
		var len = 1.0 / Math.sqrt(p.x * p.x + p.y * p.y + p.z * p.z + p.w * p.w);
		var this3 = { x : p.x * len, y : p.y * len, z : p.z * len, w : p.w * len};
		p = this3;
	}
	return p;
};
geom__$Tpoint_Apoint4_$Impl_$.normalize = function(this1) {
	var currentLength = Math.sqrt(this1.x * this1.x + this1.y * this1.y + this1.z * this1.z + this1.w * this1.w);
	if(currentLength != 0.) {
		var mul = 1. / currentLength;
		this1.x *= mul;
		this1.y *= mul;
		this1.z *= mul;
		this1.w *= mul;
		var tmp = this1.x * this1.x + this1.y * this1.y + this1.z * this1.z + this1.w * this1.w;
	}
	return this1;
};
geom__$Tpoint_Apoint4_$Impl_$.constrainDistance = function(this1,anchor,distance) {
	var a_x = this1.x - anchor.x;
	var a_y = this1.y - anchor.y;
	var a_z = this1.z - anchor.z;
	var a_w = this1.w - anchor.w;
	var currentLength = Math.sqrt(a_x * a_x + a_y * a_y + a_z * a_z + a_w * a_w);
	if(currentLength != 0.) {
		var mul = 1. / currentLength;
		a_x *= mul;
		a_y *= mul;
		a_z *= mul;
		a_w *= mul;
		var tmp = a_x * a_x + a_y * a_y + a_z * a_z + a_w * a_w;
	}
	var a_x1 = a_x * distance;
	var a_y1 = a_y * distance;
	var a_z1 = a_z * distance;
	var a_w1 = a_w * distance;
	var this2 = { x : a_x1 + anchor.x, y : a_y1 + anchor.y, z : a_z1 + anchor.z, w : a_w1 + anchor.w};
	return this2;
};
geom__$Tpoint_Apoint4_$Impl_$.fromVec = function(vec) {
	var this1 = { x : vec[0], y : vec[1], z : vec[2], w : vec[3]};
	return this1;
};
geom__$Tpoint_Apoint4_$Impl_$.toVector = function(this1) {
	var this2 = new Array(4);
	var vec = this2;
	vec[0] = this1.x;
	vec[1] = this1.y;
	vec[2] = this1.z;
	vec[3] = this1.w;
	return vec;
};
geom__$Tpoint_Apoint4_$Impl_$.fromArray = function(arr) {
	var this1 = { x : arr[0], y : arr[1], z : arr[2], w : arr[3]};
	return this1;
};
geom__$Tpoint_Apoint4_$Impl_$.toArray = function(this1) {
	return [this1.x,this1.y,this1.z,this1.w];
};
var htmlHelper_canvas__$CanvasWrapper_CanvasWrapper_$Impl_$ = {};
htmlHelper_canvas__$CanvasWrapper_CanvasWrapper_$Impl_$.__name__ = true;
htmlHelper_canvas__$CanvasWrapper_CanvasWrapper_$Impl_$._new = function(e) {
	var this1;
	if(e == null) {
		var canvas = window.document.createElement("canvas");
		var dom = canvas;
		var style = dom.style;
		style.paddingLeft = "0px";
		style.paddingTop = "0px";
		style.left = "0px";
		style.top = "0px";
		style.position = "absolute";
		this1 = canvas;
	} else {
		this1 = e;
	}
	return this1;
};
htmlHelper_canvas__$CanvasWrapper_CanvasWrapper_$Impl_$.create = function() {
	var canvas = window.document.createElement("canvas");
	var dom = canvas;
	var style = dom.style;
	style.paddingLeft = "0px";
	style.paddingTop = "0px";
	style.left = "0px";
	style.top = "0px";
	style.position = "absolute";
	return canvas;
};
htmlHelper_canvas__$CanvasWrapper_CanvasWrapper_$Impl_$.set_x = function(this1,x_) {
	this1.style.left = (x_ == null ? "null" : "" + x_) + "px";
	return x_;
};
htmlHelper_canvas__$CanvasWrapper_CanvasWrapper_$Impl_$.get_x = function(this1) {
	var style = this1.style;
	var len = style.left.length;
	return Std.parseInt(style.left.substr(0,len - 2));
};
htmlHelper_canvas__$CanvasWrapper_CanvasWrapper_$Impl_$.set_y = function(this1,y_) {
	this1.style.left = (y_ == null ? "null" : "" + y_) + "px";
	return y_;
};
htmlHelper_canvas__$CanvasWrapper_CanvasWrapper_$Impl_$.get_y = function(this1) {
	var style = this1.style;
	var len = style.top.length;
	return Std.parseInt(style.top.substr(0,len - 2));
};
var htmlHelper_tools_AnimateTimer = function() { };
htmlHelper_tools_AnimateTimer.__name__ = true;
htmlHelper_tools_AnimateTimer.create = function() {
	if(htmlHelper_tools_AnimateTimer.s != null) {
		return;
	}
	htmlHelper_tools_AnimateTimer.s = window.document.createElement("style");
	htmlHelper_tools_AnimateTimer.s.innerHTML = "@keyframes spin { from { transform:rotate( 0deg ); } to { transform:rotate( 360deg ); } }";
	window.document.getElementsByTagName("head")[0].appendChild(htmlHelper_tools_AnimateTimer.s);
	htmlHelper_tools_AnimateTimer.s.animation = "spin 1s linear infinite";
	htmlHelper_tools_AnimateTimer.loop(60.0);
};
htmlHelper_tools_AnimateTimer.loop = function(tim) {
	window.requestAnimationFrame(htmlHelper_tools_AnimateTimer.loop);
	if(htmlHelper_tools_AnimateTimer.onFrame != null) {
		htmlHelper_tools_AnimateTimer.onFrame(htmlHelper_tools_AnimateTimer.counter);
	}
	htmlHelper_tools_AnimateTimer.counter++;
	return true;
};
htmlHelper_tools_AnimateTimer.kill = function() {
	if(htmlHelper_tools_AnimateTimer.s == null) {
		return;
	}
	window.document.getElementsByTagName("head")[0].removeChild(htmlHelper_tools_AnimateTimer.s);
	htmlHelper_tools_AnimateTimer.onFrame = null;
	htmlHelper_tools_AnimateTimer.s = null;
};
htmlHelper_tools_AnimateTimer.tween = function(t,b,e,d,f) {
	if(t > d) {
		return null;
	}
	return f(t,b,e - b,d);
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s += "\t";
				var tmp = n + "(";
				var _g = [];
				var _g1 = 0;
				var _g2 = con.__params__;
				while(_g1 < _g2.length) {
					var p = _g2[_g1];
					++_g1;
					_g.push(js_Boot.__string_rec(o[p],s));
				}
				return tmp + _g.join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var l = o.length;
			var i;
			var str = "[";
			s += "\t";
			var _g3 = 0;
			var _g11 = l;
			while(_g3 < _g11) {
				var i1 = _g3++;
				str += (i1 > 0 ? "," : "") + js_Boot.__string_rec(o[i1],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e1 ) {
			var e2 = ((e1) instanceof js__$Boot_HaxeError) ? e1.val : e1;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str1 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str1.length != 2) {
			str1 += ", \n";
		}
		str1 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str1 += "\n" + s + "}";
		return str1;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var justDrawing_Surface = function(graphics_) {
	this.inFill = false;
	this.prevY = 0;
	this.prevX = 0;
	this.graphics = graphics_;
	this.inFill = false;
};
justDrawing_Surface.__name__ = true;
justDrawing_Surface.getColor = function(col,alpha) {
	var str;
	if(alpha != null && alpha != 1.0) {
		var r = col >> 16 & 255;
		var g = col >> 8 & 255;
		var b = col & 255;
		str = "rgba(" + r + "," + g + "," + b + "," + alpha + ")";
	} else {
		str = "#" + StringTools.hex(col,6);
	}
	return str;
};
justDrawing_Surface.arcTan = function(p0,p1) {
	return Math.atan2(p1.y - p0.y,p1.x - p0.x);
};
justDrawing_Surface.distance = function(p0,p1) {
	var x = p0.x - p1.x;
	var y = p0.y - p1.y;
	return Math.sqrt(x * x + y * y);
};
justDrawing_Surface.quadraticBezier = function(t,arr) {
	var u = 1 - t;
	var u1 = 1 - t;
	return { x : Math.pow(u,2) * arr[0].x + 2 * u * t * arr[1].x + Math.pow(t,2) * arr[2].x, y : Math.pow(u1,2) * arr[0].y + 2 * u1 * t * arr[1].y + Math.pow(t,2) * arr[2].y};
};
justDrawing_Surface._quadraticBezier = function(t,startPoint,controlPoint,endPoint) {
	var u = 1 - t;
	return Math.pow(u,2) * startPoint + 2 * u * t * controlPoint + Math.pow(t,2) * endPoint;
};
justDrawing_Surface.cubicBezier = function(t,arr) {
	var u = 1 - t;
	var u1 = 1 - t;
	return { x : Math.pow(u,3) * arr[0].x + 3 * Math.pow(u,2) * t * arr[1].x + 3 * u * Math.pow(t,2) * arr[2].x + Math.pow(t,3) * arr[3].x, y : Math.pow(u1,3) * arr[0].y + 3 * Math.pow(u1,2) * t * arr[1].y + 3 * u1 * Math.pow(t,2) * arr[2].y + Math.pow(t,3) * arr[3].y};
};
justDrawing_Surface._cubicBezier = function(t,startPoint,controlPoint1,controlPoint2,endPoint) {
	var u = 1 - t;
	return Math.pow(u,3) * startPoint + 3 * Math.pow(u,2) * t * controlPoint1 + 3 * u * Math.pow(t,2) * controlPoint2 + Math.pow(t,3) * endPoint;
};
justDrawing_Surface.prototype = {
	clear: function() {
		this.graphics.clearRect(0,0,this.width,this.height);
	}
	,lineStyle: function(thick,color,alpha) {
		if(alpha == null) {
			alpha = 1.;
		}
		this.thickness = thick;
		this.lineColor = color;
		this.lineAlpha = alpha;
		this.graphics.lineWidth = thick;
		var col = this.lineColor;
		var alpha1 = this.lineAlpha;
		var str;
		if(alpha1 != null && alpha1 != 1.0) {
			var r = col >> 16 & 255;
			var g = col >> 8 & 255;
			var b = col & 255;
			str = "rgba(" + r + "," + g + "," + b + "," + alpha1 + ")";
		} else {
			str = "#" + StringTools.hex(col,6);
		}
		this.graphics.strokeStyle = str;
	}
	,beginFill: function(color,alpha) {
		this.fillColor = color;
		this.fillAlpha = alpha;
		this.inFill = true;
		var col = this.fillColor;
		var alpha1 = this.fillAlpha;
		var str;
		if(alpha1 != null && alpha1 != 1.0) {
			var r = col >> 16 & 255;
			var g = col >> 8 & 255;
			var b = col & 255;
			str = "rgba(" + r + "," + g + "," + b + "," + alpha1 + ")";
		} else {
			str = "#" + StringTools.hex(col,6);
		}
		this.graphics.fillStyle = str;
		this.graphics.beginPath();
	}
	,endFill: function() {
		var wasFill = this.inFill;
		this.inFill = false;
		this.graphics.stroke();
		this.graphics.closePath();
		this.graphics.fill();
	}
	,moveTo: function(x,y) {
		this.prevX = x;
		this.prevY = y;
		this.graphics.beginPath();
		this.graphics.moveTo(x,y);
	}
	,lineTo: function(x,y) {
		this.graphics.lineTo(x,y);
		this.graphics.stroke();
		this.prevX = x;
		this.prevY = y;
	}
	,curveTo: function(x1,y1,x2,y2,x3,y3) {
		this.graphics.bezierCurveTo(x1,y1,x2,y2,x3,y3);
		this.graphics.stroke();
	}
	,quadTo: function(cx,cy,ax,ay) {
		this.graphics.quadraticCurveTo(cx,cy,ax,ay);
		this.graphics.stroke();
	}
	,drawCircle: function(cx,cy,radius) {
		this.graphics.beginPath();
		this.graphics.arc(cx,cy,radius,0,2 * Math.PI,false);
		this.graphics.stroke();
		this.graphics.closePath();
	}
	,drawRect: function(x,y,width,height) {
		this.graphics.beginPath();
		this.graphics.moveTo(x,y);
		this.graphics.lineTo(x + width,y);
		this.graphics.lineTo(x + width,y + height);
		this.graphics.lineTo(x,y + height);
		this.graphics.stroke();
		this.graphics.closePath();
	}
	,drawEquilaterialTri: function(x,y,radius,direction) {
		var third = Math.PI * 2 / 3;
		var points = [];
		var x1;
		var y1;
		x1 = x + radius * Math.cos(direction + 0 * third);
		y1 = y + radius * Math.sin(direction + 0 * third);
		points.push(x1);
		points.push(y1);
		x1 = x + radius * Math.cos(direction + third);
		y1 = y + radius * Math.sin(direction + third);
		points.push(x1);
		points.push(y1);
		x1 = x + radius * Math.cos(direction + 2 * third);
		y1 = y + radius * Math.sin(direction + 2 * third);
		points.push(x1);
		points.push(y1);
		this.drawTri(points);
	}
	,drawTri: function(points) {
		this.graphics.beginPath();
		var i = 0;
		while(i < points.length) {
			if(i == 0) {
				this.graphics.moveTo(points[i],points[i + 1]);
			} else {
				this.graphics.lineTo(points[i],points[i + 1]);
			}
			i += 2;
		}
		this.graphics.stroke();
		this.graphics.closePath();
	}
};
var trilateral_angle_DifferencePreference = $hxEnums["trilateral.angle.DifferencePreference"] = { __ename__ : true, __constructs__ : ["CLOCKWISE","ANTICLOCKWISE","SMALL","LARGE"]
	,CLOCKWISE: {_hx_index:0,__enum__:"trilateral.angle.DifferencePreference",toString:$estr}
	,ANTICLOCKWISE: {_hx_index:1,__enum__:"trilateral.angle.DifferencePreference",toString:$estr}
	,SMALL: {_hx_index:2,__enum__:"trilateral.angle.DifferencePreference",toString:$estr}
	,LARGE: {_hx_index:3,__enum__:"trilateral.angle.DifferencePreference",toString:$estr}
};
var trilateral_angle_Angles = function() { };
trilateral_angle_Angles.__name__ = true;
trilateral_angle_Angles.pi2pi = function(angle) {
	if(angle <= Math.PI && angle > -Math.PI) {
		return angle;
	} else {
		var a = (angle + Math.PI) % (2 * Math.PI);
		if(a >= 0) {
			return a - Math.PI;
		} else {
			return a + Math.PI;
		}
	}
};
trilateral_angle_Angles.zeroto2pi = function(angle) {
	if(angle >= 0 && angle > Math.PI) {
		return angle;
	} else {
		var a = angle % (2 * Math.PI);
		if(a >= 0) {
			return a;
		} else {
			return a + 2 * Math.PI;
		}
	}
};
trilateral_angle_Angles.zerotoMinus2pi = function(angle) {
	if(angle <= 0 && angle > -Math.PI) {
		return angle;
	} else {
		var a = angle % (2 * Math.PI);
		var a1 = a >= 0 ? a : a + 2 * Math.PI;
		return -(Math.PI * 2 - a1);
	}
};
trilateral_angle_Angles.differencePrefer = function(a,b,prefer) {
	switch(prefer._hx_index) {
	case 0:
		var f;
		if(a >= 0 && a > Math.PI) {
			f = a;
		} else {
			var a1 = a % (2 * Math.PI);
			f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this1 = f;
		var za = this1;
		var f1;
		if(b >= 0 && b > Math.PI) {
			f1 = b;
		} else {
			var a2 = b % (2 * Math.PI);
			f1 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
		}
		var this2 = f1;
		var zb = this2;
		var fa = za;
		var fb = zb;
		var theta = Math.abs(a - b);
		var clockwise = a < b;
		var dif = clockwise ? theta : -theta;
		if(dif > 0) {
			return dif;
		} else {
			return 2 * Math.PI + dif;
		}
		break;
	case 1:
		var f2;
		if(a >= 0 && a > Math.PI) {
			f2 = a;
		} else {
			var a3 = a % (2 * Math.PI);
			f2 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
		}
		var this3 = f2;
		var za1 = this3;
		var f3;
		if(b >= 0 && b > Math.PI) {
			f3 = b;
		} else {
			var a4 = b % (2 * Math.PI);
			f3 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
		}
		var this4 = f3;
		var zb1 = this4;
		var fa1 = za1;
		var fb1 = zb1;
		var theta1 = Math.abs(a - b);
		var clockwise1 = a < b;
		var dif1 = clockwise1 ? theta1 : -theta1;
		if(dif1 < 0) {
			return dif1;
		} else {
			return -2 * Math.PI + dif1;
		}
		break;
	case 2:
		var f4;
		if(a >= 0 && a > Math.PI) {
			f4 = a;
		} else {
			var a5 = a % (2 * Math.PI);
			f4 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
		}
		var this5 = f4;
		var za2 = this5;
		var f5;
		if(b >= 0 && b > Math.PI) {
			f5 = b;
		} else {
			var a6 = b % (2 * Math.PI);
			f5 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
		}
		var this6 = f5;
		var zb2 = this6;
		var fa2 = a;
		var fb2 = b;
		var theta2 = Math.abs(a - b);
		var smallest = theta2 <= Math.PI;
		var clockwise2 = a < b;
		var dif2 = clockwise2 ? theta2 : -theta2;
		if(smallest) {
			return dif2;
		} else if(clockwise2) {
			return -(2 * Math.PI - theta2);
		} else {
			return 2 * Math.PI - theta2;
		}
		break;
	case 3:
		var f6;
		if(a >= 0 && a > Math.PI) {
			f6 = a;
		} else {
			var a7 = a % (2 * Math.PI);
			f6 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
		}
		var this7 = f6;
		var za3 = this7;
		var f7;
		if(b >= 0 && b > Math.PI) {
			f7 = b;
		} else {
			var a8 = b % (2 * Math.PI);
			f7 = a8 >= 0 ? a8 : a8 + 2 * Math.PI;
		}
		var this8 = f7;
		var zb3 = this8;
		var fa3 = a;
		var fb3 = b;
		var theta3 = Math.abs(a - b);
		var largest = theta3 > Math.PI;
		var clockwise3 = a < b;
		var dif3 = clockwise3 ? theta3 : -theta3;
		if(largest) {
			return dif3;
		} else if(clockwise3) {
			return -(2 * Math.PI - theta3);
		} else {
			return 2 * Math.PI - theta3;
		}
		break;
	}
};
trilateral_angle_Angles.difference = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
	}
	var this1 = f;
	var za = this1;
	var f1;
	if(b >= 0 && b > Math.PI) {
		f1 = b;
	} else {
		var a2 = b % (2 * Math.PI);
		f1 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
	}
	var this2 = f1;
	var zb = this2;
	var fa = za;
	var fb = zb;
	var theta = Math.abs(a - b);
	var clockwise = a < b;
	if(clockwise) {
		return theta;
	} else {
		return -theta;
	}
};
trilateral_angle_Angles.differenceClockWise = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
	}
	var this1 = f;
	var za = this1;
	var f1;
	if(b >= 0 && b > Math.PI) {
		f1 = b;
	} else {
		var a2 = b % (2 * Math.PI);
		f1 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
	}
	var this2 = f1;
	var zb = this2;
	var fa = za;
	var fb = zb;
	var theta = Math.abs(a - b);
	var clockwise = a < b;
	var dif = clockwise ? theta : -theta;
	if(dif > 0) {
		return dif;
	} else {
		return 2 * Math.PI + dif;
	}
};
trilateral_angle_Angles.differenceAntiClockwise = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
	}
	var this1 = f;
	var za = this1;
	var f1;
	if(b >= 0 && b > Math.PI) {
		f1 = b;
	} else {
		var a2 = b % (2 * Math.PI);
		f1 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
	}
	var this2 = f1;
	var zb = this2;
	var fa = za;
	var fb = zb;
	var theta = Math.abs(a - b);
	var clockwise = a < b;
	var dif = clockwise ? theta : -theta;
	if(dif < 0) {
		return dif;
	} else {
		return -2 * Math.PI + dif;
	}
};
trilateral_angle_Angles.differenceSmall = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
	}
	var this1 = f;
	var za = this1;
	var f1;
	if(b >= 0 && b > Math.PI) {
		f1 = b;
	} else {
		var a2 = b % (2 * Math.PI);
		f1 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
	}
	var this2 = f1;
	var zb = this2;
	var fa = a;
	var fb = b;
	var theta = Math.abs(a - b);
	var smallest = theta <= Math.PI;
	var clockwise = a < b;
	var dif = clockwise ? theta : -theta;
	if(smallest) {
		return dif;
	} else if(clockwise) {
		return -(2 * Math.PI - theta);
	} else {
		return 2 * Math.PI - theta;
	}
};
trilateral_angle_Angles.differenceLarge = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
	}
	var this1 = f;
	var za = this1;
	var f1;
	if(b >= 0 && b > Math.PI) {
		f1 = b;
	} else {
		var a2 = b % (2 * Math.PI);
		f1 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
	}
	var this2 = f1;
	var zb = this2;
	var fa = a;
	var fb = b;
	var theta = Math.abs(a - b);
	var largest = theta > Math.PI;
	var clockwise = a < b;
	var dif = clockwise ? theta : -theta;
	if(largest) {
		return dif;
	} else if(clockwise) {
		return -(2 * Math.PI - theta);
	} else {
		return 2 * Math.PI - theta;
	}
};
trilateral_angle_Angles.differenceSmallLarge = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
	}
	var this1 = f;
	var za = this1;
	var f1;
	if(b >= 0 && b > Math.PI) {
		f1 = b;
	} else {
		var a2 = b % (2 * Math.PI);
		f1 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
	}
	var this2 = f1;
	var zb = this2;
	var fa = a;
	var fb = b;
	var theta = Math.abs(a - b);
	var smallest = theta <= Math.PI;
	var clockwise = a < b;
	var dif = clockwise ? theta : -theta;
	var other = clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
	if(smallest) {
		return { small : dif, large : other};
	} else {
		return { small : other, large : dif};
	}
};
var trilateral_angle__$Fraction_FractionArray_$Impl_$ = {};
trilateral_angle__$Fraction_FractionArray_$Impl_$.__name__ = true;
trilateral_angle__$Fraction_FractionArray_$Impl_$._new = function(val) {
	var this1 = val == null ? [] : val;
	return this1;
};
trilateral_angle__$Fraction_FractionArray_$Impl_$.add = function(this1,val) {
	this1[this1.length] = val;
};
trilateral_angle__$Fraction_FractionArray_$Impl_$.toString = function(this1) {
	var l = this1.length;
	var str = "";
	var _g = 0;
	var _g1 = l;
	while(_g < _g1) {
		var i = _g++;
		var this2 = this1[i];
		var n = this2.numerator;
		var d = this2.denominator;
		var out = n == 0 ? "0" : n == d ? "1" : d == 1 ? this2.positive ? "" + n : "-" + n : this2.positive ? "" + n + "/" + d : "-" + n + "/" + d;
		str = str + "\n" + out;
	}
	return str;
};
var trilateral_angle__$Fraction_Fraction_$Impl_$ = {};
trilateral_angle__$Fraction_Fraction_$Impl_$.__name__ = true;
trilateral_angle__$Fraction_Fraction_$Impl_$._new = function(numerator,denominator,positive,value) {
	if(positive == null) {
		positive = true;
	}
	var numNeg = numerator < 0;
	var denoNeg = denominator < 0;
	if(value == null) {
		value = positive ? numerator / denominator : -numerator / denominator;
	}
	if(numNeg || denoNeg) {
		if(!(numNeg && denoNeg)) {
			positive = !positive;
		}
		if(numNeg) {
			numerator = -numerator;
		}
		if(denoNeg) {
			denominator = -denominator;
		}
	}
	var this1 = { numerator : numerator, denominator : denominator, positive : positive, value : value};
	return this1;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.optimize = function(this1) {
	var f = this1.value;
	var arr = trilateral_angle_Fracs.approximateFractions(f);
	var dist = Infinity;
	var dif;
	var l = arr.length;
	var fracFloat;
	var frac = trilateral_angle__$Fraction_Fraction_$Impl_$;
	var fracStore = arr[0];
	var _g = 0;
	var _g1 = l;
	while(_g < _g1) {
		var i = _g++;
		var frac1 = arr[i];
		fracFloat = frac1.positive ? frac1.numerator / frac1.denominator : -frac1.numerator / frac1.denominator;
		dif = Math.abs(fracFloat - f);
		if(dif < dist) {
			dist = dif;
			fracStore = frac1;
		}
	}
	return fracStore;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.optimizeFraction = function(this1) {
	var f = this1.positive ? this1.numerator / this1.denominator : -this1.numerator / this1.denominator;
	var arr = trilateral_angle_Fracs.approximateFractions(f);
	var dist = Infinity;
	var dif;
	var l = arr.length;
	var fracFloat;
	var frac = trilateral_angle__$Fraction_Fraction_$Impl_$;
	var fracStore = arr[0];
	var _g = 0;
	var _g1 = l;
	while(_g < _g1) {
		var i = _g++;
		var frac1 = arr[i];
		fracFloat = frac1.positive ? frac1.numerator / frac1.denominator : -frac1.numerator / frac1.denominator;
		dif = Math.abs(fracFloat - f);
		if(dif < dist) {
			dist = dif;
			fracStore = frac1;
		}
	}
	return fracStore;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.toFloat = function(this1) {
	if(this1.positive) {
		return this1.numerator / this1.denominator;
	} else {
		return -this1.numerator / this1.denominator;
	}
};
trilateral_angle__$Fraction_Fraction_$Impl_$.float = function(this1) {
	return this1.value;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.verbose = function(this1) {
	return "{ numerator:" + this1.numerator + ", denominator: " + this1.denominator + ", positive: " + (this1.positive == null ? "null" : "" + this1.positive) + ", value: " + this1.value + " }";
};
trilateral_angle__$Fraction_Fraction_$Impl_$.fromString = function(val) {
	var i = val.indexOf("/");
	var frac;
	if(i != -1) {
		var numerator = Std.parseInt(HxOverrides.substr(val,0,i));
		var denominator = Std.parseInt(HxOverrides.substr(val,i + 1,val.length));
		var positive = true;
		var value = null;
		var numNeg = numerator < 0;
		var denoNeg = denominator < 0;
		if(value == null) {
			value = positive ? numerator / denominator : -numerator / denominator;
		}
		if(numNeg || denoNeg) {
			if(!(numNeg && denoNeg)) {
				positive = !positive;
			}
			if(numNeg) {
				numerator = -numerator;
			}
			if(denoNeg) {
				denominator = -denominator;
			}
		}
		var this1 = { numerator : numerator, denominator : denominator, positive : positive, value : value};
		frac = this1;
	} else {
		var f = parseFloat(val);
		var arr = trilateral_angle_Fracs.approximateFractions(f);
		var dist = Infinity;
		var dif;
		var l = arr.length;
		var fracFloat;
		var frac1 = trilateral_angle__$Fraction_Fraction_$Impl_$;
		var fracStore = arr[0];
		var _g = 0;
		var _g1 = l;
		while(_g < _g1) {
			var i1 = _g++;
			var frac2 = arr[i1];
			fracFloat = frac2.positive ? frac2.numerator / frac2.denominator : -frac2.numerator / frac2.denominator;
			dif = Math.abs(fracFloat - f);
			if(dif < dist) {
				dist = dif;
				fracStore = frac2;
			}
		}
		frac = fracStore;
	}
	return frac;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.toString = function(this1) {
	var n = this1.numerator;
	var d = this1.denominator;
	var out = n == 0 ? "0" : n == d ? "1" : d == 1 ? this1.positive ? "" + n : "-" + n : this1.positive ? "" + n + "/" + d : "-" + n + "/" + d;
	return out;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.fromFloat = function(f) {
	var arr = trilateral_angle_Fracs.approximateFractions(f);
	var dist = Infinity;
	var dif;
	var l = arr.length;
	var fracFloat;
	var frac = trilateral_angle__$Fraction_Fraction_$Impl_$;
	var fracStore = arr[0];
	var _g = 0;
	var _g1 = l;
	while(_g < _g1) {
		var i = _g++;
		var frac1 = arr[i];
		fracFloat = frac1.positive ? frac1.numerator / frac1.denominator : -frac1.numerator / frac1.denominator;
		dif = Math.abs(fracFloat - f);
		if(dif < dist) {
			dist = dif;
			fracStore = frac1;
		}
	}
	return fracStore;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.firstFloat = function(f) {
	var arr = trilateral_angle_Fracs.approximateFractions(f);
	var fracStore = arr[0];
	return fracStore;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.byDenominator = function(this1,val) {
	var n = this1.numerator;
	var d = this1.denominator;
	var out = n == 0 ? "0" : n == d ? "1" : d == 1 ? this1.positive ? "" + n : "-" + n : this1.positive ? "" + n + "/" + d : "-" + n + "/" + d;
	var out1 = out;
	if(!(this1.denominator == val || out1 == "0" || out1 == "1")) {
		var dom = Math.round(this1.value * val);
		var numerator = dom;
		var denominator = val;
		var positive = true;
		var value = null;
		var numNeg = numerator < 0;
		var denoNeg = denominator < 0;
		if(value == null) {
			value = positive ? numerator / denominator : -numerator / denominator;
		}
		if(numNeg || denoNeg) {
			if(!(numNeg && denoNeg)) {
				positive = !positive;
			}
			if(numNeg) {
				numerator = -numerator;
			}
			if(denoNeg) {
				denominator = -denominator;
			}
		}
		var this2 = { numerator : numerator, denominator : denominator, positive : positive, value : value};
		var frac = this2;
		var n1 = frac.numerator;
		var d1 = frac.denominator;
		var out2 = n1 == 0 ? "0" : n1 == d1 ? "1" : d1 == 1 ? frac.positive ? "" + n1 : "-" + n1 : frac.positive ? "" + n1 + "/" + d1 : "-" + n1 + "/" + d1;
		out1 = out2;
	}
	return out1;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.all = function(f) {
	return trilateral_angle_Fracs.approximateFractions(f);
};
trilateral_angle__$Fraction_Fraction_$Impl_$.similarToFraction = function(this1) {
	var f = this1.positive ? this1.numerator / this1.denominator : -this1.numerator / this1.denominator;
	return trilateral_angle_Fracs.approximateFractions(f);
};
trilateral_angle__$Fraction_Fraction_$Impl_$.similarToValue = function(this1) {
	return trilateral_angle_Fracs.approximateFractions(this1.value);
};
var trilateral_angle_Fracs = function() { };
trilateral_angle_Fracs.__name__ = true;
trilateral_angle_Fracs.grabDecimalInput = function(decimalVal) {
	var decimal = Math.abs(parseFloat(decimalVal));
	if(isNaN(decimal)) {
		return 0.;
	} else {
		return decimal;
	}
};
trilateral_angle_Fracs.approximateFractions = function(f) {
	var positive = f <= 0 ? false : true;
	var numerators = [0,1];
	var denominators = [1,0];
	var f2 = f <= 0 ? -f : f;
	var fStr = f2 == null ? "null" : "" + f2;
	var digits = "";
	var ix = fStr.indexOf(".");
	if(ix == -1) {
		digits = fStr;
	} else if(ix == 0) {
		digits = HxOverrides.substr(fStr,1,fStr.length);
	} else if(ix < fStr.length) {
		digits = HxOverrides.substr(fStr,0,ix) + HxOverrides.substr(fStr,ix + 1,fStr.length);
	}
	var LStr = digits;
	var numDigits = LStr.length;
	var L2 = f2;
	var numIntDigits = Std.string(L2).length;
	if(L2 == 0) {
		numIntDigits = 0;
	}
	var numDigitsPastDecimal = numDigits - numIntDigits;
	var i = numDigitsPastDecimal;
	var L = parseFloat(digits);
	while(i > 0 && L % 2 == 0) {
		L /= 2;
		--i;
	}
	i = numDigitsPastDecimal;
	while(i > 0 && L % 5 == 0) {
		L /= 5;
		--i;
	}
	var maxNumerator = L;
	var d2 = f2;
	var calcD;
	var prevCalcD = null;
	var this1 = [];
	var arrFraction = this1;
	var j = 0;
	var _g = 2;
	while(_g < 1000) {
		var i1 = _g++;
		var L21 = Math.floor(d2);
		numerators[i1] = L21 * numerators[i1 - 1] + numerators[i1 - 2] | 0;
		if(Math.abs(numerators[i1]) > maxNumerator) {
			break;
		}
		denominators[i1] = L21 * denominators[i1 - 1] + denominators[i1 - 2] | 0;
		calcD = numerators[i1] / denominators[i1];
		if(calcD == prevCalcD) {
			break;
		}
		var numerator = numerators[i1];
		var denominator = denominators[i1];
		var positive1 = positive;
		var value = f;
		var numNeg = numerator < 0;
		var denoNeg = denominator < 0;
		if(value == null) {
			value = positive1 ? numerator / denominator : -numerator / denominator;
		}
		if(numNeg || denoNeg) {
			if(!(numNeg && denoNeg)) {
				positive1 = !positive1;
			}
			if(numNeg) {
				numerator = -numerator;
			}
			if(denoNeg) {
				denominator = -denominator;
			}
		}
		var this2 = { numerator : numerator, denominator : denominator, positive : positive1, value : value};
		arrFraction[arrFraction.length] = this2;
		if(calcD == f2) {
			break;
		}
		prevCalcD = calcD;
		d2 = 1 / (d2 - L21);
	}
	return arrFraction;
};
trilateral_angle_Fracs.getMaxNumerator = function(f) {
	var fStr = f == null ? "null" : "" + f;
	var digits = "";
	var ix = fStr.indexOf(".");
	if(ix == -1) {
		digits = fStr;
	} else if(ix == 0) {
		digits = HxOverrides.substr(fStr,1,fStr.length);
	} else if(ix < fStr.length) {
		digits = HxOverrides.substr(fStr,0,ix) + HxOverrides.substr(fStr,ix + 1,fStr.length);
	}
	var LStr = digits;
	var numDigits = LStr.length;
	var L2 = f;
	var numIntDigits = (L2 == null ? "null" : "" + L2).length;
	if(L2 == 0) {
		numIntDigits = 0;
	}
	var numDigitsPastDecimal = numDigits - numIntDigits;
	var i = numDigitsPastDecimal;
	var L = parseFloat(digits);
	while(i > 0 && L % 2 == 0) {
		L /= 2;
		--i;
	}
	i = numDigitsPastDecimal;
	while(i > 0 && L % 5 == 0) {
		L /= 5;
		--i;
	}
	return L;
};
trilateral_angle_Fracs.extractDigitStr = function(fStr) {
	var f2 = "";
	var ixe = fStr.indexOf("E");
	if(ixe == -1) {
		ixe = fStr.indexOf("e");
	}
	if(ixe == -1) {
		f2 = fStr;
	} else {
		f2 = HxOverrides.substr(fStr,0,ixe);
	}
	var digits = "";
	var ix = f2.indexOf(".");
	if(ix == -1) {
		digits = f2;
	} else if(ix == 0) {
		digits = HxOverrides.substr(f2,1,f2.length);
	} else if(ix < f2.length) {
		digits = HxOverrides.substr(f2,0,ix) + HxOverrides.substr(f2,ix + 1,f2.length);
	}
	return digits;
};
trilateral_angle_Fracs.getMaxNumeratorStr = function(fStr) {
	var f2 = "";
	var ixe = fStr.indexOf("E");
	if(ixe == -1) {
		ixe = fStr.indexOf("e");
	}
	if(ixe == -1) {
		f2 = fStr;
	} else {
		f2 = HxOverrides.substr(fStr,0,ixe);
	}
	var digits = "";
	var ix = f2.indexOf(".");
	if(ix == -1) {
		digits = f2;
	} else if(ix == 0) {
		digits = HxOverrides.substr(f2,1,f2.length);
	} else if(ix < f2.length) {
		digits = HxOverrides.substr(f2,0,ix) + HxOverrides.substr(f2,ix + 1,f2.length);
	}
	var LStr = digits;
	var numDigits = LStr.length;
	var L2 = fStr;
	var numIntDigits = L2.length;
	if(L2 == "0") {
		numIntDigits = 0;
	}
	var numDigitsPastDecimal = numDigits - numIntDigits;
	var i = numDigitsPastDecimal;
	var L = parseFloat(fStr);
	while(i > 0 && L % 2 == 0) {
		L /= 2;
		--i;
	}
	i = numDigitsPastDecimal;
	while(i > 0 && L % 5 == 0) {
		L /= 5;
		--i;
	}
	return L;
};
var trilateral_angle__$Pi2pi_Pi2pi_$Impl_$ = {};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.__name__ = true;
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$._new = function(f) {
	var this1 = f;
	return this1;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.fromFloat = function(f) {
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this1 = f1;
	return this1;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.additionPi = function(this1,b) {
	var f = this1 + b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.subtractionPi = function(this1,b) {
	var f = this1 - b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.dividePi = function(this1,b) {
	var f = this1 / b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.timesPi = function(this1,b) {
	var f = this1 * b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.addition = function(this1,b) {
	var f = this1 + b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.subtraction = function(this1,b) {
	var f = this1 - b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.divide = function(this1,b) {
	var f = this1 / b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.times = function(this1,b) {
	var f = this1 * b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.get_degrees = function(this1) {
	return this1 * 180 / Math.PI;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.set_degrees = function(this1,val) {
	this1 = Math.PI * val / 180;
	return val;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.fromFraction = function(val) {
	var f = (val.positive ? val.numerator / val.denominator : -val.numerator / val.denominator) * Math.PI;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this1 = f1;
	return this1;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.tofraction = function(this1) {
	var f = this1 / Math.PI;
	var arr = trilateral_angle_Fracs.approximateFractions(f);
	var dist = Infinity;
	var dif;
	var l = arr.length;
	var fracFloat;
	var frac = trilateral_angle__$Fraction_Fraction_$Impl_$;
	var fracStore = arr[0];
	var _g = 0;
	var _g1 = l;
	while(_g < _g1) {
		var i = _g++;
		var frac1 = arr[i];
		fracFloat = frac1.positive ? frac1.numerator / frac1.denominator : -frac1.numerator / frac1.denominator;
		dif = Math.abs(fracFloat - f);
		if(dif < dist) {
			dist = dif;
			fracStore = frac1;
		}
	}
	return fracStore;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.fromString = function(val) {
	var i = val.indexOf("/");
	var frac;
	if(i != -1) {
		var numerator = Std.parseInt(HxOverrides.substr(val,0,i));
		var denominator = Std.parseInt(HxOverrides.substr(val,i + 1,val.length));
		var positive = true;
		var value = null;
		var numNeg = numerator < 0;
		var denoNeg = denominator < 0;
		if(value == null) {
			value = positive ? numerator / denominator : -numerator / denominator;
		}
		if(numNeg || denoNeg) {
			if(!(numNeg && denoNeg)) {
				positive = !positive;
			}
			if(numNeg) {
				numerator = -numerator;
			}
			if(denoNeg) {
				denominator = -denominator;
			}
		}
		var this1 = { numerator : numerator, denominator : denominator, positive : positive, value : value};
		frac = this1;
	} else {
		var f = parseFloat(val);
		var arr = trilateral_angle_Fracs.approximateFractions(f);
		var dist = Infinity;
		var dif;
		var l = arr.length;
		var fracFloat;
		var frac1 = trilateral_angle__$Fraction_Fraction_$Impl_$;
		var fracStore = arr[0];
		var _g = 0;
		var _g1 = l;
		while(_g < _g1) {
			var i1 = _g++;
			var frac2 = arr[i1];
			fracFloat = frac2.positive ? frac2.numerator / frac2.denominator : -frac2.numerator / frac2.denominator;
			dif = Math.abs(fracFloat - f);
			if(dif < dist) {
				dist = dif;
				fracStore = frac2;
			}
		}
		frac = fracStore;
	}
	var frac3 = frac;
	var f1 = (frac3.positive ? frac3.numerator / frac3.denominator : -frac3.numerator / frac3.denominator) * Math.PI;
	var f2;
	if(f1 <= Math.PI && f1 > -Math.PI) {
		f2 = f1;
	} else {
		var a = (f1 + Math.PI) % (2 * Math.PI);
		f2 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this2 = f2;
	return this2;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.toString = function(this1) {
	return Std.string(this1);
};
var trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$ = {};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.__name__ = true;
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$._new = function(f) {
	var this1 = f;
	return this1;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.fromFloat = function(f) {
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this1 = f1;
	return this1;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.additionPi = function(this1,b) {
	var f = this1 + b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.subtractionPi = function(this1,b) {
	var f = this1 - b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.dividePi = function(this1,b) {
	var f = this1 / b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.timesPi = function(this1,b) {
	var f = this1 * b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.addition = function(this1,b) {
	var f = this1 + b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.subtraction = function(this1,b) {
	var f = this1 - b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.divide = function(this1,b) {
	var f = this1 / b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.times = function(this1,b) {
	var f = this1 * b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.get_degrees = function(this1) {
	return this1 * 180 / Math.PI;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.set_degrees = function(this1,val) {
	this1 = Math.PI * val / 180;
	return val;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.fromFraction = function(val) {
	var f = (val.positive ? val.numerator / val.denominator : -val.numerator / val.denominator) * Math.PI;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this1 = f1;
	return this1;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.tofraction = function(this1) {
	var f = this1 / Math.PI;
	var arr = trilateral_angle_Fracs.approximateFractions(f);
	var dist = Infinity;
	var dif;
	var l = arr.length;
	var fracFloat;
	var frac = trilateral_angle__$Fraction_Fraction_$Impl_$;
	var fracStore = arr[0];
	var _g = 0;
	var _g1 = l;
	while(_g < _g1) {
		var i = _g++;
		var frac1 = arr[i];
		fracFloat = frac1.positive ? frac1.numerator / frac1.denominator : -frac1.numerator / frac1.denominator;
		dif = Math.abs(fracFloat - f);
		if(dif < dist) {
			dist = dif;
			fracStore = frac1;
		}
	}
	return fracStore;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.fromString = function(val) {
	var i = val.indexOf("/");
	var frac;
	if(i != -1) {
		var numerator = Std.parseInt(HxOverrides.substr(val,0,i));
		var denominator = Std.parseInt(HxOverrides.substr(val,i + 1,val.length));
		var positive = true;
		var value = null;
		var numNeg = numerator < 0;
		var denoNeg = denominator < 0;
		if(value == null) {
			value = positive ? numerator / denominator : -numerator / denominator;
		}
		if(numNeg || denoNeg) {
			if(!(numNeg && denoNeg)) {
				positive = !positive;
			}
			if(numNeg) {
				numerator = -numerator;
			}
			if(denoNeg) {
				denominator = -denominator;
			}
		}
		var this1 = { numerator : numerator, denominator : denominator, positive : positive, value : value};
		frac = this1;
	} else {
		var f = parseFloat(val);
		var arr = trilateral_angle_Fracs.approximateFractions(f);
		var dist = Infinity;
		var dif;
		var l = arr.length;
		var fracFloat;
		var frac1 = trilateral_angle__$Fraction_Fraction_$Impl_$;
		var fracStore = arr[0];
		var _g = 0;
		var _g1 = l;
		while(_g < _g1) {
			var i1 = _g++;
			var frac2 = arr[i1];
			fracFloat = frac2.positive ? frac2.numerator / frac2.denominator : -frac2.numerator / frac2.denominator;
			dif = Math.abs(fracFloat - f);
			if(dif < dist) {
				dist = dif;
				fracStore = frac2;
			}
		}
		frac = fracStore;
	}
	var frac3 = frac;
	var f1 = (frac3.positive ? frac3.numerator / frac3.denominator : -frac3.numerator / frac3.denominator) * Math.PI;
	var f2;
	if(f1 >= 0 && f1 > Math.PI) {
		f2 = f1;
	} else {
		var a = f1 % (2 * Math.PI);
		f2 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this2 = f2;
	return this2;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.toString = function(this1) {
	return Std.string(this1);
};
var trilateral_geom_Algebra = function() { };
trilateral_geom_Algebra.__name__ = true;
trilateral_geom_Algebra.theta = function(p0,p1) {
	var dx = p0.x - p1.x;
	var dy = p0.y - p1.y;
	return Math.atan2(dy,dx);
};
trilateral_geom_Algebra.dist = function(p0,p1) {
	var dx = p0.x - p1.x;
	var dy = p0.y - p1.y;
	return dx * dx + dy * dy;
};
trilateral_geom_Algebra.adjustWinding = function(A_,B_,C_) {
	var p0_x = B_.x - A_.x;
	var p0_y = B_.y - A_.y;
	var p1_x = C_.x - A_.x;
	var p1_y = C_.y - A_.y;
	var val = !(p0_x * p1_y - p0_y * p1_x < 0);
	return val;
};
trilateral_geom_Algebra.subtract = function(p0,p1) {
	return { x : p0.x - p1.x, y : p0.y - p1.y};
};
trilateral_geom_Algebra.cross = function(p0,p1) {
	return p0.x * p1.y - p0.y * p1.x;
};
trilateral_geom_Algebra.sign = function(n) {
	return Math.abs(n) / n | 0;
};
trilateral_geom_Algebra.quadratic = function(t,s,c,e) {
	var u = 1 - t;
	return Math.pow(u,2) * s + 2 * u * t * c + Math.pow(t,2) * e;
};
trilateral_geom_Algebra.cubic = function(t,s,c1,c2,e) {
	var u = 1 - t;
	return Math.pow(u,3) * s + 3 * Math.pow(u,2) * t * c1 + 3 * u * Math.pow(t,2) * c2 + Math.pow(t,3) * e;
};
trilateral_geom_Algebra.quadCurve = function(p,ax,ay,bx,by,cx,cy) {
	var x = ax - bx;
	var y = ay - by;
	var x1 = bx - cx;
	var y1 = by - cy;
	var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
	if(approxDistance == 0) {
		approxDistance = 0.000001;
	}
	var step = Math.min(1 / (approxDistance * 0.707),trilateral_geom_Algebra.quadStep);
	var l = p.length;
	p[l++] = ax;
	p[l++] = ay;
	var t = step;
	while(t < 1.) {
		var u = 1 - t;
		p[l++] = Math.pow(u,2) * ax + 2 * u * t * bx + Math.pow(t,2) * cx;
		var u1 = 1 - t;
		p[l++] = Math.pow(u1,2) * ay + 2 * u1 * t * by + Math.pow(t,2) * cy;
		t += step;
	}
	p[l++] = cx;
	p[l++] = cy;
	return p;
};
trilateral_geom_Algebra.cubicCurve = function(p,ax,ay,bx,by,cx,cy,dx,dy) {
	var x = ax - bx;
	var y = ay - by;
	var x1 = bx - cx;
	var y1 = by - cy;
	var x2 = cx - dx;
	var y2 = cy - dy;
	var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2);
	if(approxDistance == 0) {
		approxDistance = 0.000001;
	}
	var step = Math.min(1 / (approxDistance * 0.707),trilateral_geom_Algebra.cubicStep);
	var l = p.length;
	p[l++] = ax;
	p[l++] = ay;
	var t = step;
	while(t < 1.) {
		var u = 1 - t;
		p[l++] = Math.pow(u,3) * ax + 3 * Math.pow(u,2) * t * bx + 3 * u * Math.pow(t,2) * cx + Math.pow(t,3) * dx;
		var u1 = 1 - t;
		p[l++] = Math.pow(u1,3) * ay + 3 * Math.pow(u1,2) * t * by + 3 * u1 * Math.pow(t,2) * cy + Math.pow(t,3) * dy;
		t += step;
	}
	p[l++] = dx;
	p[l++] = dy;
	return p;
};
trilateral_geom_Algebra.calculateQuadStep = function(ax,ay,bx,by,cx,cy) {
	var x = ax - bx;
	var y = ay - by;
	var x1 = bx - cx;
	var y1 = by - cy;
	var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
	if(approxDistance == 0) {
		approxDistance = 0.000001;
	}
	return Math.min(1 / (approxDistance * 0.707),trilateral_geom_Algebra.quadStep);
};
trilateral_geom_Algebra.calculateCubicStep = function(ax,ay,bx,by,cx,cy,dx,dy) {
	var x = ax - bx;
	var y = ay - by;
	var x1 = bx - cx;
	var y1 = by - cy;
	var x2 = cx - dx;
	var y2 = cy - dy;
	var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2);
	if(approxDistance == 0) {
		approxDistance = 0.000001;
	}
	return Math.min(1 / (approxDistance * 0.707),trilateral_geom_Algebra.cubicStep);
};
trilateral_geom_Algebra.lineAB = function(A,B,width) {
	var dx = A.x - B.x;
	var dy = A.y - B.y;
	var P_x = A.x - width / 2;
	var P_y = A.y;
	var omega = Math.atan2(dy,dx);
	var dim_x = width;
	var dim_y = dx * dx + dy * dy;
	var pivotX = A.x + width / 2;
	var pivotY = A.y;
	var px = P_x;
	var py = P_y;
	var dx1 = dim_x;
	var dy1 = dim_y;
	var A_ = { x : px, y : py};
	var B_ = { x : px + dx1, y : py};
	var C_ = { x : px + dx1, y : py + dy1};
	var D_ = { x : px, y : py + dy1};
	if(omega != 0.) {
		var sin = Math.sin(omega);
		var cos = Math.cos(omega);
		var px1 = A_.x - pivotX;
		var py1 = A_.y - pivotY;
		var px2 = px1 * cos - py1 * sin;
		py1 = py1 * cos + px1 * sin;
		A_ = { x : px2 + pivotX, y : py1 + pivotY};
		var px3 = B_.x - pivotX;
		var py2 = B_.y - pivotY;
		var px21 = px3 * cos - py2 * sin;
		py2 = py2 * cos + px3 * sin;
		B_ = { x : px21 + pivotX, y : py2 + pivotY};
		var px4 = C_.x - pivotX;
		var py3 = C_.y - pivotY;
		var px22 = px4 * cos - py3 * sin;
		py3 = py3 * cos + px4 * sin;
		C_ = { x : px22 + pivotX, y : py3 + pivotY};
		var px5 = D_.x - pivotX;
		var py4 = D_.y - pivotY;
		var px23 = px5 * cos - py4 * sin;
		py4 = py4 * cos + px5 * sin;
		D_ = { x : px23 + pivotX, y : py4 + pivotY};
	}
	return { A : A_, B : B_, C : C_, D : D_};
};
trilateral_geom_Algebra.lineABCoord = function(ax,ay,bx,by,width) {
	var dx = ax - bx;
	var dy = ay - by;
	var P_x = ax - width / 2;
	var P_y = ay;
	var omega = Math.atan2(dy,dx);
	var dim_x = width;
	var dim_y = dx * dx + dy * dy;
	var pivotX = ax + width / 2;
	var px = P_x;
	var py = P_y;
	var dx1 = dim_x;
	var dy1 = dim_y;
	var A_ = { x : px, y : py};
	var B_ = { x : px + dx1, y : py};
	var C_ = { x : px + dx1, y : py + dy1};
	var D_ = { x : px, y : py + dy1};
	if(omega != 0.) {
		var sin = Math.sin(omega);
		var cos = Math.cos(omega);
		var px1 = A_.x - pivotX;
		var py1 = A_.y - ay;
		var px2 = px1 * cos - py1 * sin;
		py1 = py1 * cos + px1 * sin;
		A_ = { x : px2 + pivotX, y : py1 + ay};
		var px3 = B_.x - pivotX;
		var py2 = B_.y - ay;
		var px21 = px3 * cos - py2 * sin;
		py2 = py2 * cos + px3 * sin;
		B_ = { x : px21 + pivotX, y : py2 + ay};
		var px4 = C_.x - pivotX;
		var py3 = C_.y - ay;
		var px22 = px4 * cos - py3 * sin;
		py3 = py3 * cos + px4 * sin;
		C_ = { x : px22 + pivotX, y : py3 + ay};
		var px5 = D_.x - pivotX;
		var py4 = D_.y - ay;
		var px23 = px5 * cos - py4 * sin;
		py4 = py4 * cos + px5 * sin;
		D_ = { x : px23 + pivotX, y : py4 + ay};
	}
	return { A : A_, B : B_, C : C_, D : D_};
};
trilateral_geom_Algebra.rotateVectorLine = function(pos,dim,omega,pivotX,pivotY) {
	var px = pos.x;
	var py = pos.y;
	var dx = dim.x;
	var dy = dim.y;
	var A_ = { x : px, y : py};
	var B_ = { x : px + dx, y : py};
	var C_ = { x : px + dx, y : py + dy};
	var D_ = { x : px, y : py + dy};
	if(omega != 0.) {
		var sin = Math.sin(omega);
		var cos = Math.cos(omega);
		var px1 = A_.x - pivotX;
		var py1 = A_.y - pivotY;
		var px2 = px1 * cos - py1 * sin;
		py1 = py1 * cos + px1 * sin;
		A_ = { x : px2 + pivotX, y : py1 + pivotY};
		var px3 = B_.x - pivotX;
		var py2 = B_.y - pivotY;
		var px21 = px3 * cos - py2 * sin;
		py2 = py2 * cos + px3 * sin;
		B_ = { x : px21 + pivotX, y : py2 + pivotY};
		var px4 = C_.x - pivotX;
		var py3 = C_.y - pivotY;
		var px22 = px4 * cos - py3 * sin;
		py3 = py3 * cos + px4 * sin;
		C_ = { x : px22 + pivotX, y : py3 + pivotY};
		var px5 = D_.x - pivotX;
		var py4 = D_.y - pivotY;
		var px23 = px5 * cos - py4 * sin;
		py4 = py4 * cos + px5 * sin;
		D_ = { x : px23 + pivotX, y : py4 + pivotY};
	}
	return { A : A_, B : B_, C : C_, D : D_};
};
trilateral_geom_Algebra.pivotCheap = function(p,sin,cos,pivotX,pivotY) {
	var px = p.x - pivotX;
	var py = p.y - pivotY;
	var px2 = px * cos - py * sin;
	py = py * cos + px * sin;
	return { x : px2 + pivotX, y : py + pivotY};
};
trilateral_geom_Algebra.pivot = function(p,omega,pivotX,pivotY) {
	var px = p.x - pivotX;
	var py = p.y - pivotY;
	var px2 = px * Math.cos(omega) - py * Math.sin(omega);
	py = py * Math.cos(omega) + px * Math.sin(omega);
	return { x : px2 + pivotX, y : py + pivotY};
};
trilateral_geom_Algebra.thetaCheap = function(dx,dy) {
	return Math.atan2(dy,dx);
};
trilateral_geom_Algebra.distCheap = function(dx,dy) {
	return dx * dx + dy * dy;
};
trilateral_geom_Algebra.distance = function(px,py,qx,qy) {
	var x = px - qx;
	var y = py - qy;
	return Math.sqrt(x * x + y * y);
};
var trilateral_geom_Contour = function(triArr_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.counter = 0;
	this.count = 0;
	this.pointsAnti = [];
	this.pointsClock = [];
	this.triArr = triArr_;
	this.endLine = endLine_;
};
trilateral_geom_Contour.__name__ = true;
trilateral_geom_Contour.thetaCompute = function(px,py,qx,qy) {
	return Math.atan2(py - qy,px - qx);
};
trilateral_geom_Contour.dist = function(px,py,qx,qy) {
	var x = px - qx;
	var y = py - qy;
	return x * x + y * y;
};
trilateral_geom_Contour.prototype = {
	reset: function() {
		this.angleA = 0;
		this.count = 0;
		this.kax = 0;
		this.kay = 0;
		this.kbx = 0;
		this.kby = 0;
		this.kcx = 0;
		this.kcy = 0;
		this.ncx = 0;
		this.ncy = 0;
		this.ax = 0;
		this.ay = 0;
		this.bx = 0;
		this.by = 0;
		this.cx = 0;
		this.cy = 0;
		this.dx = null;
		this.dy = null;
		this.ex = null;
		this.ey = null;
		this.pointsClock.length = 0;
		this.pointsAnti.length = 0;
	}
	,triangleJoin: function(ax_,ay_,bx_,by_,width_,curveEnds,overlap) {
		if(overlap == null) {
			overlap = false;
		}
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = this.dx != null ? this.angle1 : null;
		this.halfA = Math.PI / 2;
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var x = this.dxOld - bx_;
		var y = this.dyOld - by_;
		var x1 = this.exOld - bx_;
		var y1 = this.eyOld - by_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(this.ay - this.dyOld,this.ax - this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.eyPrev,this.ax - this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(this.ay - this.eyOld,this.ax - this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.dyPrev,this.ax - this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f1;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f1 = theta1;
			} else {
				var a1 = theta1 % (2 * Math.PI);
				f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
			}
			var this2 = f1;
			var zb = this2;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(theta0 - theta1);
			var clockwise = theta0 < theta1;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f2;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f2 = theta0;
			} else {
				var a2 = theta0 % (2 * Math.PI);
				f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
			}
			var this3 = f2;
			var za1 = this3;
			var f3;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f3 = theta1;
			} else {
				var a3 = theta1 % (2 * Math.PI);
				f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
			}
			var this4 = f3;
			var zb1 = this4;
			var fa1 = za1;
			var fb1 = zb1;
			var theta2 = Math.abs(theta0 - theta1);
			var clockwise1 = theta0 < theta1;
			var dif2 = clockwise1 ? theta2 : -theta2;
			dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
			break;
		case 2:
			var f4;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f4 = theta0;
			} else {
				var a4 = theta0 % (2 * Math.PI);
				f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
			}
			var this5 = f4;
			var za2 = this5;
			var f5;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f5 = theta1;
			} else {
				var a5 = theta1 % (2 * Math.PI);
				f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
			}
			var this6 = f5;
			var zb2 = this6;
			var fa2 = theta0;
			var fb2 = theta1;
			var theta3 = Math.abs(theta0 - theta1);
			var smallest = theta3 <= Math.PI;
			var clockwise2 = theta0 < theta1;
			var dif3 = clockwise2 ? theta3 : -theta3;
			dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
			break;
		case 3:
			var f6;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f6 = theta0;
			} else {
				var a6 = theta0 % (2 * Math.PI);
				f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
			}
			var this7 = f6;
			var za3 = this7;
			var f7;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f7 = theta1;
			} else {
				var a7 = theta1 % (2 * Math.PI);
				f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
			}
			var this8 = f7;
			var zb3 = this8;
			var fa3 = theta0;
			var fb3 = theta1;
			var theta4 = Math.abs(theta0 - theta1);
			var largest = theta4 > Math.PI;
			var clockwise3 = theta0 < theta1;
			var dif4 = clockwise3 ? theta4 : -theta4;
			dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta4) : 2 * Math.PI - theta4;
			break;
		}
		if(!overlap && this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f8;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f8 = theta0;
			} else {
				var a8 = (theta0 + Math.PI) % (2 * Math.PI);
				f8 = a8 >= 0 ? a8 - Math.PI : a8 + Math.PI;
			}
			var this9 = f8;
			var start = this9;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			this.jx = this.ax + h * Math.sin(delta);
			this.jy = this.ay + h * Math.cos(delta);
		}
		if(this.count == 0 && (this.endLine == 1 || this.endLine == 3)) {
			var ax = this.ax;
			var ay = this.ay;
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma1 = -this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			var this10 = this.triArr;
			var t = [];
			var this11;
			if(t == null) {
				var t1 = [];
				var this12 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
				this11 = this12;
			} else {
				this11 = t;
			}
			var this13 = this11;
			var out = this13;
			var pi = Math.PI;
			var step = pi * 2 / 36;
			var dif5;
			switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f9;
				if(beta >= 0 && beta > Math.PI) {
					f9 = beta;
				} else {
					var a9 = beta % (2 * Math.PI);
					f9 = a9 >= 0 ? a9 : a9 + 2 * Math.PI;
				}
				var this14 = f9;
				var za4 = this14;
				var f10;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f10 = gamma1;
				} else {
					var a10 = gamma1 % (2 * Math.PI);
					f10 = a10 >= 0 ? a10 : a10 + 2 * Math.PI;
				}
				var this15 = f10;
				var zb4 = this15;
				var fa4 = za4;
				var fb4 = zb4;
				var theta5 = Math.abs(beta - gamma1);
				var clockwise4 = beta < gamma1;
				var dif6 = clockwise4 ? theta5 : -theta5;
				dif5 = dif6 > 0 ? dif6 : 2 * Math.PI + dif6;
				break;
			case 1:
				var f11;
				if(beta >= 0 && beta > Math.PI) {
					f11 = beta;
				} else {
					var a11 = beta % (2 * Math.PI);
					f11 = a11 >= 0 ? a11 : a11 + 2 * Math.PI;
				}
				var this16 = f11;
				var za5 = this16;
				var f12;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f12 = gamma1;
				} else {
					var a12 = gamma1 % (2 * Math.PI);
					f12 = a12 >= 0 ? a12 : a12 + 2 * Math.PI;
				}
				var this17 = f12;
				var zb5 = this17;
				var fa5 = za5;
				var fb5 = zb5;
				var theta6 = Math.abs(beta - gamma1);
				var clockwise5 = beta < gamma1;
				var dif7 = clockwise5 ? theta6 : -theta6;
				dif5 = dif7 < 0 ? dif7 : -2 * Math.PI + dif7;
				break;
			case 2:
				var f13;
				if(beta >= 0 && beta > Math.PI) {
					f13 = beta;
				} else {
					var a13 = beta % (2 * Math.PI);
					f13 = a13 >= 0 ? a13 : a13 + 2 * Math.PI;
				}
				var this18 = f13;
				var za6 = this18;
				var f14;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f14 = gamma1;
				} else {
					var a14 = gamma1 % (2 * Math.PI);
					f14 = a14 >= 0 ? a14 : a14 + 2 * Math.PI;
				}
				var this19 = f14;
				var zb6 = this19;
				var fa6 = beta;
				var fb6 = gamma1;
				var theta7 = Math.abs(beta - gamma1);
				var smallest1 = theta7 <= Math.PI;
				var clockwise6 = beta < gamma1;
				var dif8 = clockwise6 ? theta7 : -theta7;
				dif5 = smallest1 ? dif8 : clockwise6 ? -(2 * Math.PI - theta7) : 2 * Math.PI - theta7;
				break;
			case 3:
				var f15;
				if(beta >= 0 && beta > Math.PI) {
					f15 = beta;
				} else {
					var a15 = beta % (2 * Math.PI);
					f15 = a15 >= 0 ? a15 : a15 + 2 * Math.PI;
				}
				var this20 = f15;
				var za7 = this20;
				var f16;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f16 = gamma1;
				} else {
					var a16 = gamma1 % (2 * Math.PI);
					f16 = a16 >= 0 ? a16 : a16 + 2 * Math.PI;
				}
				var this21 = f16;
				var zb7 = this21;
				var fa7 = beta;
				var fb7 = gamma1;
				var theta8 = Math.abs(beta - gamma1);
				var largest1 = theta8 > Math.PI;
				var clockwise7 = beta < gamma1;
				var dif9 = clockwise7 ? theta8 : -theta8;
				dif5 = largest1 ? dif9 : clockwise7 ? -(2 * Math.PI - theta8) : 2 * Math.PI - theta8;
				break;
			}
			var positive = dif5 >= 0;
			var totalSteps = Math.ceil(Math.abs(dif5) / step);
			var step1 = dif5 / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					var t2 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
					out[out.length] = t2;
				}
				angle += step1;
				bx = cx;
				by = cy;
			}
			var triArr = out;
			var _g2 = 0;
			while(_g2 < triArr.length) {
				var t3 = triArr[_g2];
				++_g2;
				this10[this10.length] = t3;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g3 = 0;
			var _g11 = p4;
			while(_g3 < _g11) {
				var i1 = _g3++;
				this.pointsAnti[pA++] = temp[len - 2 * i1 + 1];
				this.pointsAnti[pA++] = temp[len - 2 * i1];
			}
			var pC = this.pointsClock.length;
			var _g21 = 0;
			var _g31 = p4;
			while(_g21 < _g31) {
				var i2 = _g21++;
				this.pointsClock[pC++] = temp[i2 * 2 + len + 1];
				this.pointsClock[pC++] = temp[i2 * 2 + len];
			}
		}
		if(overlap) {
			var this22 = this.triArr;
			var tri = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,0);
			this22[this22.length] = tri;
			var this23 = this.triArr;
			var tri1 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,0);
			this23[this23.length] = tri1;
		} else {
			if(this.count != 0) {
				this.addQuads(clockWise,width_);
			}
			this.quadIndex = this.triArr.length;
			if(this.count == 0) {
				this.penultimateAX = this.dxPrev;
				this.penultimateAY = this.dyPrev;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.penultimateCX = this.dx;
				this.penultimateCY = this.dy;
				this.lastClockX = this.exPrev;
				this.lastClockY = this.eyPrev;
				var this24 = this.triArr;
				var tri2 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,0);
				this24[this24.length] = tri2;
				var this25 = this.triArr;
				var tri3 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,0);
				this25[this25.length] = tri3;
			} else {
				if(clockWise && !this.lastClock) {
					this.penultimateAX = this.jx;
					this.penultimateAY = this.jy;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.exPrev;
					this.lastClockY = this.eyPrev;
					var this26 = this.triArr;
					var tri4 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,0);
					this26[this26.length] = tri4;
					var this27 = this.triArr;
					var tri5 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,0);
					this27[this27.length] = tri5;
				}
				if(clockWise && this.lastClock) {
					this.penultimateAX = this.jx;
					this.penultimateAY = this.jy;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.exPrev;
					this.lastClockY = this.eyPrev;
					var this28 = this.triArr;
					var tri6 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,0);
					this28[this28.length] = tri6;
					var this29 = this.triArr;
					var tri7 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,0);
					this29[this29.length] = tri7;
				}
				if(!clockWise && !this.lastClock) {
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.jx;
					this.lastClockY = this.jy;
					this.penultimateAX = this.dxPrev;
					this.penultimateAY = this.dyPrev;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					var this30 = this.triArr;
					var tri8 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.jx,this.jy,0);
					this30[this30.length] = tri8;
					var this31 = this.triArr;
					var tri9 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,0);
					this31[this31.length] = tri9;
				}
				if(!clockWise && this.lastClock) {
					this.penultimateAX = this.dxPrev;
					this.penultimateAY = this.dyPrev;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.jx;
					this.penultimateCY = this.jy;
					this.lastClockX = this.dx;
					this.lastClockY = this.dy;
					var this32 = this.triArr;
					var tri10 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,0);
					this32[this32.length] = tri10;
					var this33 = this.triArr;
					var tri11 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.jx,this.jy,this.ex,this.ey,0);
					this33[this33.length] = tri11;
				}
			}
		}
		if(curveEnds) {
			if(clockWise) {
				var radius1 = width_ / 2;
				var edgePoly = this.pointsClock;
				var t4 = [];
				var this34;
				if(t4 == null) {
					var t5 = [];
					var this35 = t5 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t5;
					this34 = this35;
				} else {
					this34 = t4;
				}
				var this36 = this34;
				var out1 = this36;
				var pi1 = Math.PI;
				var step2 = pi1 * 2 / 36;
				var positive1 = dif >= 0;
				var totalSteps1 = Math.ceil(Math.abs(dif) / step2);
				var step3 = dif / totalSteps1;
				var angle1 = theta0;
				var cx1;
				var cy1;
				var bx1 = 0;
				var by1 = 0;
				var p21 = edgePoly.length;
				var count = 0;
				var _g4 = 0;
				var _g12 = totalSteps1 + 1;
				while(_g4 < _g12) {
					var i3 = _g4++;
					cx1 = ax_ + radius1 * Math.sin(angle1);
					cy1 = ay_ + radius1 * Math.cos(angle1);
					if(i3 != 0) {
						var t6 = new trilateral_tri_Trilateral(ax_,ay_,bx1,by1,cx1,cy1);
						out1[out1.length] = t6;
						edgePoly[p21++] = cx1;
						edgePoly[p21++] = cy1;
					}
					angle1 += step3;
					bx1 = cx1;
					by1 = cy1;
				}
				var trilateralArray = out1;
				var this37 = this.triArr;
				var _g5 = 0;
				while(_g5 < trilateralArray.length) {
					var t7 = trilateralArray[_g5];
					++_g5;
					this37[this37.length] = t7;
				}
			} else {
				var radius2 = width_ / 2;
				var edgePoly1 = this.pointsAnti;
				var t8 = [];
				var this38;
				if(t8 == null) {
					var t9 = [];
					var this39 = t9 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t9;
					this38 = this39;
				} else {
					this38 = t8;
				}
				var this40 = this38;
				var out2 = this40;
				var pi2 = Math.PI;
				var step4 = pi2 * 2 / 36;
				var positive2 = dif >= 0;
				var totalSteps2 = Math.ceil(Math.abs(dif) / step4);
				var step5 = dif / totalSteps2;
				var angle2 = theta0;
				var cx2;
				var cy2;
				var bx2 = 0;
				var by2 = 0;
				var p22 = edgePoly1.length;
				var count1 = 0;
				var _g6 = 0;
				var _g13 = totalSteps2 + 1;
				while(_g6 < _g13) {
					var i4 = _g6++;
					cx2 = ax_ + radius2 * Math.sin(angle2);
					cy2 = ay_ + radius2 * Math.cos(angle2);
					if(i4 != 0) {
						var t10 = new trilateral_tri_Trilateral(ax_,ay_,bx2,by2,cx2,cy2);
						out2[out2.length] = t10;
						edgePoly1[p22++] = cx2;
						edgePoly1[p22++] = cy2;
					}
					angle2 += step5;
					bx2 = cx2;
					by2 = cy2;
				}
				var trilateralArray1 = out2;
				var this41 = this.triArr;
				var _g7 = 0;
				while(_g7 < trilateralArray1.length) {
					var t11 = trilateralArray1[_g7];
					++_g7;
					this41[this41.length] = t11;
				}
			}
		} else if(this.count != 0) {
			if(overlap) {
				if(clockWise) {
					var this42 = this.triArr;
					var tri12 = new trilateral_tri_Trilateral(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.ax,this.ay,0);
					this42[this42.length] = tri12;
				} else {
					var this43 = this.triArr;
					var tri13 = new trilateral_tri_Trilateral(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.ax,this.ay,0);
					this43[this43.length] = tri13;
				}
			} else if(clockWise) {
				var this44 = this.triArr;
				var tri14 = new trilateral_tri_Trilateral(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.jx,this.jy,0);
				this44[this44.length] = tri14;
			} else {
				var this45 = this.triArr;
				var tri15 = new trilateral_tri_Trilateral(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.jx,this.jy,0);
				this45[this45.length] = tri15;
			}
		}
		this.kax = this.dxPrev;
		this.kay = this.dyPrev;
		this.kbx = this.dx;
		this.kby = this.dy;
		this.ncx = this.exPrev;
		this.ncy = this.eyPrev;
		this.kcx = this.ex;
		this.kcy = this.ey;
		if(curveEnds && !overlap && this.count != 0) {
			if(clockWise) {
				var this46 = this.triArr;
				var tri16 = new trilateral_tri_Trilateral(this.ax,this.ay,this.dxOld,this.dyOld,this.jx,this.jy,0);
				this46[this46.length] = tri16;
				var this47 = this.triArr;
				var tri17 = new trilateral_tri_Trilateral(this.ax,this.ay,this.exPrev,this.eyPrev,this.jx,this.jy,0);
				this47[this47.length] = tri17;
			} else {
				var this48 = this.triArr;
				var tri18 = new trilateral_tri_Trilateral(this.ax,this.ay,this.exOld,this.eyOld,this.jx,this.jy,0);
				this48[this48.length] = tri18;
				var this49 = this.triArr;
				var tri19 = new trilateral_tri_Trilateral(this.ax,this.ay,this.dxPrev,this.dyPrev,this.jx,this.jy,0);
				this49[this49.length] = tri19;
			}
		}
		this.jxOld = this.jx;
		this.jyOld = this.jy;
		this.lastClock = clockWise;
		this.count++;
		return this.triArr;
	}
	,overlapQuad: function() {
		var this1 = this.triArr;
		var tri = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,0);
		this1[this1.length] = tri;
		var this2 = this.triArr;
		var tri1 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,0);
		this2[this2.length] = tri1;
	}
	,end: function(width_) {
		this.endEdges();
		if(this.count != 0) {
			var ax = this.bx;
			var ay = this.by;
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var temp = [];
			var this1 = this.triArr;
			var t = [];
			var this2;
			if(t == null) {
				var t1 = [];
				var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
				this2 = this3;
			} else {
				this2 = t;
			}
			var this4 = this2;
			var out = this4;
			var pi = Math.PI;
			var step = pi * 2 / 36;
			var dif;
			switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this5 = f;
				var za = this5;
				var f1;
				if(gamma >= 0 && gamma > Math.PI) {
					f1 = gamma;
				} else {
					var a1 = gamma % (2 * Math.PI);
					f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
				}
				var this6 = f1;
				var zb = this6;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(beta - gamma);
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f2;
				if(beta >= 0 && beta > Math.PI) {
					f2 = beta;
				} else {
					var a2 = beta % (2 * Math.PI);
					f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
				}
				var this7 = f2;
				var za1 = this7;
				var f3;
				if(gamma >= 0 && gamma > Math.PI) {
					f3 = gamma;
				} else {
					var a3 = gamma % (2 * Math.PI);
					f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
				}
				var this8 = f3;
				var zb1 = this8;
				var fa1 = za1;
				var fb1 = zb1;
				var theta1 = Math.abs(beta - gamma);
				var clockwise1 = beta < gamma;
				var dif2 = clockwise1 ? theta1 : -theta1;
				dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
				break;
			case 2:
				var f4;
				if(beta >= 0 && beta > Math.PI) {
					f4 = beta;
				} else {
					var a4 = beta % (2 * Math.PI);
					f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
				}
				var this9 = f4;
				var za2 = this9;
				var f5;
				if(gamma >= 0 && gamma > Math.PI) {
					f5 = gamma;
				} else {
					var a5 = gamma % (2 * Math.PI);
					f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
				}
				var this10 = f5;
				var zb2 = this10;
				var fa2 = beta;
				var fb2 = gamma;
				var theta2 = Math.abs(beta - gamma);
				var smallest = theta2 <= Math.PI;
				var clockwise2 = beta < gamma;
				var dif3 = clockwise2 ? theta2 : -theta2;
				dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
				break;
			case 3:
				var f6;
				if(beta >= 0 && beta > Math.PI) {
					f6 = beta;
				} else {
					var a6 = beta % (2 * Math.PI);
					f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
				}
				var this11 = f6;
				var za3 = this11;
				var f7;
				if(gamma >= 0 && gamma > Math.PI) {
					f7 = gamma;
				} else {
					var a7 = gamma % (2 * Math.PI);
					f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
				}
				var this12 = f7;
				var zb3 = this12;
				var fa3 = beta;
				var fb3 = gamma;
				var theta3 = Math.abs(beta - gamma);
				var largest = theta3 > Math.PI;
				var clockwise3 = beta < gamma;
				var dif4 = clockwise3 ? theta3 : -theta3;
				dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step1 = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					var t2 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
					out[out.length] = t2;
				}
				angle += step1;
				bx = cx;
				by = cy;
			}
			var triArr = out;
			var _g2 = 0;
			while(_g2 < triArr.length) {
				var t3 = triArr[_g2];
				++_g2;
				this1[this1.length] = t3;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var _g3 = 0;
			var _g11 = len + 2;
			while(_g3 < _g11) {
				var i1 = _g3++;
				this.pointsAnti[pA++] = temp[i1];
			}
			var pC = this.pointsClock.length;
			var _g21 = 1;
			var _g31 = len / 2 + 1 | 0;
			while(_g21 < _g31) {
				var i2 = _g21++;
				this.pointsClock[pC++] = temp[temp.length - 2 * i2];
				this.pointsClock[pC++] = temp[temp.length - 2 * i2 - 1];
			}
		}
	}
	,add: function(trilateral1) {
		var this1 = this.triArr;
		this1[this1.length] = trilateral1;
	}
	,addArray: function(trilateralArray) {
		var this1 = this.triArr;
		var _g = 0;
		while(_g < trilateralArray.length) {
			var t = trilateralArray[_g];
			++_g;
			this1[this1.length] = t;
		}
	}
	,addTri: function(ax_,ay_,bx_,by_,cx_,cy_,mark_) {
		if(mark_ == null) {
			mark_ = 0;
		}
		var this1 = this.triArr;
		var tri = new trilateral_tri_Trilateral(ax_,ay_,bx_,by_,cx_,cy_,mark_);
		this1[this1.length] = tri;
	}
	,addPieXstart: function(ax,ay,radius,beta,gamma,prefer,mark,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(mark == null) {
			mark = 0;
		}
		var temp = [];
		var this1 = this.triArr;
		var t = [];
		var this2;
		if(t == null) {
			var t1 = [];
			var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this2 = this3;
		} else {
			this2 = t;
		}
		var this4 = this2;
		var out = this4;
		var pi = Math.PI;
		var step = pi * 2 / sides;
		var dif;
		switch(prefer._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this5 = f;
			var za = this5;
			var f1;
			if(gamma >= 0 && gamma > Math.PI) {
				f1 = gamma;
			} else {
				var a1 = gamma % (2 * Math.PI);
				f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
			}
			var this6 = f1;
			var zb = this6;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(beta - gamma);
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f2;
			if(beta >= 0 && beta > Math.PI) {
				f2 = beta;
			} else {
				var a2 = beta % (2 * Math.PI);
				f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
			}
			var this7 = f2;
			var za1 = this7;
			var f3;
			if(gamma >= 0 && gamma > Math.PI) {
				f3 = gamma;
			} else {
				var a3 = gamma % (2 * Math.PI);
				f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
			}
			var this8 = f3;
			var zb1 = this8;
			var fa1 = za1;
			var fb1 = zb1;
			var theta1 = Math.abs(beta - gamma);
			var clockwise1 = beta < gamma;
			var dif2 = clockwise1 ? theta1 : -theta1;
			dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
			break;
		case 2:
			var f4;
			if(beta >= 0 && beta > Math.PI) {
				f4 = beta;
			} else {
				var a4 = beta % (2 * Math.PI);
				f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
			}
			var this9 = f4;
			var za2 = this9;
			var f5;
			if(gamma >= 0 && gamma > Math.PI) {
				f5 = gamma;
			} else {
				var a5 = gamma % (2 * Math.PI);
				f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
			}
			var this10 = f5;
			var zb2 = this10;
			var fa2 = beta;
			var fb2 = gamma;
			var theta2 = Math.abs(beta - gamma);
			var smallest = theta2 <= Math.PI;
			var clockwise2 = beta < gamma;
			var dif3 = clockwise2 ? theta2 : -theta2;
			dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
			break;
		case 3:
			var f6;
			if(beta >= 0 && beta > Math.PI) {
				f6 = beta;
			} else {
				var a6 = beta % (2 * Math.PI);
				f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
			}
			var this11 = f6;
			var za3 = this11;
			var f7;
			if(gamma >= 0 && gamma > Math.PI) {
				f7 = gamma;
			} else {
				var a7 = gamma % (2 * Math.PI);
				f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
			}
			var this12 = f7;
			var zb3 = this12;
			var fa3 = beta;
			var fb3 = gamma;
			var theta3 = Math.abs(beta - gamma);
			var largest = theta3 > Math.PI;
			var clockwise3 = beta < gamma;
			var dif4 = clockwise3 ? theta3 : -theta3;
			dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step1 = dif / totalSteps;
		var angle = beta;
		var cx;
		var cy;
		var bx = 0;
		var by = 0;
		var p2 = temp.length;
		var _g = 0;
		var _g1 = totalSteps + 1;
		while(_g < _g1) {
			var i = _g++;
			cx = ax + radius * Math.sin(angle);
			cy = ay + radius * Math.cos(angle);
			temp[p2++] = cx;
			temp[p2++] = cy;
			if(i != 0) {
				var t2 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
				out[out.length] = t2;
				if(mark != 0) {
					t2.mark = mark;
				}
			}
			angle += step1;
			bx = cx;
			by = cy;
		}
		var triArr = out;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t3 = triArr[_g2];
			++_g2;
			this1[this1.length] = t3;
		}
		var pA = this.pointsAnti.length;
		var len = temp.length / 2 | 0;
		var p4 = temp.length / 4 | 0;
		var _g3 = 0;
		var _g11 = p4;
		while(_g3 < _g11) {
			var i1 = _g3++;
			this.pointsAnti[pA++] = temp[len - 2 * i1 + 1];
			this.pointsAnti[pA++] = temp[len - 2 * i1];
		}
		var pC = this.pointsClock.length;
		var _g21 = 0;
		var _g31 = p4;
		while(_g21 < _g31) {
			var i2 = _g21++;
			this.pointsClock[pC++] = temp[i2 * 2 + len + 1];
			this.pointsClock[pC++] = temp[i2 * 2 + len];
		}
	}
	,addPieX: function(ax,ay,radius,beta,gamma,prefer,mark,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(mark == null) {
			mark = 0;
		}
		var temp = [];
		var this1 = this.triArr;
		var t = [];
		var this2;
		if(t == null) {
			var t1 = [];
			var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this2 = this3;
		} else {
			this2 = t;
		}
		var this4 = this2;
		var out = this4;
		var pi = Math.PI;
		var step = pi * 2 / sides;
		var dif;
		switch(prefer._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this5 = f;
			var za = this5;
			var f1;
			if(gamma >= 0 && gamma > Math.PI) {
				f1 = gamma;
			} else {
				var a1 = gamma % (2 * Math.PI);
				f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
			}
			var this6 = f1;
			var zb = this6;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(beta - gamma);
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f2;
			if(beta >= 0 && beta > Math.PI) {
				f2 = beta;
			} else {
				var a2 = beta % (2 * Math.PI);
				f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
			}
			var this7 = f2;
			var za1 = this7;
			var f3;
			if(gamma >= 0 && gamma > Math.PI) {
				f3 = gamma;
			} else {
				var a3 = gamma % (2 * Math.PI);
				f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
			}
			var this8 = f3;
			var zb1 = this8;
			var fa1 = za1;
			var fb1 = zb1;
			var theta1 = Math.abs(beta - gamma);
			var clockwise1 = beta < gamma;
			var dif2 = clockwise1 ? theta1 : -theta1;
			dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
			break;
		case 2:
			var f4;
			if(beta >= 0 && beta > Math.PI) {
				f4 = beta;
			} else {
				var a4 = beta % (2 * Math.PI);
				f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
			}
			var this9 = f4;
			var za2 = this9;
			var f5;
			if(gamma >= 0 && gamma > Math.PI) {
				f5 = gamma;
			} else {
				var a5 = gamma % (2 * Math.PI);
				f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
			}
			var this10 = f5;
			var zb2 = this10;
			var fa2 = beta;
			var fb2 = gamma;
			var theta2 = Math.abs(beta - gamma);
			var smallest = theta2 <= Math.PI;
			var clockwise2 = beta < gamma;
			var dif3 = clockwise2 ? theta2 : -theta2;
			dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
			break;
		case 3:
			var f6;
			if(beta >= 0 && beta > Math.PI) {
				f6 = beta;
			} else {
				var a6 = beta % (2 * Math.PI);
				f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
			}
			var this11 = f6;
			var za3 = this11;
			var f7;
			if(gamma >= 0 && gamma > Math.PI) {
				f7 = gamma;
			} else {
				var a7 = gamma % (2 * Math.PI);
				f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
			}
			var this12 = f7;
			var zb3 = this12;
			var fa3 = beta;
			var fb3 = gamma;
			var theta3 = Math.abs(beta - gamma);
			var largest = theta3 > Math.PI;
			var clockwise3 = beta < gamma;
			var dif4 = clockwise3 ? theta3 : -theta3;
			dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step1 = dif / totalSteps;
		var angle = beta;
		var cx;
		var cy;
		var bx = 0;
		var by = 0;
		var p2 = temp.length;
		var _g = 0;
		var _g1 = totalSteps + 1;
		while(_g < _g1) {
			var i = _g++;
			cx = ax + radius * Math.sin(angle);
			cy = ay + radius * Math.cos(angle);
			temp[p2++] = cx;
			temp[p2++] = cy;
			if(i != 0) {
				var t2 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
				out[out.length] = t2;
				if(mark != 0) {
					t2.mark = mark;
				}
			}
			angle += step1;
			bx = cx;
			by = cy;
		}
		var triArr = out;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t3 = triArr[_g2];
			++_g2;
			this1[this1.length] = t3;
		}
		var pA = this.pointsAnti.length;
		var len = temp.length / 2 | 0;
		var _g3 = 0;
		var _g11 = len + 2;
		while(_g3 < _g11) {
			var i1 = _g3++;
			this.pointsAnti[pA++] = temp[i1];
		}
		var pC = this.pointsClock.length;
		var _g21 = 1;
		var _g31 = len / 2 + 1 | 0;
		while(_g21 < _g31) {
			var i2 = _g21++;
			this.pointsClock[pC++] = temp[temp.length - 2 * i2];
			this.pointsClock[pC++] = temp[temp.length - 2 * i2 - 1];
		}
	}
	,addPie: function(ax,ay,radius,beta,gamma,prefer,mark,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(mark == null) {
			mark = 0;
		}
		var this1 = this.triArr;
		var t = [];
		var this2;
		if(t == null) {
			var t1 = [];
			var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this2 = this3;
		} else {
			this2 = t;
		}
		var this4 = this2;
		var out = this4;
		var pi = Math.PI;
		var step = pi * 2 / sides;
		var dif;
		switch(prefer._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this5 = f;
			var za = this5;
			var f1;
			if(gamma >= 0 && gamma > Math.PI) {
				f1 = gamma;
			} else {
				var a1 = gamma % (2 * Math.PI);
				f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
			}
			var this6 = f1;
			var zb = this6;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(beta - gamma);
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f2;
			if(beta >= 0 && beta > Math.PI) {
				f2 = beta;
			} else {
				var a2 = beta % (2 * Math.PI);
				f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
			}
			var this7 = f2;
			var za1 = this7;
			var f3;
			if(gamma >= 0 && gamma > Math.PI) {
				f3 = gamma;
			} else {
				var a3 = gamma % (2 * Math.PI);
				f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
			}
			var this8 = f3;
			var zb1 = this8;
			var fa1 = za1;
			var fb1 = zb1;
			var theta1 = Math.abs(beta - gamma);
			var clockwise1 = beta < gamma;
			var dif2 = clockwise1 ? theta1 : -theta1;
			dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
			break;
		case 2:
			var f4;
			if(beta >= 0 && beta > Math.PI) {
				f4 = beta;
			} else {
				var a4 = beta % (2 * Math.PI);
				f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
			}
			var this9 = f4;
			var za2 = this9;
			var f5;
			if(gamma >= 0 && gamma > Math.PI) {
				f5 = gamma;
			} else {
				var a5 = gamma % (2 * Math.PI);
				f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
			}
			var this10 = f5;
			var zb2 = this10;
			var fa2 = beta;
			var fb2 = gamma;
			var theta2 = Math.abs(beta - gamma);
			var smallest = theta2 <= Math.PI;
			var clockwise2 = beta < gamma;
			var dif3 = clockwise2 ? theta2 : -theta2;
			dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
			break;
		case 3:
			var f6;
			if(beta >= 0 && beta > Math.PI) {
				f6 = beta;
			} else {
				var a6 = beta % (2 * Math.PI);
				f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
			}
			var this11 = f6;
			var za3 = this11;
			var f7;
			if(gamma >= 0 && gamma > Math.PI) {
				f7 = gamma;
			} else {
				var a7 = gamma % (2 * Math.PI);
				f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
			}
			var this12 = f7;
			var zb3 = this12;
			var fa3 = beta;
			var fb3 = gamma;
			var theta3 = Math.abs(beta - gamma);
			var largest = theta3 > Math.PI;
			var clockwise3 = beta < gamma;
			var dif4 = clockwise3 ? theta3 : -theta3;
			dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step1 = dif / totalSteps;
		var angle = beta;
		var cx;
		var cy;
		var bx = 0;
		var by = 0;
		var _g = 0;
		var _g1 = totalSteps + 1;
		while(_g < _g1) {
			var i = _g++;
			cx = ax + radius * Math.sin(angle);
			cy = ay + radius * Math.cos(angle);
			if(i != 0) {
				var t2 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
				out[out.length] = t2;
				if(mark != 0) {
					t2.mark = mark;
				}
			}
			angle += step1;
			bx = cx;
			by = cy;
		}
		var triArr = out;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t3 = triArr[_g2];
			++_g2;
			this1[this1.length] = t3;
		}
	}
	,computeJ: function(width_,theta0,dif) {
		var gamma = Math.abs(dif) / 2;
		var h = width_ / 2 / Math.cos(gamma);
		var f;
		if(theta0 <= Math.PI && theta0 > -Math.PI) {
			f = theta0;
		} else {
			var a = (theta0 + Math.PI) % (2 * Math.PI);
			f = a >= 0 ? a - Math.PI : a + Math.PI;
		}
		var this1 = f;
		var start = this1;
		var start2 = start;
		var delta = start2 + dif / 2 + Math.PI;
		this.jx = this.ax + h * Math.sin(delta);
		this.jy = this.ay + h * Math.cos(delta);
	}
	,addDot: function(x,y,color,width_) {
		var w = width_ * 0.07;
		var t = [];
		var this1;
		if(t == null) {
			var t1 = [];
			var this2 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this1 = this2;
		} else {
			this1 = t;
		}
		var this3 = this1;
		var out = this3;
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx;
		var by;
		var cx;
		var cy;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = x + w * Math.sin(theta);
			by = y + w * Math.cos(theta);
			theta += step;
			cx = x + w * Math.sin(theta);
			cy = y + w * Math.cos(theta);
			var t2 = new trilateral_tri_Trilateral(x,y,bx,by,cx,cy);
			out[out.length] = t2;
			t2.mark = color;
		}
		var trilateralArray = out;
		var this4 = this.triArr;
		var _g2 = 0;
		while(_g2 < trilateralArray.length) {
			var t3 = trilateralArray[_g2];
			++_g2;
			this4[this4.length] = t3;
		}
	}
	,addSmallTriangles: function(clockWise,width_) {
		if(clockWise) {
			var this1 = this.triArr;
			var tri = new trilateral_tri_Trilateral(this.ax,this.ay,this.dxOld,this.dyOld,this.jx,this.jy,0);
			this1[this1.length] = tri;
			var this2 = this.triArr;
			var tri1 = new trilateral_tri_Trilateral(this.ax,this.ay,this.exPrev,this.eyPrev,this.jx,this.jy,0);
			this2[this2.length] = tri1;
		} else {
			var this3 = this.triArr;
			var tri2 = new trilateral_tri_Trilateral(this.ax,this.ay,this.exOld,this.eyOld,this.jx,this.jy,0);
			this3[this3.length] = tri2;
			var this4 = this.triArr;
			var tri3 = new trilateral_tri_Trilateral(this.ax,this.ay,this.dxPrev,this.dyPrev,this.jx,this.jy,0);
			this4[this4.length] = tri3;
		}
	}
	,addTriangleCorners: function(oldx_,oldy_,prevx_,prevy_,width_) {
		var w = width_ * 0.07;
		var t = [];
		var this1;
		if(t == null) {
			var t1 = [];
			var this2 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this1 = this2;
		} else {
			this1 = t;
		}
		var this3 = this1;
		var out = this3;
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx;
		var by;
		var cx;
		var cy;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = oldx_ + w * Math.sin(theta);
			by = oldy_ + w * Math.cos(theta);
			theta += step;
			cx = oldx_ + w * Math.sin(theta);
			cy = oldy_ + w * Math.cos(theta);
			var t2 = new trilateral_tri_Trilateral(oldx_,oldy_,bx,by,cx,cy);
			out[out.length] = t2;
			t2.mark = 4;
		}
		var trilateralArray = out;
		var this4 = this.triArr;
		var _g2 = 0;
		while(_g2 < trilateralArray.length) {
			var t3 = trilateralArray[_g2];
			++_g2;
			this4[this4.length] = t3;
		}
		var t4 = [];
		var this5;
		if(t4 == null) {
			var t5 = [];
			var this6 = t5 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t5;
			this5 = this6;
		} else {
			this5 = t4;
		}
		var this7 = this5;
		var out1 = this7;
		var pi1 = Math.PI;
		var theta1 = pi1 / 2;
		var step1 = pi1 * 2 / 36;
		var bx1;
		var by1;
		var cx1;
		var cy1;
		var _g3 = 0;
		var _g11 = 36;
		while(_g3 < _g11) {
			var i1 = _g3++;
			bx1 = prevx_ + w * Math.sin(theta1);
			by1 = prevy_ + w * Math.cos(theta1);
			theta1 += step1;
			cx1 = prevx_ + w * Math.sin(theta1);
			cy1 = prevy_ + w * Math.cos(theta1);
			var t6 = new trilateral_tri_Trilateral(prevx_,prevy_,bx1,by1,cx1,cy1);
			out1[out1.length] = t6;
			t6.mark = 3;
		}
		var trilateralArray1 = out1;
		var this8 = this.triArr;
		var _g4 = 0;
		while(_g4 < trilateralArray1.length) {
			var t7 = trilateralArray1[_g4];
			++_g4;
			this8[this8.length] = t7;
		}
		var ax = this.ax;
		var ay = this.ay;
		var t8 = [];
		var this9;
		if(t8 == null) {
			var t9 = [];
			var this10 = t9 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t9;
			this9 = this10;
		} else {
			this9 = t8;
		}
		var this11 = this9;
		var out2 = this11;
		var pi2 = Math.PI;
		var theta2 = pi2 / 2;
		var step2 = pi2 * 2 / 36;
		var bx2;
		var by2;
		var cx2;
		var cy2;
		var _g5 = 0;
		var _g12 = 36;
		while(_g5 < _g12) {
			var i2 = _g5++;
			bx2 = ax + w * Math.sin(theta2);
			by2 = ay + w * Math.cos(theta2);
			theta2 += step2;
			cx2 = ax + w * Math.sin(theta2);
			cy2 = ay + w * Math.cos(theta2);
			var t10 = new trilateral_tri_Trilateral(ax,ay,bx2,by2,cx2,cy2);
			out2[out2.length] = t10;
			t10.mark = 10;
		}
		var trilateralArray2 = out2;
		var this12 = this.triArr;
		var _g6 = 0;
		while(_g6 < trilateralArray2.length) {
			var t11 = trilateralArray2[_g6];
			++_g6;
			this12[this12.length] = t11;
		}
		var ax1 = this.jx;
		var ay1 = this.jy;
		var t12 = [];
		var this13;
		if(t12 == null) {
			var t13 = [];
			var this14 = t13 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t13;
			this13 = this14;
		} else {
			this13 = t12;
		}
		var this15 = this13;
		var out3 = this15;
		var pi3 = Math.PI;
		var theta3 = pi3 / 2;
		var step3 = pi3 * 2 / 36;
		var bx3;
		var by3;
		var cx3;
		var cy3;
		var _g7 = 0;
		var _g13 = 36;
		while(_g7 < _g13) {
			var i3 = _g7++;
			bx3 = ax1 + w * Math.sin(theta3);
			by3 = ay1 + w * Math.cos(theta3);
			theta3 += step3;
			cx3 = ax1 + w * Math.sin(theta3);
			cy3 = ay1 + w * Math.cos(theta3);
			var t14 = new trilateral_tri_Trilateral(ax1,ay1,bx3,by3,cx3,cy3);
			out3[out3.length] = t14;
			t14.mark = 5;
		}
		var trilateralArray3 = out3;
		var this16 = this.triArr;
		var _g8 = 0;
		while(_g8 < trilateralArray3.length) {
			var t15 = trilateralArray3[_g8];
			++_g8;
			this16[this16.length] = t15;
		}
	}
	,addTriangleCornersLess: function(oldx_,oldy_,prevx_,prevy_,width_) {
		var w = width_ * 0.07;
		var t = [];
		var this1;
		if(t == null) {
			var t1 = [];
			var this2 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this1 = this2;
		} else {
			this1 = t;
		}
		var this3 = this1;
		var out = this3;
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx;
		var by;
		var cx;
		var cy;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = oldx_ + w * Math.sin(theta);
			by = oldy_ + w * Math.cos(theta);
			theta += step;
			cx = oldx_ + w * Math.sin(theta);
			cy = oldy_ + w * Math.cos(theta);
			var t2 = new trilateral_tri_Trilateral(oldx_,oldy_,bx,by,cx,cy);
			out[out.length] = t2;
			t2.mark = 4;
		}
		var trilateralArray = out;
		var this4 = this.triArr;
		var _g2 = 0;
		while(_g2 < trilateralArray.length) {
			var t3 = trilateralArray[_g2];
			++_g2;
			this4[this4.length] = t3;
		}
		var t4 = [];
		var this5;
		if(t4 == null) {
			var t5 = [];
			var this6 = t5 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t5;
			this5 = this6;
		} else {
			this5 = t4;
		}
		var this7 = this5;
		var out1 = this7;
		var pi1 = Math.PI;
		var theta1 = pi1 / 2;
		var step1 = pi1 * 2 / 36;
		var bx1;
		var by1;
		var cx1;
		var cy1;
		var _g3 = 0;
		var _g11 = 36;
		while(_g3 < _g11) {
			var i1 = _g3++;
			bx1 = prevx_ + w * Math.sin(theta1);
			by1 = prevy_ + w * Math.cos(theta1);
			theta1 += step1;
			cx1 = prevx_ + w * Math.sin(theta1);
			cy1 = prevy_ + w * Math.cos(theta1);
			var t6 = new trilateral_tri_Trilateral(prevx_,prevy_,bx1,by1,cx1,cy1);
			out1[out1.length] = t6;
			t6.mark = 3;
		}
		var trilateralArray1 = out1;
		var this8 = this.triArr;
		var _g4 = 0;
		while(_g4 < trilateralArray1.length) {
			var t7 = trilateralArray1[_g4];
			++_g4;
			this8[this8.length] = t7;
		}
		var ax = this.jx;
		var ay = this.jy;
		var t8 = [];
		var this9;
		if(t8 == null) {
			var t9 = [];
			var this10 = t9 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t9;
			this9 = this10;
		} else {
			this9 = t8;
		}
		var this11 = this9;
		var out2 = this11;
		var pi2 = Math.PI;
		var theta2 = pi2 / 2;
		var step2 = pi2 * 2 / 36;
		var bx2;
		var by2;
		var cx2;
		var cy2;
		var _g5 = 0;
		var _g12 = 36;
		while(_g5 < _g12) {
			var i2 = _g5++;
			bx2 = ax + w * Math.sin(theta2);
			by2 = ay + w * Math.cos(theta2);
			theta2 += step2;
			cx2 = ax + w * Math.sin(theta2);
			cy2 = ay + w * Math.cos(theta2);
			var t10 = new trilateral_tri_Trilateral(ax,ay,bx2,by2,cx2,cy2);
			out2[out2.length] = t10;
			t10.mark = 5;
		}
		var trilateralArray2 = out2;
		var this12 = this.triArr;
		var _g6 = 0;
		while(_g6 < trilateralArray2.length) {
			var t11 = trilateralArray2[_g6];
			++_g6;
			this12[this12.length] = t11;
		}
	}
	,connectQuadsWhenQuadsOverlay: function(clockWise,width_) {
		if(clockWise) {
			var this1 = this.triArr;
			var tri = new trilateral_tri_Trilateral(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.ax,this.ay,0);
			this1[this1.length] = tri;
		} else {
			var this2 = this.triArr;
			var tri1 = new trilateral_tri_Trilateral(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.ax,this.ay,0);
			this2[this2.length] = tri1;
		}
	}
	,connectQuads: function(clockWise,width_) {
		if(clockWise) {
			var this1 = this.triArr;
			var tri = new trilateral_tri_Trilateral(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.jx,this.jy,0);
			this1[this1.length] = tri;
		} else {
			var this2 = this.triArr;
			var tri1 = new trilateral_tri_Trilateral(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.jx,this.jy,0);
			this2[this2.length] = tri1;
		}
	}
	,addInitialQuads: function(clockWise,width_) {
		this.quadIndex = this.triArr.length;
		if(this.count == 0) {
			this.penultimateAX = this.dxPrev;
			this.penultimateAY = this.dyPrev;
			this.lastAntiX = this.ex;
			this.lastAntiY = this.ey;
			this.penultimateCX = this.dx;
			this.penultimateCY = this.dy;
			this.lastClockX = this.exPrev;
			this.lastClockY = this.eyPrev;
			var this1 = this.triArr;
			var tri = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,0);
			this1[this1.length] = tri;
			var this2 = this.triArr;
			var tri1 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,0);
			this2[this2.length] = tri1;
		} else {
			if(clockWise && !this.lastClock) {
				this.penultimateAX = this.jx;
				this.penultimateAY = this.jy;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.penultimateCX = this.dx;
				this.penultimateCY = this.dy;
				this.lastClockX = this.exPrev;
				this.lastClockY = this.eyPrev;
				var this3 = this.triArr;
				var tri2 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,0);
				this3[this3.length] = tri2;
				var this4 = this.triArr;
				var tri3 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,0);
				this4[this4.length] = tri3;
			}
			if(clockWise && this.lastClock) {
				this.penultimateAX = this.jx;
				this.penultimateAY = this.jy;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.penultimateCX = this.dx;
				this.penultimateCY = this.dy;
				this.lastClockX = this.exPrev;
				this.lastClockY = this.eyPrev;
				var this5 = this.triArr;
				var tri4 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,0);
				this5[this5.length] = tri4;
				var this6 = this.triArr;
				var tri5 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,0);
				this6[this6.length] = tri5;
			}
			if(!clockWise && !this.lastClock) {
				this.penultimateCX = this.dx;
				this.penultimateCY = this.dy;
				this.lastClockX = this.jx;
				this.lastClockY = this.jy;
				this.penultimateAX = this.dxPrev;
				this.penultimateAY = this.dyPrev;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				var this7 = this.triArr;
				var tri6 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.jx,this.jy,0);
				this7[this7.length] = tri6;
				var this8 = this.triArr;
				var tri7 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,0);
				this8[this8.length] = tri7;
			}
			if(!clockWise && this.lastClock) {
				this.penultimateAX = this.dxPrev;
				this.penultimateAY = this.dyPrev;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.penultimateCX = this.jx;
				this.penultimateCY = this.jy;
				this.lastClockX = this.dx;
				this.lastClockY = this.dy;
				var this9 = this.triArr;
				var tri8 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,0);
				this9[this9.length] = tri8;
				var this10 = this.triArr;
				var tri9 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.jx,this.jy,this.ex,this.ey,0);
				this10[this10.length] = tri9;
			}
		}
	}
	,endEdges: function() {
		var pC = this.pointsClock.length;
		var pA = this.pointsAnti.length;
		this.pointsClock[pC++] = this.penultimateCX;
		this.pointsClock[pC++] = this.penultimateCY;
		this.pointsClock[pC++] = this.lastClockX;
		this.pointsClock[pC++] = this.lastClockY;
		this.pointsAnti[pA++] = this.penultimateAX;
		this.pointsAnti[pA++] = this.penultimateAY;
		this.pointsAnti[pA++] = this.lastAntiX;
		this.pointsAnti[pA++] = this.lastAntiY;
	}
	,addQuads: function(clockWise,width_) {
		var pC = 0;
		var pA = 0;
		if(clockWise && !this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.kax,this.kay,this.kbx,this.kby,this.ncx,this.ncy);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.kax,this.kay,this.kbx,this.kby,this.jxOld,this.jyOld);
			}
			this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.kax,this.kay,this.kbx,this.kby,this.jx,this.jy);
		}
		if(clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				this.pointsAnti[pA++] = this.kbx;
				this.pointsAnti[pA++] = this.kby;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kax;
				this.pointsClock[pC++] = this.kay;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.kax,this.kay,this.kbx,this.kby,this.jx,this.jy);
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.kax,this.kay,this.kbx,this.kby,this.ncx,this.ncy);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.jxOld,this.jyOld,this.kbx,this.kby,this.jx,this.jy);
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.jxOld,this.jyOld,this.kbx,this.kby,this.ncx,this.ncy);
			}
		}
		if(!clockWise && !this.lastClock) {
			this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.kax,this.kay,this.jx,this.jy,this.kcx,this.kcy);
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.kax,this.kay,this.jx,this.jy,this.ncx,this.ncy);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.kax,this.kay,this.jx,this.jy,this.jxOld,this.jyOld);
			}
		}
		if(!clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.kax,this.kay,this.jx,this.jy,this.kcx,this.kcy);
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.kax,this.kay,this.jx,this.jy,this.ncx,this.ncy);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.jxOld,this.jyOld,this.jx,this.jy,this.kcx,this.kcy);
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.jxOld,this.jyOld,this.jx,this.jy,this.ncx,this.ncy);
			}
		}
	}
	,storeLastQuads: function() {
		this.kax = this.dxPrev;
		this.kay = this.dyPrev;
		this.kbx = this.dx;
		this.kby = this.dy;
		this.ncx = this.exPrev;
		this.ncy = this.eyPrev;
		this.kcx = this.ex;
		this.kcy = this.ey;
	}
	,isClockwise: function(x,y) {
		var x1 = this.dxOld - x;
		var y1 = this.dyOld - y;
		var x2 = this.exOld - x;
		var y2 = this.eyOld - y;
		return x1 * x1 + y1 * y1 > x2 * x2 + y2 * y2;
	}
	,line: function(ax_,ay_,bx_,by_,width_,endLineCurve) {
		if(endLineCurve == null) {
			endLineCurve = 0;
		}
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.halfA = Math.PI / 2;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var dxPrev_ = this.dx;
		var dyPrev_ = this.dy;
		var exPrev_ = this.ex;
		var eyPrev_ = this.ey;
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		switch(endLineCurve) {
		case 0:
			break;
		case 1:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var this1 = this.triArr;
			var t = [];
			var this2;
			if(t == null) {
				var t1 = [];
				var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
				this2 = this3;
			} else {
				this2 = t;
			}
			var this4 = this2;
			var out = this4;
			var pi = Math.PI;
			var step = pi * 2 / 36;
			var dif;
			switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this5 = f;
				var za = this5;
				var f1;
				if(gamma >= 0 && gamma > Math.PI) {
					f1 = gamma;
				} else {
					var a1 = gamma % (2 * Math.PI);
					f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
				}
				var this6 = f1;
				var zb = this6;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(beta - gamma);
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f2;
				if(beta >= 0 && beta > Math.PI) {
					f2 = beta;
				} else {
					var a2 = beta % (2 * Math.PI);
					f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
				}
				var this7 = f2;
				var za1 = this7;
				var f3;
				if(gamma >= 0 && gamma > Math.PI) {
					f3 = gamma;
				} else {
					var a3 = gamma % (2 * Math.PI);
					f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
				}
				var this8 = f3;
				var zb1 = this8;
				var fa1 = za1;
				var fb1 = zb1;
				var theta1 = Math.abs(beta - gamma);
				var clockwise1 = beta < gamma;
				var dif2 = clockwise1 ? theta1 : -theta1;
				dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
				break;
			case 2:
				var f4;
				if(beta >= 0 && beta > Math.PI) {
					f4 = beta;
				} else {
					var a4 = beta % (2 * Math.PI);
					f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
				}
				var this9 = f4;
				var za2 = this9;
				var f5;
				if(gamma >= 0 && gamma > Math.PI) {
					f5 = gamma;
				} else {
					var a5 = gamma % (2 * Math.PI);
					f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
				}
				var this10 = f5;
				var zb2 = this10;
				var fa2 = beta;
				var fb2 = gamma;
				var theta2 = Math.abs(beta - gamma);
				var smallest = theta2 <= Math.PI;
				var clockwise2 = beta < gamma;
				var dif3 = clockwise2 ? theta2 : -theta2;
				dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
				break;
			case 3:
				var f6;
				if(beta >= 0 && beta > Math.PI) {
					f6 = beta;
				} else {
					var a6 = beta % (2 * Math.PI);
					f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
				}
				var this11 = f6;
				var za3 = this11;
				var f7;
				if(gamma >= 0 && gamma > Math.PI) {
					f7 = gamma;
				} else {
					var a7 = gamma % (2 * Math.PI);
					f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
				}
				var this12 = f7;
				var zb3 = this12;
				var fa3 = beta;
				var fb3 = gamma;
				var theta3 = Math.abs(beta - gamma);
				var largest = theta3 > Math.PI;
				var clockwise3 = beta < gamma;
				var dif4 = clockwise3 ? theta3 : -theta3;
				dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step1 = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var t2 = new trilateral_tri_Trilateral(ax_,ay_,bx,by,cx,cy);
					out[out.length] = t2;
				}
				angle += step1;
				bx = cx;
				by = cy;
			}
			var triArr = out;
			var _g2 = 0;
			while(_g2 < triArr.length) {
				var t3 = triArr[_g2];
				++_g2;
				this1[this1.length] = t3;
			}
			break;
		case 2:
			var radius1 = width_ / 2;
			var beta1 = -this.angle1 - Math.PI / 2;
			var gamma1 = -this.angle1 - Math.PI / 2 - Math.PI;
			var this13 = this.triArr;
			var t4 = [];
			var this14;
			if(t4 == null) {
				var t5 = [];
				var this15 = t5 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t5;
				this14 = this15;
			} else {
				this14 = t4;
			}
			var this16 = this14;
			var out1 = this16;
			var pi1 = Math.PI;
			var step2 = pi1 * 2 / 36;
			var dif5;
			switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f8;
				if(beta1 >= 0 && beta1 > Math.PI) {
					f8 = beta1;
				} else {
					var a8 = beta1 % (2 * Math.PI);
					f8 = a8 >= 0 ? a8 : a8 + 2 * Math.PI;
				}
				var this17 = f8;
				var za4 = this17;
				var f9;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f9 = gamma1;
				} else {
					var a9 = gamma1 % (2 * Math.PI);
					f9 = a9 >= 0 ? a9 : a9 + 2 * Math.PI;
				}
				var this18 = f9;
				var zb4 = this18;
				var fa4 = za4;
				var fb4 = zb4;
				var theta4 = Math.abs(beta1 - gamma1);
				var clockwise4 = beta1 < gamma1;
				var dif6 = clockwise4 ? theta4 : -theta4;
				dif5 = dif6 > 0 ? dif6 : 2 * Math.PI + dif6;
				break;
			case 1:
				var f10;
				if(beta1 >= 0 && beta1 > Math.PI) {
					f10 = beta1;
				} else {
					var a10 = beta1 % (2 * Math.PI);
					f10 = a10 >= 0 ? a10 : a10 + 2 * Math.PI;
				}
				var this19 = f10;
				var za5 = this19;
				var f11;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f11 = gamma1;
				} else {
					var a11 = gamma1 % (2 * Math.PI);
					f11 = a11 >= 0 ? a11 : a11 + 2 * Math.PI;
				}
				var this20 = f11;
				var zb5 = this20;
				var fa5 = za5;
				var fb5 = zb5;
				var theta5 = Math.abs(beta1 - gamma1);
				var clockwise5 = beta1 < gamma1;
				var dif7 = clockwise5 ? theta5 : -theta5;
				dif5 = dif7 < 0 ? dif7 : -2 * Math.PI + dif7;
				break;
			case 2:
				var f12;
				if(beta1 >= 0 && beta1 > Math.PI) {
					f12 = beta1;
				} else {
					var a12 = beta1 % (2 * Math.PI);
					f12 = a12 >= 0 ? a12 : a12 + 2 * Math.PI;
				}
				var this21 = f12;
				var za6 = this21;
				var f13;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f13 = gamma1;
				} else {
					var a13 = gamma1 % (2 * Math.PI);
					f13 = a13 >= 0 ? a13 : a13 + 2 * Math.PI;
				}
				var this22 = f13;
				var zb6 = this22;
				var fa6 = beta1;
				var fb6 = gamma1;
				var theta6 = Math.abs(beta1 - gamma1);
				var smallest1 = theta6 <= Math.PI;
				var clockwise6 = beta1 < gamma1;
				var dif8 = clockwise6 ? theta6 : -theta6;
				dif5 = smallest1 ? dif8 : clockwise6 ? -(2 * Math.PI - theta6) : 2 * Math.PI - theta6;
				break;
			case 3:
				var f14;
				if(beta1 >= 0 && beta1 > Math.PI) {
					f14 = beta1;
				} else {
					var a14 = beta1 % (2 * Math.PI);
					f14 = a14 >= 0 ? a14 : a14 + 2 * Math.PI;
				}
				var this23 = f14;
				var za7 = this23;
				var f15;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f15 = gamma1;
				} else {
					var a15 = gamma1 % (2 * Math.PI);
					f15 = a15 >= 0 ? a15 : a15 + 2 * Math.PI;
				}
				var this24 = f15;
				var zb7 = this24;
				var fa7 = beta1;
				var fb7 = gamma1;
				var theta7 = Math.abs(beta1 - gamma1);
				var largest1 = theta7 > Math.PI;
				var clockwise7 = beta1 < gamma1;
				var dif9 = clockwise7 ? theta7 : -theta7;
				dif5 = largest1 ? dif9 : clockwise7 ? -(2 * Math.PI - theta7) : 2 * Math.PI - theta7;
				break;
			}
			var positive1 = dif5 >= 0;
			var totalSteps1 = Math.ceil(Math.abs(dif5) / step2);
			var step3 = dif5 / totalSteps1;
			var angle1 = beta1;
			var cx1;
			var cy1;
			var bx1 = 0;
			var by1 = 0;
			var _g3 = 0;
			var _g11 = totalSteps1 + 1;
			while(_g3 < _g11) {
				var i1 = _g3++;
				cx1 = bx_ + radius1 * Math.sin(angle1);
				cy1 = by_ + radius1 * Math.cos(angle1);
				if(i1 != 0) {
					var t6 = new trilateral_tri_Trilateral(bx_,by_,bx1,by1,cx1,cy1);
					out1[out1.length] = t6;
				}
				angle1 += step3;
				bx1 = cx1;
				by1 = cy1;
			}
			var triArr1 = out1;
			var _g4 = 0;
			while(_g4 < triArr1.length) {
				var t7 = triArr1[_g4];
				++_g4;
				this13[this13.length] = t7;
			}
			break;
		case 3:
			var radius2 = width_ / 2;
			var beta2 = -this.angle1 - Math.PI / 2;
			var gamma2 = -this.angle1 - Math.PI / 2 + Math.PI;
			var this25 = this.triArr;
			var t8 = [];
			var this26;
			if(t8 == null) {
				var t9 = [];
				var this27 = t9 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t9;
				this26 = this27;
			} else {
				this26 = t8;
			}
			var this28 = this26;
			var out2 = this28;
			var pi2 = Math.PI;
			var step4 = pi2 * 2 / 36;
			var dif10;
			switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f16;
				if(beta2 >= 0 && beta2 > Math.PI) {
					f16 = beta2;
				} else {
					var a16 = beta2 % (2 * Math.PI);
					f16 = a16 >= 0 ? a16 : a16 + 2 * Math.PI;
				}
				var this29 = f16;
				var za8 = this29;
				var f17;
				if(gamma2 >= 0 && gamma2 > Math.PI) {
					f17 = gamma2;
				} else {
					var a17 = gamma2 % (2 * Math.PI);
					f17 = a17 >= 0 ? a17 : a17 + 2 * Math.PI;
				}
				var this30 = f17;
				var zb8 = this30;
				var fa8 = za8;
				var fb8 = zb8;
				var theta8 = Math.abs(beta2 - gamma2);
				var clockwise8 = beta2 < gamma2;
				var dif11 = clockwise8 ? theta8 : -theta8;
				dif10 = dif11 > 0 ? dif11 : 2 * Math.PI + dif11;
				break;
			case 1:
				var f18;
				if(beta2 >= 0 && beta2 > Math.PI) {
					f18 = beta2;
				} else {
					var a18 = beta2 % (2 * Math.PI);
					f18 = a18 >= 0 ? a18 : a18 + 2 * Math.PI;
				}
				var this31 = f18;
				var za9 = this31;
				var f19;
				if(gamma2 >= 0 && gamma2 > Math.PI) {
					f19 = gamma2;
				} else {
					var a19 = gamma2 % (2 * Math.PI);
					f19 = a19 >= 0 ? a19 : a19 + 2 * Math.PI;
				}
				var this32 = f19;
				var zb9 = this32;
				var fa9 = za9;
				var fb9 = zb9;
				var theta9 = Math.abs(beta2 - gamma2);
				var clockwise9 = beta2 < gamma2;
				var dif12 = clockwise9 ? theta9 : -theta9;
				dif10 = dif12 < 0 ? dif12 : -2 * Math.PI + dif12;
				break;
			case 2:
				var f20;
				if(beta2 >= 0 && beta2 > Math.PI) {
					f20 = beta2;
				} else {
					var a20 = beta2 % (2 * Math.PI);
					f20 = a20 >= 0 ? a20 : a20 + 2 * Math.PI;
				}
				var this33 = f20;
				var za10 = this33;
				var f21;
				if(gamma2 >= 0 && gamma2 > Math.PI) {
					f21 = gamma2;
				} else {
					var a21 = gamma2 % (2 * Math.PI);
					f21 = a21 >= 0 ? a21 : a21 + 2 * Math.PI;
				}
				var this34 = f21;
				var zb10 = this34;
				var fa10 = beta2;
				var fb10 = gamma2;
				var theta10 = Math.abs(beta2 - gamma2);
				var smallest2 = theta10 <= Math.PI;
				var clockwise10 = beta2 < gamma2;
				var dif13 = clockwise10 ? theta10 : -theta10;
				dif10 = smallest2 ? dif13 : clockwise10 ? -(2 * Math.PI - theta10) : 2 * Math.PI - theta10;
				break;
			case 3:
				var f22;
				if(beta2 >= 0 && beta2 > Math.PI) {
					f22 = beta2;
				} else {
					var a22 = beta2 % (2 * Math.PI);
					f22 = a22 >= 0 ? a22 : a22 + 2 * Math.PI;
				}
				var this35 = f22;
				var za11 = this35;
				var f23;
				if(gamma2 >= 0 && gamma2 > Math.PI) {
					f23 = gamma2;
				} else {
					var a23 = gamma2 % (2 * Math.PI);
					f23 = a23 >= 0 ? a23 : a23 + 2 * Math.PI;
				}
				var this36 = f23;
				var zb11 = this36;
				var fa11 = beta2;
				var fb11 = gamma2;
				var theta11 = Math.abs(beta2 - gamma2);
				var largest2 = theta11 > Math.PI;
				var clockwise11 = beta2 < gamma2;
				var dif14 = clockwise11 ? theta11 : -theta11;
				dif10 = largest2 ? dif14 : clockwise11 ? -(2 * Math.PI - theta11) : 2 * Math.PI - theta11;
				break;
			}
			var positive2 = dif10 >= 0;
			var totalSteps2 = Math.ceil(Math.abs(dif10) / step4);
			var step5 = dif10 / totalSteps2;
			var angle2 = beta2;
			var cx2;
			var cy2;
			var bx2 = 0;
			var by2 = 0;
			var _g5 = 0;
			var _g12 = totalSteps2 + 1;
			while(_g5 < _g12) {
				var i2 = _g5++;
				cx2 = ax_ + radius2 * Math.sin(angle2);
				cy2 = ay_ + radius2 * Math.cos(angle2);
				if(i2 != 0) {
					var t10 = new trilateral_tri_Trilateral(ax_,ay_,bx2,by2,cx2,cy2);
					out2[out2.length] = t10;
				}
				angle2 += step5;
				bx2 = cx2;
				by2 = cy2;
			}
			var triArr2 = out2;
			var _g6 = 0;
			while(_g6 < triArr2.length) {
				var t11 = triArr2[_g6];
				++_g6;
				this25[this25.length] = t11;
			}
			var radius3 = width_ / 2;
			var beta3 = -this.angle1 - Math.PI / 2;
			var gamma3 = -this.angle1 - Math.PI / 2 - Math.PI;
			var this37 = this.triArr;
			var t12 = [];
			var this38;
			if(t12 == null) {
				var t13 = [];
				var this39 = t13 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t13;
				this38 = this39;
			} else {
				this38 = t12;
			}
			var this40 = this38;
			var out3 = this40;
			var pi3 = Math.PI;
			var step6 = pi3 * 2 / 36;
			var dif15;
			switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f24;
				if(beta3 >= 0 && beta3 > Math.PI) {
					f24 = beta3;
				} else {
					var a24 = beta3 % (2 * Math.PI);
					f24 = a24 >= 0 ? a24 : a24 + 2 * Math.PI;
				}
				var this41 = f24;
				var za12 = this41;
				var f25;
				if(gamma3 >= 0 && gamma3 > Math.PI) {
					f25 = gamma3;
				} else {
					var a25 = gamma3 % (2 * Math.PI);
					f25 = a25 >= 0 ? a25 : a25 + 2 * Math.PI;
				}
				var this42 = f25;
				var zb12 = this42;
				var fa12 = za12;
				var fb12 = zb12;
				var theta12 = Math.abs(beta3 - gamma3);
				var clockwise12 = beta3 < gamma3;
				var dif16 = clockwise12 ? theta12 : -theta12;
				dif15 = dif16 > 0 ? dif16 : 2 * Math.PI + dif16;
				break;
			case 1:
				var f26;
				if(beta3 >= 0 && beta3 > Math.PI) {
					f26 = beta3;
				} else {
					var a26 = beta3 % (2 * Math.PI);
					f26 = a26 >= 0 ? a26 : a26 + 2 * Math.PI;
				}
				var this43 = f26;
				var za13 = this43;
				var f27;
				if(gamma3 >= 0 && gamma3 > Math.PI) {
					f27 = gamma3;
				} else {
					var a27 = gamma3 % (2 * Math.PI);
					f27 = a27 >= 0 ? a27 : a27 + 2 * Math.PI;
				}
				var this44 = f27;
				var zb13 = this44;
				var fa13 = za13;
				var fb13 = zb13;
				var theta13 = Math.abs(beta3 - gamma3);
				var clockwise13 = beta3 < gamma3;
				var dif17 = clockwise13 ? theta13 : -theta13;
				dif15 = dif17 < 0 ? dif17 : -2 * Math.PI + dif17;
				break;
			case 2:
				var f28;
				if(beta3 >= 0 && beta3 > Math.PI) {
					f28 = beta3;
				} else {
					var a28 = beta3 % (2 * Math.PI);
					f28 = a28 >= 0 ? a28 : a28 + 2 * Math.PI;
				}
				var this45 = f28;
				var za14 = this45;
				var f29;
				if(gamma3 >= 0 && gamma3 > Math.PI) {
					f29 = gamma3;
				} else {
					var a29 = gamma3 % (2 * Math.PI);
					f29 = a29 >= 0 ? a29 : a29 + 2 * Math.PI;
				}
				var this46 = f29;
				var zb14 = this46;
				var fa14 = beta3;
				var fb14 = gamma3;
				var theta14 = Math.abs(beta3 - gamma3);
				var smallest3 = theta14 <= Math.PI;
				var clockwise14 = beta3 < gamma3;
				var dif18 = clockwise14 ? theta14 : -theta14;
				dif15 = smallest3 ? dif18 : clockwise14 ? -(2 * Math.PI - theta14) : 2 * Math.PI - theta14;
				break;
			case 3:
				var f30;
				if(beta3 >= 0 && beta3 > Math.PI) {
					f30 = beta3;
				} else {
					var a30 = beta3 % (2 * Math.PI);
					f30 = a30 >= 0 ? a30 : a30 + 2 * Math.PI;
				}
				var this47 = f30;
				var za15 = this47;
				var f31;
				if(gamma3 >= 0 && gamma3 > Math.PI) {
					f31 = gamma3;
				} else {
					var a31 = gamma3 % (2 * Math.PI);
					f31 = a31 >= 0 ? a31 : a31 + 2 * Math.PI;
				}
				var this48 = f31;
				var zb15 = this48;
				var fa15 = beta3;
				var fb15 = gamma3;
				var theta15 = Math.abs(beta3 - gamma3);
				var largest3 = theta15 > Math.PI;
				var clockwise15 = beta3 < gamma3;
				var dif19 = clockwise15 ? theta15 : -theta15;
				dif15 = largest3 ? dif19 : clockwise15 ? -(2 * Math.PI - theta15) : 2 * Math.PI - theta15;
				break;
			}
			var positive3 = dif15 >= 0;
			var totalSteps3 = Math.ceil(Math.abs(dif15) / step6);
			var step7 = dif15 / totalSteps3;
			var angle3 = beta3;
			var cx3;
			var cy3;
			var bx3 = 0;
			var by3 = 0;
			var _g7 = 0;
			var _g13 = totalSteps3 + 1;
			while(_g7 < _g13) {
				var i3 = _g7++;
				cx3 = bx_ + radius3 * Math.sin(angle3);
				cy3 = by_ + radius3 * Math.cos(angle3);
				if(i3 != 0) {
					var t14 = new trilateral_tri_Trilateral(bx_,by_,bx3,by3,cx3,cy3);
					out3[out3.length] = t14;
				}
				angle3 += step7;
				bx3 = cx3;
				by3 = cy3;
			}
			var triArr3 = out3;
			var _g8 = 0;
			while(_g8 < triArr3.length) {
				var t15 = triArr3[_g8];
				++_g8;
				this37[this37.length] = t15;
			}
			break;
		}
		var this49 = this.triArr;
		var tri = new trilateral_tri_Trilateral(dxPrev_,dyPrev_,this.dx,this.dy,exPrev_,eyPrev_,0);
		this49[this49.length] = tri;
		var this50 = this.triArr;
		var tri1 = new trilateral_tri_Trilateral(dxPrev_,dyPrev_,this.dx,this.dy,this.ex,this.ey,0);
		this50[this50.length] = tri1;
	}
	,computeDE: function() {
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
	}
	,anglesCompute: function() {
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
	}
	,thetaComputeAdj: function(qx,qy) {
		return -Math.atan2(this.ay - qy,this.ax - qx) - Math.PI / 2;
	}
};
var trilateral_justPath_IPathContext = function() { };
trilateral_justPath_IPathContext.__name__ = true;
var trilateral_pairs_Line = function() { };
trilateral_pairs_Line.__name__ = true;
trilateral_pairs_Line.create = function(A,B,width) {
	var dx = A.x - B.x;
	var dy = A.y - B.y;
	var P_x = A.x - width / 2;
	var P_y = A.y;
	var omega = Math.atan2(dy,dx);
	var dim_x = width;
	var dim_y = dx * dx + dy * dy;
	var pivotX = A.x + width / 2;
	var pivotY = A.y;
	var px = P_x;
	var py = P_y;
	var dx1 = dim_x;
	var dy1 = dim_y;
	var A_ = { x : px, y : py};
	var B_ = { x : px + dx1, y : py};
	var C_ = { x : px + dx1, y : py + dy1};
	var D_ = { x : px, y : py + dy1};
	if(omega != 0.) {
		var sin = Math.sin(omega);
		var cos = Math.cos(omega);
		var px1 = A_.x - pivotX;
		var py1 = A_.y - pivotY;
		var px2 = px1 * cos - py1 * sin;
		py1 = py1 * cos + px1 * sin;
		A_ = { x : px2 + pivotX, y : py1 + pivotY};
		var px3 = B_.x - pivotX;
		var py2 = B_.y - pivotY;
		var px21 = px3 * cos - py2 * sin;
		py2 = py2 * cos + px3 * sin;
		B_ = { x : px21 + pivotX, y : py2 + pivotY};
		var px4 = C_.x - pivotX;
		var py3 = C_.y - pivotY;
		var px22 = px4 * cos - py3 * sin;
		py3 = py3 * cos + px4 * sin;
		C_ = { x : px22 + pivotX, y : py3 + pivotY};
		var px5 = D_.x - pivotX;
		var py4 = D_.y - pivotY;
		var px23 = px5 * cos - py4 * sin;
		py4 = py4 * cos + px5 * sin;
		D_ = { x : px23 + pivotX, y : py4 + pivotY};
	}
	var q_A = A_;
	var q_B = B_;
	var q_C = C_;
	var q_D = D_;
	return { t0 : new trilateral_tri_Trilateral(q_A.x,q_A.y,q_B.x,q_B.y,q_D.x,q_D.y), t1 : new trilateral_tri_Trilateral(q_B.x,q_B.y,q_C.x,q_C.y,q_D.x,q_D.y)};
};
trilateral_pairs_Line.fromCoord = function(ax,ay,bx,by,width) {
	var dx = ax - bx;
	var dy = ay - by;
	var P_x = ax - width / 2;
	var P_y = ay;
	var omega = Math.atan2(dy,dx);
	var dim_x = width;
	var dim_y = dx * dx + dy * dy;
	var pivotX = ax + width / 2;
	var px = P_x;
	var py = P_y;
	var dx1 = dim_x;
	var dy1 = dim_y;
	var A_ = { x : px, y : py};
	var B_ = { x : px + dx1, y : py};
	var C_ = { x : px + dx1, y : py + dy1};
	var D_ = { x : px, y : py + dy1};
	if(omega != 0.) {
		var sin = Math.sin(omega);
		var cos = Math.cos(omega);
		var px1 = A_.x - pivotX;
		var py1 = A_.y - ay;
		var px2 = px1 * cos - py1 * sin;
		py1 = py1 * cos + px1 * sin;
		A_ = { x : px2 + pivotX, y : py1 + ay};
		var px3 = B_.x - pivotX;
		var py2 = B_.y - ay;
		var px21 = px3 * cos - py2 * sin;
		py2 = py2 * cos + px3 * sin;
		B_ = { x : px21 + pivotX, y : py2 + ay};
		var px4 = C_.x - pivotX;
		var py3 = C_.y - ay;
		var px22 = px4 * cos - py3 * sin;
		py3 = py3 * cos + px4 * sin;
		C_ = { x : px22 + pivotX, y : py3 + ay};
		var px5 = D_.x - pivotX;
		var py4 = D_.y - ay;
		var px23 = px5 * cos - py4 * sin;
		py4 = py4 * cos + px5 * sin;
		D_ = { x : px23 + pivotX, y : py4 + ay};
	}
	var q_A = A_;
	var q_B = B_;
	var q_C = C_;
	var q_D = D_;
	return { t0 : new trilateral_tri_Trilateral(q_A.x,q_A.y,q_B.x,q_B.y,q_D.x,q_D.y), t1 : new trilateral_tri_Trilateral(q_B.x,q_B.y,q_C.x,q_C.y,q_D.x,q_D.y)};
};
var trilateral_pairs_Quad = function() { };
trilateral_pairs_Quad.__name__ = true;
trilateral_pairs_Quad.rectangle = function(x,y,w,h) {
	var ax = x;
	var ay = y;
	var bx = x + w;
	var by = ay;
	var cx = bx;
	var cy = ay + h;
	var dx = x;
	var dy = cy;
	return { t0 : new trilateral_tri_Trilateral(ax,ay,bx,by,dx,dy), t1 : new trilateral_tri_Trilateral(bx,by,cx,cy,dx,dy)};
};
trilateral_pairs_Quad.squareOutline = function(px,py,radius,thick,theta) {
	if(theta == null) {
		theta = 0;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var ax = 0.;
	var ay = 0.;
	var bx = 0.;
	var by = 0.;
	var cx = 0.;
	var cy = 0.;
	var dx = 0.;
	var dy = 0.;
	var a0x = 0.;
	var a0y = 0.;
	var b0x = 0.;
	var b0y = 0.;
	var c0x = 0.;
	var c0y = 0.;
	var d0x = 0.;
	var d0y = 0.;
	if(theta != 0) {
		var pi = Math.PI;
		var pi4 = pi / 4;
		var pi2 = pi / 2;
		var sqrt2 = Math.sqrt(2);
		var r = radius * sqrt2;
		var aTheta = -pi + theta - pi4;
		var dTheta = -pi + theta + pi / 2 - pi / 4;
		var cTheta = theta - pi4;
		var bTheta = -pi + theta - pi2 - pi4;
		var as = Math.sin(aTheta);
		var ac = Math.cos(aTheta);
		var bs = Math.sin(bTheta);
		var bc = Math.cos(bTheta);
		var cs = Math.sin(cTheta);
		var cc = Math.cos(cTheta);
		var ds = Math.sin(dTheta);
		var dc = Math.cos(dTheta);
		var r0 = r - thick;
		ax = px + r * as;
		ay = py + r * ac;
		bx = px + r * bs;
		by = py + r * bc;
		cx = px + r * cs;
		cy = py + r * cc;
		dx = px + r * ds;
		dy = py + r * dc;
		a0x = px + r0 * as;
		a0y = py + r0 * ac;
		b0x = px + r0 * bs;
		b0y = py + r0 * bc;
		c0x = px + r0 * cs;
		c0y = py + r0 * cc;
		d0x = px + r0 * ds;
		d0y = py + r0 * dc;
	} else {
		ax = px - radius;
		ay = py - radius;
		var lx = radius * 2;
		var ly = lx;
		bx = ax + lx;
		by = ay;
		cx = bx;
		cy = ay + ly;
		dx = ax;
		dy = cy;
		var radius0 = radius - thick;
		a0x = px - radius0;
		a0y = py - radius0;
		var l0x = radius0 * 2;
		var l0y = l0x;
		b0x = a0x + l0x;
		b0y = a0y;
		c0x = b0x;
		c0y = a0y + l0y;
		d0x = a0x;
		d0y = c0y;
	}
	var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,a0x,a0y);
	out[out.length] = tri;
	var tri1 = new trilateral_tri_Trilateral(bx,by,b0x,b0y,a0x,a0y);
	out[out.length] = tri1;
	var tri2 = new trilateral_tri_Trilateral(d0x,d0y,c0x,c0y,dx,dy);
	out[out.length] = tri2;
	var tri3 = new trilateral_tri_Trilateral(c0x,c0y,cx,cy,dx,dy);
	out[out.length] = tri3;
	var tri4 = new trilateral_tri_Trilateral(ax,ay,a0x,a0y,d0x,d0y);
	out[out.length] = tri4;
	var tri5 = new trilateral_tri_Trilateral(ax,ay,d0x,d0y,dx,dy);
	out[out.length] = tri5;
	var tri6 = new trilateral_tri_Trilateral(b0x,b0y,bx,by,c0x,c0y);
	out[out.length] = tri6;
	var tri7 = new trilateral_tri_Trilateral(bx,by,cx,cy,c0x,c0y);
	out[out.length] = tri7;
	return out;
};
trilateral_pairs_Quad.square = function(px,py,radius,theta) {
	if(theta == null) {
		theta = 0;
	}
	var ax = 0.;
	var ay = 0.;
	var bx = 0.;
	var by = 0.;
	var cx = 0.;
	var cy = 0.;
	var dx = 0.;
	var dy = 0.;
	if(theta != 0) {
		var pi = Math.PI;
		var pi4 = pi / 4;
		var pi2 = pi / 2;
		var sqrt2 = Math.sqrt(2);
		var r = radius * sqrt2;
		var aTheta = -pi + theta - pi4;
		var dTheta = -pi + theta + pi / 2 - pi / 4;
		var cTheta = theta - pi4;
		var bTheta = -pi + theta - pi2 - pi4;
		ax = px + r * Math.sin(aTheta);
		ay = py + r * Math.cos(aTheta);
		bx = px + r * Math.sin(bTheta);
		by = py + r * Math.cos(bTheta);
		cx = px + r * Math.sin(cTheta);
		cy = py + r * Math.cos(cTheta);
		dx = px + r * Math.sin(dTheta);
		dy = py + r * Math.cos(dTheta);
	} else {
		ax = px - radius;
		ay = py - radius;
		var lx = radius * 2;
		var ly = lx;
		bx = ax + lx;
		by = ay;
		cx = bx;
		cy = ay + ly;
		dx = ax;
		dy = cy;
	}
	return { t0 : new trilateral_tri_Trilateral(ax,ay,bx,by,dx,dy), t1 : new trilateral_tri_Trilateral(bx,by,cx,cy,dx,dy)};
};
trilateral_pairs_Quad.diamond = function(x,y,radius,theta) {
	if(theta == null) {
		theta = 0;
	}
	var theta1 = Math.PI / 4 + theta;
	var ax = 0.;
	var ay = 0.;
	var bx = 0.;
	var by = 0.;
	var cx = 0.;
	var cy = 0.;
	var dx = 0.;
	var dy = 0.;
	if(theta1 != 0) {
		var pi = Math.PI;
		var pi4 = pi / 4;
		var pi2 = pi / 2;
		var sqrt2 = Math.sqrt(2);
		var r = radius * sqrt2;
		var aTheta = -pi + theta1 - pi4;
		var dTheta = -pi + theta1 + pi / 2 - pi / 4;
		var cTheta = theta1 - pi4;
		var bTheta = -pi + theta1 - pi2 - pi4;
		ax = x + r * Math.sin(aTheta);
		ay = y + r * Math.cos(aTheta);
		bx = x + r * Math.sin(bTheta);
		by = y + r * Math.cos(bTheta);
		cx = x + r * Math.sin(cTheta);
		cy = y + r * Math.cos(cTheta);
		dx = x + r * Math.sin(dTheta);
		dy = y + r * Math.cos(dTheta);
	} else {
		ax = x - radius;
		ay = y - radius;
		var lx = radius * 2;
		var ly = lx;
		bx = ax + lx;
		by = ay;
		cx = bx;
		cy = ay + ly;
		dx = ax;
		dy = cy;
	}
	return { t0 : new trilateral_tri_Trilateral(ax,ay,bx,by,dx,dy), t1 : new trilateral_tri_Trilateral(bx,by,cx,cy,dx,dy)};
};
trilateral_pairs_Quad.diamondOutline = function(x,y,thick,radius,theta) {
	if(theta == null) {
		theta = 0;
	}
	var theta1 = Math.PI / 4 + theta;
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var ax = 0.;
	var ay = 0.;
	var bx = 0.;
	var by = 0.;
	var cx = 0.;
	var cy = 0.;
	var dx = 0.;
	var dy = 0.;
	var a0x = 0.;
	var a0y = 0.;
	var b0x = 0.;
	var b0y = 0.;
	var c0x = 0.;
	var c0y = 0.;
	var d0x = 0.;
	var d0y = 0.;
	if(theta1 != 0) {
		var pi = Math.PI;
		var pi4 = pi / 4;
		var pi2 = pi / 2;
		var sqrt2 = Math.sqrt(2);
		var r = radius * sqrt2;
		var aTheta = -pi + theta1 - pi4;
		var dTheta = -pi + theta1 + pi / 2 - pi / 4;
		var cTheta = theta1 - pi4;
		var bTheta = -pi + theta1 - pi2 - pi4;
		var as = Math.sin(aTheta);
		var ac = Math.cos(aTheta);
		var bs = Math.sin(bTheta);
		var bc = Math.cos(bTheta);
		var cs = Math.sin(cTheta);
		var cc = Math.cos(cTheta);
		var ds = Math.sin(dTheta);
		var dc = Math.cos(dTheta);
		var r0 = r - thick;
		ax = x + r * as;
		ay = y + r * ac;
		bx = x + r * bs;
		by = y + r * bc;
		cx = x + r * cs;
		cy = y + r * cc;
		dx = x + r * ds;
		dy = y + r * dc;
		a0x = x + r0 * as;
		a0y = y + r0 * ac;
		b0x = x + r0 * bs;
		b0y = y + r0 * bc;
		c0x = x + r0 * cs;
		c0y = y + r0 * cc;
		d0x = x + r0 * ds;
		d0y = y + r0 * dc;
	} else {
		ax = x - radius;
		ay = y - radius;
		var lx = radius * 2;
		var ly = lx;
		bx = ax + lx;
		by = ay;
		cx = bx;
		cy = ay + ly;
		dx = ax;
		dy = cy;
		var radius0 = radius - thick;
		a0x = x - radius0;
		a0y = y - radius0;
		var l0x = radius0 * 2;
		var l0y = l0x;
		b0x = a0x + l0x;
		b0y = a0y;
		c0x = b0x;
		c0y = a0y + l0y;
		d0x = a0x;
		d0y = c0y;
	}
	var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,a0x,a0y);
	out[out.length] = tri;
	var tri1 = new trilateral_tri_Trilateral(bx,by,b0x,b0y,a0x,a0y);
	out[out.length] = tri1;
	var tri2 = new trilateral_tri_Trilateral(d0x,d0y,c0x,c0y,dx,dy);
	out[out.length] = tri2;
	var tri3 = new trilateral_tri_Trilateral(c0x,c0y,cx,cy,dx,dy);
	out[out.length] = tri3;
	var tri4 = new trilateral_tri_Trilateral(ax,ay,a0x,a0y,d0x,d0y);
	out[out.length] = tri4;
	var tri5 = new trilateral_tri_Trilateral(ax,ay,d0x,d0y,dx,dy);
	out[out.length] = tri5;
	var tri6 = new trilateral_tri_Trilateral(b0x,b0y,bx,by,c0x,c0y);
	out[out.length] = tri6;
	var tri7 = new trilateral_tri_Trilateral(bx,by,cx,cy,c0x,c0y);
	out[out.length] = tri7;
	return out;
};
var trilateral_pairs_Star = function() { };
trilateral_pairs_Star.__name__ = true;
trilateral_pairs_Star.create = function(px,py,radius,theta) {
	if(theta == null) {
		theta = 0;
	}
	var pi = Math.PI;
	var omega = -pi + theta;
	var a0x = px + radius * Math.sin(omega);
	var a0y = py + radius * Math.cos(omega);
	omega += pi / 3;
	var a1x = px + radius * Math.sin(omega);
	var a1y = py + radius * Math.cos(omega);
	omega += pi / 3;
	var b0x = px + radius * Math.sin(omega);
	var b0y = py + radius * Math.cos(omega);
	omega += pi / 3;
	var b1x = px + radius * Math.sin(omega);
	var b1y = py + radius * Math.cos(omega);
	omega += pi / 3;
	var c0x = px + radius * Math.sin(omega);
	var c0y = py + radius * Math.cos(omega);
	omega += pi / 3;
	var c1x = px + radius * Math.sin(omega);
	var c1y = py + radius * Math.cos(omega);
	return { t0 : new trilateral_tri_Trilateral(a0x,a0y,b0x,b0y,c0x,c0y), t1 : new trilateral_tri_Trilateral(a1x,a1y,b1x,b1y,c1x,c1y)};
};
var trilateral_path_Base = function(contour_,trilateralArray_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.width = 0.01;
	this.y = 0.;
	this.x = 0.;
	var tmp;
	if(trilateralArray_ == null) {
		var t = [];
		var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
		var this2 = this1;
		tmp = this2;
	} else {
		tmp = trilateralArray_;
	}
	this.trilateralArray = tmp;
	this.contour = contour_ == null ? new trilateral_geom_Contour(this.trilateralArray,endLine_) : contour_;
	this.endLine = endLine_;
	this.points = [];
	this.pointsClock = [];
	this.pointsAnti = [];
	this.points[0] = [];
	this.dim = [];
};
trilateral_path_Base.__name__ = true;
trilateral_path_Base.__interfaces__ = [trilateral_justPath_IPathContext];
trilateral_path_Base.prototype = {
	reset: function() {
		var t = [];
		var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
		var this2 = this1;
		this.trilateralArray = this2;
		this.contour = new trilateral_geom_Contour(this.trilateralArray,this.endLine);
		this.points = [];
		this.pointsClock = [];
		this.pointsAnti = [];
		this.points[0] = [];
		this.dim = [];
	}
	,pointsNoEndOverlap: function() {
		var p;
		var l;
		var j = 0;
		var pointsClean = [];
		var _g = 0;
		var _g1 = this.points.length;
		while(_g < _g1) {
			var i = _g++;
			p = this.points[i];
			if(p.length > 2) {
				pointsClean[j++] = p;
			}
		}
		this.points = pointsClean;
		var _g2 = 0;
		var _g3 = this.points.length;
		while(_g2 < _g3) {
			var i1 = _g2++;
			p = this.points[i1];
			l = p.length;
			var repeat = p[0] == p[l - 2] && p[1] == p[l - 1];
			if(repeat) {
				this.points[i1].pop();
				this.points[i1].pop();
				l -= 2;
			}
		}
		return this.points;
	}
	,pointsRewound: function() {
		var p;
		var l;
		var j = 0;
		var pointsClean = [];
		var _g = 0;
		var _g1 = this.points.length;
		while(_g < _g1) {
			var i = _g++;
			p = this.points[i];
			if(p.length > 2) {
				pointsClean[j++] = p;
			}
		}
		this.points = pointsClean;
		var _g2 = 0;
		var _g3 = this.points.length;
		while(_g2 < _g3) {
			var i1 = _g2++;
			p = this.points[i1];
			l = p.length;
			var repeat = p[0] == p[l - 2] && p[1] == p[l - 1];
			if(repeat) {
				this.points[i1].pop();
				this.points[i1].pop();
				l -= 2;
			}
			var cc = 0.;
			var k = 0;
			var x1;
			var y1;
			var x2;
			var y2;
			var last = l - 2;
			while(k < l) {
				x1 = p[k];
				y1 = p[k + 1];
				if(k == last) {
					x2 = p[0];
					y2 = p[1];
				} else {
					x2 = p[k + 2];
					y2 = p[k + 3];
				}
				cc += (x2 - x1) * (y2 + y1);
				k += 2;
			}
			var reverse = cc > 0;
			if(reverse) {
				k = 0;
				while(k < l) {
					x1 = p[k];
					p[k] = p[k + 1];
					p[k + 1] = x1;
					k += 2;
				}
			}
			p.reverse();
			this.points[i1] = p;
		}
		return this.points;
	}
	,initDim: function() {
		return { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
	}
	,updateDim: function(x,y) {
		var d = this.dim[this.dim.length - 1];
		if(x < d.minX) {
			d.minX = x;
		}
		if(x > d.maxX) {
			d.maxX = x;
		}
		if(y < d.minY) {
			d.minY = y;
		}
		if(y > d.maxY) {
			d.maxY = y;
		}
	}
	,moveTo: function(x_,y_) {
		if(this.endLine == 2 || this.endLine == 3) {
			var _this = this.contour;
			var width_ = this.width;
			_this.endEdges();
			if(_this.count != 0) {
				var ax = _this.bx;
				var ay = _this.by;
				var radius = width_ / 2;
				var beta = -_this.angle1 - Math.PI / 2;
				var gamma = -_this.angle1 - Math.PI / 2 - Math.PI;
				var temp = [];
				var this1 = _this.triArr;
				var t = [];
				var this2;
				if(t == null) {
					var t1 = [];
					var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
					this2 = this3;
				} else {
					this2 = t;
				}
				var this4 = this2;
				var out = this4;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var dif;
				switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
				case 0:
					var f;
					if(beta >= 0 && beta > Math.PI) {
						f = beta;
					} else {
						var a = beta % (2 * Math.PI);
						f = a >= 0 ? a : a + 2 * Math.PI;
					}
					var this5 = f;
					var za = this5;
					var f1;
					if(gamma >= 0 && gamma > Math.PI) {
						f1 = gamma;
					} else {
						var a1 = gamma % (2 * Math.PI);
						f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
					}
					var this6 = f1;
					var zb = this6;
					var fa = za;
					var fb = zb;
					var theta = Math.abs(beta - gamma);
					var clockwise = beta < gamma;
					var dif1 = clockwise ? theta : -theta;
					dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
					break;
				case 1:
					var f2;
					if(beta >= 0 && beta > Math.PI) {
						f2 = beta;
					} else {
						var a2 = beta % (2 * Math.PI);
						f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
					}
					var this7 = f2;
					var za1 = this7;
					var f3;
					if(gamma >= 0 && gamma > Math.PI) {
						f3 = gamma;
					} else {
						var a3 = gamma % (2 * Math.PI);
						f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
					}
					var this8 = f3;
					var zb1 = this8;
					var fa1 = za1;
					var fb1 = zb1;
					var theta1 = Math.abs(beta - gamma);
					var clockwise1 = beta < gamma;
					var dif2 = clockwise1 ? theta1 : -theta1;
					dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
					break;
				case 2:
					var f4;
					if(beta >= 0 && beta > Math.PI) {
						f4 = beta;
					} else {
						var a4 = beta % (2 * Math.PI);
						f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
					}
					var this9 = f4;
					var za2 = this9;
					var f5;
					if(gamma >= 0 && gamma > Math.PI) {
						f5 = gamma;
					} else {
						var a5 = gamma % (2 * Math.PI);
						f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
					}
					var this10 = f5;
					var zb2 = this10;
					var fa2 = beta;
					var fb2 = gamma;
					var theta2 = Math.abs(beta - gamma);
					var smallest = theta2 <= Math.PI;
					var clockwise2 = beta < gamma;
					var dif3 = clockwise2 ? theta2 : -theta2;
					dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
					break;
				case 3:
					var f6;
					if(beta >= 0 && beta > Math.PI) {
						f6 = beta;
					} else {
						var a6 = beta % (2 * Math.PI);
						f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
					}
					var this11 = f6;
					var za3 = this11;
					var f7;
					if(gamma >= 0 && gamma > Math.PI) {
						f7 = gamma;
					} else {
						var a7 = gamma % (2 * Math.PI);
						f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
					}
					var this12 = f7;
					var zb3 = this12;
					var fa3 = beta;
					var fb3 = gamma;
					var theta3 = Math.abs(beta - gamma);
					var largest = theta3 > Math.PI;
					var clockwise3 = beta < gamma;
					var dif4 = clockwise3 ? theta3 : -theta3;
					dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
					break;
				}
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step1 = dif / totalSteps;
				var angle = beta;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = temp.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax + radius * Math.sin(angle);
					cy = ay + radius * Math.cos(angle);
					temp[p2++] = cx;
					temp[p2++] = cy;
					if(i != 0) {
						var t2 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
						out[out.length] = t2;
					}
					angle += step1;
					bx = cx;
					by = cy;
				}
				var triArr = out;
				var _g2 = 0;
				while(_g2 < triArr.length) {
					var t3 = triArr[_g2];
					++_g2;
					this1[this1.length] = t3;
				}
				var pA = _this.pointsAnti.length;
				var len = temp.length / 2 | 0;
				var _g3 = 0;
				var _g11 = len + 2;
				while(_g3 < _g11) {
					var i1 = _g3++;
					_this.pointsAnti[pA++] = temp[i1];
				}
				var pC = _this.pointsClock.length;
				var _g21 = 1;
				var _g31 = len / 2 + 1 | 0;
				while(_g21 < _g31) {
					var i2 = _g21++;
					_this.pointsClock[pC++] = temp[temp.length - 2 * i2];
					_this.pointsClock[pC++] = temp[temp.length - 2 * i2 - 1];
				}
			}
		}
		this.x = x_;
		this.y = y_;
		var l = this.points.length;
		this.points[l] = [];
		this.points[l][0] = x_;
		this.points[l][1] = y_;
		this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
		this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
		this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
		var d = this.dim[this.dim.length - 1];
		if(x_ < d.minX) {
			d.minX = x_;
		}
		if(x_ > d.maxX) {
			d.maxX = x_;
		}
		if(y_ < d.minY) {
			d.minY = y_;
		}
		if(y_ > d.maxY) {
			d.maxY = y_;
		}
		this.contour.reset();
	}
	,lastClock: function() {
		if(this.contour.pointsClock.length != 0) {
			this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
			this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
		}
	}
	,getEdges: function() {
		var edges = [];
		var no = this.pointsClock.length;
		if(no > this.pointsAnti.length) {
			no = this.pointsAnti.length;
		}
		var pClock;
		var pAnti;
		var shape;
		var _g = 0;
		var _g1 = no;
		while(_g < _g1) {
			var s = _g++;
			pClock = this.pointsClock[s];
			pAnti = this.pointsAnti[s];
			var lc = pClock.length;
			var la = pAnti.length;
			edges[s] = [];
			shape = edges[s];
			var _g2 = 0;
			var _g11 = lc;
			while(_g2 < _g11) {
				var i = _g2++;
				shape[i] = pClock[i];
			}
			var j = shape.length;
			var l5 = la / 2 | 0;
			var _g21 = 0;
			var _g3 = l5;
			while(_g21 < _g3) {
				var i1 = _g21++;
				shape[j + i1 * 2] = pAnti[la - i1 * 2 - 1];
				shape[j + i1 * 2 + 1] = pAnti[la - i1 * 2];
			}
			j = shape.length;
			shape[j++] = pClock[0];
			shape[j] = pClock[1];
		}
		return edges;
	}
	,lineTo: function(x_,y_) {
		var repeat = this.x == x_ && this.y == y_;
		if(!repeat) {
			if(this.widthFunction != null) {
				this.width = this.widthFunction(this.width,this.x,this.x,x_,y_);
			}
			this.line(x_,y_);
			var l = this.points.length;
			var p = this.points[l - 1];
			var l2 = p.length;
			p[l2] = x_;
			p[l2 + 1] = y_;
			var d = this.dim[this.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			this.x = x_;
			this.y = y_;
		}
	}
	,line: function(x_,y_) {
		console.log("trilateral/path/Base.hx:245:","lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )");
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.halfA = Math.PI / 2;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var dxPrev_ = _this.dx;
		var dyPrev_ = _this.dy;
		var exPrev_ = _this.ex;
		var eyPrev_ = _this.ey;
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var this1 = _this.triArr;
		var tri = new trilateral_tri_Trilateral(dxPrev_,dyPrev_,_this.dx,_this.dy,exPrev_,eyPrev_,0);
		this1[this1.length] = tri;
		var this2 = _this.triArr;
		var tri1 = new trilateral_tri_Trilateral(dxPrev_,dyPrev_,_this.dx,_this.dy,_this.ex,_this.ey,0);
		this2[this2.length] = tri1;
	}
	,lineTrace: function(x_,y_) {
		console.log("trilateral/path/Base.hx:245:","lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )");
	}
	,quadTo: function(x1,y1,x2,y2) {
		this.tempArr = [];
		var p = this.tempArr;
		var ax = this.x;
		var ay = this.y;
		var x = ax - x1;
		var y = ay - y1;
		var x3 = x1 - x2;
		var y3 = y1 - y2;
		var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x3 * x3 + y3 * y3);
		if(approxDistance == 0) {
			approxDistance = 0.000001;
		}
		var step = Math.min(1 / (approxDistance * 0.707),trilateral_geom_Algebra.quadStep);
		var l = p.length;
		p[l++] = ax;
		p[l++] = ay;
		var t = step;
		while(t < 1.) {
			var u = 1 - t;
			p[l++] = Math.pow(u,2) * ax + 2 * u * t * x1 + Math.pow(t,2) * x2;
			var u1 = 1 - t;
			p[l++] = Math.pow(u1,2) * ay + 2 * u1 * t * y1 + Math.pow(t,2) * y2;
			t += step;
		}
		p[l++] = x2;
		p[l++] = y2;
		var arr = this.tempArr;
		var l1 = arr.length;
		var i = 2;
		var x_ = arr[0];
		var y_ = arr[1];
		var repeat = this.x == x_ && this.y == y_;
		if(!repeat) {
			if(this.widthFunction != null) {
				this.width = this.widthFunction(this.width,this.x,this.x,x_,y_);
			}
			this.line(x_,y_);
			var l2 = this.points.length;
			var p1 = this.points[l2 - 1];
			var l21 = p1.length;
			p1[l21] = x_;
			p1[l21 + 1] = y_;
			var d = this.dim[this.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			this.x = x_;
			this.y = y_;
		}
		while(i < l1) {
			var x_1 = arr[i];
			var y_1 = arr[i + 1];
			var repeat1 = this.x == x_1 && this.y == y_1;
			if(!repeat1) {
				if(this.widthFunction != null) {
					this.width = this.widthFunction(this.width,this.x,this.x,x_1,y_1);
				}
				this.line(x_1,y_1);
				var l3 = this.points.length;
				var p2 = this.points[l3 - 1];
				var l22 = p2.length;
				p2[l22] = x_1;
				p2[l22 + 1] = y_1;
				var d1 = this.dim[this.dim.length - 1];
				if(x_1 < d1.minX) {
					d1.minX = x_1;
				}
				if(x_1 > d1.maxX) {
					d1.maxX = x_1;
				}
				if(y_1 < d1.minY) {
					d1.minY = y_1;
				}
				if(y_1 > d1.maxY) {
					d1.maxY = y_1;
				}
				this.x = x_1;
				this.y = y_1;
			}
			i += 2;
		}
		this.x = x2;
		this.y = y2;
	}
	,quadThru: function(x1,y1,x2,y2) {
		var newx = 2 * x1 - 0.5 * (this.x + x2);
		var newy = 2 * y1 - 0.5 * (this.y + y2);
		this.tempArr = [];
		var p = this.tempArr;
		var ax = this.x;
		var ay = this.y;
		var x = ax - newx;
		var y = ay - newy;
		var x3 = newx - x2;
		var y3 = newy - y2;
		var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x3 * x3 + y3 * y3);
		if(approxDistance == 0) {
			approxDistance = 0.000001;
		}
		var step = Math.min(1 / (approxDistance * 0.707),trilateral_geom_Algebra.quadStep);
		var l = p.length;
		p[l++] = ax;
		p[l++] = ay;
		var t = step;
		while(t < 1.) {
			var u = 1 - t;
			p[l++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * x2;
			var u1 = 1 - t;
			p[l++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * y2;
			t += step;
		}
		p[l++] = x2;
		p[l++] = y2;
		var arr = this.tempArr;
		var l1 = arr.length;
		var i = 2;
		var x_ = arr[0];
		var y_ = arr[1];
		var repeat = this.x == x_ && this.y == y_;
		if(!repeat) {
			if(this.widthFunction != null) {
				this.width = this.widthFunction(this.width,this.x,this.x,x_,y_);
			}
			this.line(x_,y_);
			var l2 = this.points.length;
			var p1 = this.points[l2 - 1];
			var l21 = p1.length;
			p1[l21] = x_;
			p1[l21 + 1] = y_;
			var d = this.dim[this.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			this.x = x_;
			this.y = y_;
		}
		while(i < l1) {
			var x_1 = arr[i];
			var y_1 = arr[i + 1];
			var repeat1 = this.x == x_1 && this.y == y_1;
			if(!repeat1) {
				if(this.widthFunction != null) {
					this.width = this.widthFunction(this.width,this.x,this.x,x_1,y_1);
				}
				this.line(x_1,y_1);
				var l3 = this.points.length;
				var p2 = this.points[l3 - 1];
				var l22 = p2.length;
				p2[l22] = x_1;
				p2[l22 + 1] = y_1;
				var d1 = this.dim[this.dim.length - 1];
				if(x_1 < d1.minX) {
					d1.minX = x_1;
				}
				if(x_1 > d1.maxX) {
					d1.maxX = x_1;
				}
				if(y_1 < d1.minY) {
					d1.minY = y_1;
				}
				if(y_1 > d1.maxY) {
					d1.maxY = y_1;
				}
				this.x = x_1;
				this.y = y_1;
			}
			i += 2;
		}
		this.x = x2;
		this.y = y2;
		return;
	}
	,curveTo: function(x1,y1,x2,y2,x3,y3) {
		this.tempArr = [];
		var p = this.tempArr;
		var ax = this.x;
		var ay = this.y;
		var x = ax - x1;
		var y = ay - y1;
		var x4 = x1 - x2;
		var y4 = y1 - y2;
		var x5 = x2 - x3;
		var y5 = y2 - y3;
		var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x4 * x4 + y4 * y4) + Math.sqrt(x5 * x5 + y5 * y5);
		if(approxDistance == 0) {
			approxDistance = 0.000001;
		}
		var step = Math.min(1 / (approxDistance * 0.707),trilateral_geom_Algebra.cubicStep);
		var l = p.length;
		p[l++] = ax;
		p[l++] = ay;
		var t = step;
		while(t < 1.) {
			var u = 1 - t;
			p[l++] = Math.pow(u,3) * ax + 3 * Math.pow(u,2) * t * x1 + 3 * u * Math.pow(t,2) * x2 + Math.pow(t,3) * x3;
			var u1 = 1 - t;
			p[l++] = Math.pow(u1,3) * ay + 3 * Math.pow(u1,2) * t * y1 + 3 * u1 * Math.pow(t,2) * y2 + Math.pow(t,3) * y3;
			t += step;
		}
		p[l++] = x3;
		p[l++] = y3;
		var arr = this.tempArr;
		var l1 = arr.length;
		var i = 2;
		var x_ = arr[0];
		var y_ = arr[1];
		var repeat = this.x == x_ && this.y == y_;
		if(!repeat) {
			if(this.widthFunction != null) {
				this.width = this.widthFunction(this.width,this.x,this.x,x_,y_);
			}
			this.line(x_,y_);
			var l2 = this.points.length;
			var p1 = this.points[l2 - 1];
			var l21 = p1.length;
			p1[l21] = x_;
			p1[l21 + 1] = y_;
			var d = this.dim[this.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			this.x = x_;
			this.y = y_;
		}
		while(i < l1) {
			var x_1 = arr[i];
			var y_1 = arr[i + 1];
			var repeat1 = this.x == x_1 && this.y == y_1;
			if(!repeat1) {
				if(this.widthFunction != null) {
					this.width = this.widthFunction(this.width,this.x,this.x,x_1,y_1);
				}
				this.line(x_1,y_1);
				var l3 = this.points.length;
				var p2 = this.points[l3 - 1];
				var l22 = p2.length;
				p2[l22] = x_1;
				p2[l22 + 1] = y_1;
				var d1 = this.dim[this.dim.length - 1];
				if(x_1 < d1.minX) {
					d1.minX = x_1;
				}
				if(x_1 > d1.maxX) {
					d1.maxX = x_1;
				}
				if(y_1 < d1.minY) {
					d1.minY = y_1;
				}
				if(y_1 > d1.maxY) {
					d1.maxY = y_1;
				}
				this.x = x_1;
				this.y = y_1;
			}
			i += 2;
		}
		this.x = x3;
		this.y = y3;
	}
	,plotCoord: function(arr,withMove) {
		if(withMove == null) {
			withMove = true;
		}
		var l = arr.length;
		var i = 2;
		if(withMove) {
			this.moveTo(arr[0],arr[1]);
		} else {
			var x_ = arr[0];
			var y_ = arr[1];
			var repeat = this.x == x_ && this.y == y_;
			if(!repeat) {
				if(this.widthFunction != null) {
					this.width = this.widthFunction(this.width,this.x,this.x,x_,y_);
				}
				this.line(x_,y_);
				var l1 = this.points.length;
				var p = this.points[l1 - 1];
				var l2 = p.length;
				p[l2] = x_;
				p[l2 + 1] = y_;
				var d = this.dim[this.dim.length - 1];
				if(x_ < d.minX) {
					d.minX = x_;
				}
				if(x_ > d.maxX) {
					d.maxX = x_;
				}
				if(y_ < d.minY) {
					d.minY = y_;
				}
				if(y_ > d.maxY) {
					d.maxY = y_;
				}
				this.x = x_;
				this.y = y_;
			}
		}
		while(i < l) {
			var x_1 = arr[i];
			var y_1 = arr[i + 1];
			var repeat1 = this.x == x_1 && this.y == y_1;
			if(!repeat1) {
				if(this.widthFunction != null) {
					this.width = this.widthFunction(this.width,this.x,this.x,x_1,y_1);
				}
				this.line(x_1,y_1);
				var l3 = this.points.length;
				var p1 = this.points[l3 - 1];
				var l21 = p1.length;
				p1[l21] = x_1;
				p1[l21 + 1] = y_1;
				var d1 = this.dim[this.dim.length - 1];
				if(x_1 < d1.minX) {
					d1.minX = x_1;
				}
				if(x_1 > d1.maxX) {
					d1.maxX = x_1;
				}
				if(y_1 < d1.minY) {
					d1.minY = y_1;
				}
				if(y_1 > d1.maxY) {
					d1.maxY = y_1;
				}
				this.x = x_1;
				this.y = y_1;
			}
			i += 2;
		}
	}
};
var trilateral_path_Fine = function(contour_,trilateralArray_,endLine_) {
	trilateral_path_Base.call(this,contour_,trilateralArray_,endLine_);
};
trilateral_path_Fine.__name__ = true;
trilateral_path_Fine.__super__ = trilateral_path_Base;
trilateral_path_Fine.prototype = $extend(trilateral_path_Base.prototype,{
	line: function(x_,y_) {
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		var oldAngle = _this.dx != null ? _this.angle1 : null;
		_this.halfA = Math.PI / 2;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var x = _this.dxOld - x_;
		var y = _this.dyOld - y_;
		var x1 = _this.exOld - x_;
		var y1 = _this.eyOld - y_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(_this.ay - _this.dyOld,_this.ax - _this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.eyPrev,_this.ax - _this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(_this.ay - _this.eyOld,_this.ax - _this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.dyPrev,_this.ax - _this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f1;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f1 = theta1;
			} else {
				var a1 = theta1 % (2 * Math.PI);
				f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
			}
			var this2 = f1;
			var zb = this2;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(theta0 - theta1);
			var clockwise = theta0 < theta1;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f2;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f2 = theta0;
			} else {
				var a2 = theta0 % (2 * Math.PI);
				f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
			}
			var this3 = f2;
			var za1 = this3;
			var f3;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f3 = theta1;
			} else {
				var a3 = theta1 % (2 * Math.PI);
				f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
			}
			var this4 = f3;
			var zb1 = this4;
			var fa1 = za1;
			var fb1 = zb1;
			var theta2 = Math.abs(theta0 - theta1);
			var clockwise1 = theta0 < theta1;
			var dif2 = clockwise1 ? theta2 : -theta2;
			dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
			break;
		case 2:
			var f4;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f4 = theta0;
			} else {
				var a4 = theta0 % (2 * Math.PI);
				f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
			}
			var this5 = f4;
			var za2 = this5;
			var f5;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f5 = theta1;
			} else {
				var a5 = theta1 % (2 * Math.PI);
				f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
			}
			var this6 = f5;
			var zb2 = this6;
			var fa2 = theta0;
			var fb2 = theta1;
			var theta3 = Math.abs(theta0 - theta1);
			var smallest = theta3 <= Math.PI;
			var clockwise2 = theta0 < theta1;
			var dif3 = clockwise2 ? theta3 : -theta3;
			dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
			break;
		case 3:
			var f6;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f6 = theta0;
			} else {
				var a6 = theta0 % (2 * Math.PI);
				f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
			}
			var this7 = f6;
			var za3 = this7;
			var f7;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f7 = theta1;
			} else {
				var a7 = theta1 % (2 * Math.PI);
				f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
			}
			var this8 = f7;
			var zb3 = this8;
			var fa3 = theta0;
			var fb3 = theta1;
			var theta4 = Math.abs(theta0 - theta1);
			var largest = theta4 > Math.PI;
			var clockwise3 = theta0 < theta1;
			var dif4 = clockwise3 ? theta4 : -theta4;
			dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta4) : 2 * Math.PI - theta4;
			break;
		}
		if(_this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f8;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f8 = theta0;
			} else {
				var a8 = (theta0 + Math.PI) % (2 * Math.PI);
				f8 = a8 >= 0 ? a8 - Math.PI : a8 + Math.PI;
			}
			var this9 = f8;
			var start = this9;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			_this.jx = _this.ax + h * Math.sin(delta);
			_this.jy = _this.ay + h * Math.cos(delta);
		}
		if(_this.count == 0 && (_this.endLine == 1 || _this.endLine == 3)) {
			var ax = _this.ax;
			var ay = _this.ay;
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma1 = -_this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			var this10 = _this.triArr;
			var t = [];
			var this11;
			if(t == null) {
				var t1 = [];
				var this12 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
				this11 = this12;
			} else {
				this11 = t;
			}
			var this13 = this11;
			var out = this13;
			var pi = Math.PI;
			var step = pi * 2 / 36;
			var dif5;
			switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f9;
				if(beta >= 0 && beta > Math.PI) {
					f9 = beta;
				} else {
					var a9 = beta % (2 * Math.PI);
					f9 = a9 >= 0 ? a9 : a9 + 2 * Math.PI;
				}
				var this14 = f9;
				var za4 = this14;
				var f10;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f10 = gamma1;
				} else {
					var a10 = gamma1 % (2 * Math.PI);
					f10 = a10 >= 0 ? a10 : a10 + 2 * Math.PI;
				}
				var this15 = f10;
				var zb4 = this15;
				var fa4 = za4;
				var fb4 = zb4;
				var theta5 = Math.abs(beta - gamma1);
				var clockwise4 = beta < gamma1;
				var dif6 = clockwise4 ? theta5 : -theta5;
				dif5 = dif6 > 0 ? dif6 : 2 * Math.PI + dif6;
				break;
			case 1:
				var f11;
				if(beta >= 0 && beta > Math.PI) {
					f11 = beta;
				} else {
					var a11 = beta % (2 * Math.PI);
					f11 = a11 >= 0 ? a11 : a11 + 2 * Math.PI;
				}
				var this16 = f11;
				var za5 = this16;
				var f12;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f12 = gamma1;
				} else {
					var a12 = gamma1 % (2 * Math.PI);
					f12 = a12 >= 0 ? a12 : a12 + 2 * Math.PI;
				}
				var this17 = f12;
				var zb5 = this17;
				var fa5 = za5;
				var fb5 = zb5;
				var theta6 = Math.abs(beta - gamma1);
				var clockwise5 = beta < gamma1;
				var dif7 = clockwise5 ? theta6 : -theta6;
				dif5 = dif7 < 0 ? dif7 : -2 * Math.PI + dif7;
				break;
			case 2:
				var f13;
				if(beta >= 0 && beta > Math.PI) {
					f13 = beta;
				} else {
					var a13 = beta % (2 * Math.PI);
					f13 = a13 >= 0 ? a13 : a13 + 2 * Math.PI;
				}
				var this18 = f13;
				var za6 = this18;
				var f14;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f14 = gamma1;
				} else {
					var a14 = gamma1 % (2 * Math.PI);
					f14 = a14 >= 0 ? a14 : a14 + 2 * Math.PI;
				}
				var this19 = f14;
				var zb6 = this19;
				var fa6 = beta;
				var fb6 = gamma1;
				var theta7 = Math.abs(beta - gamma1);
				var smallest1 = theta7 <= Math.PI;
				var clockwise6 = beta < gamma1;
				var dif8 = clockwise6 ? theta7 : -theta7;
				dif5 = smallest1 ? dif8 : clockwise6 ? -(2 * Math.PI - theta7) : 2 * Math.PI - theta7;
				break;
			case 3:
				var f15;
				if(beta >= 0 && beta > Math.PI) {
					f15 = beta;
				} else {
					var a15 = beta % (2 * Math.PI);
					f15 = a15 >= 0 ? a15 : a15 + 2 * Math.PI;
				}
				var this20 = f15;
				var za7 = this20;
				var f16;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f16 = gamma1;
				} else {
					var a16 = gamma1 % (2 * Math.PI);
					f16 = a16 >= 0 ? a16 : a16 + 2 * Math.PI;
				}
				var this21 = f16;
				var zb7 = this21;
				var fa7 = beta;
				var fb7 = gamma1;
				var theta8 = Math.abs(beta - gamma1);
				var largest1 = theta8 > Math.PI;
				var clockwise7 = beta < gamma1;
				var dif9 = clockwise7 ? theta8 : -theta8;
				dif5 = largest1 ? dif9 : clockwise7 ? -(2 * Math.PI - theta8) : 2 * Math.PI - theta8;
				break;
			}
			var positive = dif5 >= 0;
			var totalSteps = Math.ceil(Math.abs(dif5) / step);
			var step1 = dif5 / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					var t2 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
					out[out.length] = t2;
				}
				angle += step1;
				bx = cx;
				by = cy;
			}
			var triArr = out;
			var _g2 = 0;
			while(_g2 < triArr.length) {
				var t3 = triArr[_g2];
				++_g2;
				this10[this10.length] = t3;
			}
			var pA = _this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g3 = 0;
			var _g11 = p4;
			while(_g3 < _g11) {
				var i1 = _g3++;
				_this.pointsAnti[pA++] = temp[len - 2 * i1 + 1];
				_this.pointsAnti[pA++] = temp[len - 2 * i1];
			}
			var pC = _this.pointsClock.length;
			var _g21 = 0;
			var _g31 = p4;
			while(_g21 < _g31) {
				var i2 = _g21++;
				_this.pointsClock[pC++] = temp[i2 * 2 + len + 1];
				_this.pointsClock[pC++] = temp[i2 * 2 + len];
			}
		}
		if(_this.count != 0) {
			_this.addQuads(clockWise,width_);
		}
		_this.quadIndex = _this.triArr.length;
		if(_this.count == 0) {
			_this.penultimateAX = _this.dxPrev;
			_this.penultimateAY = _this.dyPrev;
			_this.lastAntiX = _this.ex;
			_this.lastAntiY = _this.ey;
			_this.penultimateCX = _this.dx;
			_this.penultimateCY = _this.dy;
			_this.lastClockX = _this.exPrev;
			_this.lastClockY = _this.eyPrev;
			var this22 = _this.triArr;
			var tri = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.dx,_this.dy,_this.ex,_this.ey,0);
			this22[this22.length] = tri;
			var this23 = _this.triArr;
			var tri1 = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.dx,_this.dy,_this.exPrev,_this.eyPrev,0);
			this23[this23.length] = tri1;
		} else {
			if(clockWise && !_this.lastClock) {
				_this.penultimateAX = _this.jx;
				_this.penultimateAY = _this.jy;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.exPrev;
				_this.lastClockY = _this.eyPrev;
				var this24 = _this.triArr;
				var tri2 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.ex,_this.ey,0);
				this24[this24.length] = tri2;
				var this25 = _this.triArr;
				var tri3 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.exPrev,_this.eyPrev,0);
				this25[this25.length] = tri3;
			}
			if(clockWise && _this.lastClock) {
				_this.penultimateAX = _this.jx;
				_this.penultimateAY = _this.jy;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.exPrev;
				_this.lastClockY = _this.eyPrev;
				var this26 = _this.triArr;
				var tri4 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.ex,_this.ey,0);
				this26[this26.length] = tri4;
				var this27 = _this.triArr;
				var tri5 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.exPrev,_this.eyPrev,0);
				this27[this27.length] = tri5;
			}
			if(!clockWise && !_this.lastClock) {
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.jx;
				_this.lastClockY = _this.jy;
				_this.penultimateAX = _this.dxPrev;
				_this.penultimateAY = _this.dyPrev;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				var this28 = _this.triArr;
				var tri6 = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.dx,_this.dy,_this.jx,_this.jy,0);
				this28[this28.length] = tri6;
				var this29 = _this.triArr;
				var tri7 = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.dx,_this.dy,_this.ex,_this.ey,0);
				this29[this29.length] = tri7;
			}
			if(!clockWise && _this.lastClock) {
				_this.penultimateAX = _this.dxPrev;
				_this.penultimateAY = _this.dyPrev;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.jx;
				_this.penultimateCY = _this.jy;
				_this.lastClockX = _this.dx;
				_this.lastClockY = _this.dy;
				var this30 = _this.triArr;
				var tri8 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.ex,_this.ey,0);
				this30[this30.length] = tri8;
				var this31 = _this.triArr;
				var tri9 = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.jx,_this.jy,_this.ex,_this.ey,0);
				this31[this31.length] = tri9;
			}
		}
		if(clockWise) {
			var radius1 = width_ / 2;
			var edgePoly = _this.pointsClock;
			var t4 = [];
			var this32;
			if(t4 == null) {
				var t5 = [];
				var this33 = t5 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t5;
				this32 = this33;
			} else {
				this32 = t4;
			}
			var this34 = this32;
			var out1 = this34;
			var pi1 = Math.PI;
			var step2 = pi1 * 2 / 36;
			var positive1 = dif >= 0;
			var totalSteps1 = Math.ceil(Math.abs(dif) / step2);
			var step3 = dif / totalSteps1;
			var angle1 = theta0;
			var cx1;
			var cy1;
			var bx1 = 0;
			var by1 = 0;
			var p21 = edgePoly.length;
			var count = 0;
			var _g4 = 0;
			var _g12 = totalSteps1 + 1;
			while(_g4 < _g12) {
				var i3 = _g4++;
				cx1 = ax_ + radius1 * Math.sin(angle1);
				cy1 = ay_ + radius1 * Math.cos(angle1);
				if(i3 != 0) {
					var t6 = new trilateral_tri_Trilateral(ax_,ay_,bx1,by1,cx1,cy1);
					out1[out1.length] = t6;
					edgePoly[p21++] = cx1;
					edgePoly[p21++] = cy1;
				}
				angle1 += step3;
				bx1 = cx1;
				by1 = cy1;
			}
			var trilateralArray = out1;
			var this35 = _this.triArr;
			var _g5 = 0;
			while(_g5 < trilateralArray.length) {
				var t7 = trilateralArray[_g5];
				++_g5;
				this35[this35.length] = t7;
			}
		} else {
			var radius2 = width_ / 2;
			var edgePoly1 = _this.pointsAnti;
			var t8 = [];
			var this36;
			if(t8 == null) {
				var t9 = [];
				var this37 = t9 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t9;
				this36 = this37;
			} else {
				this36 = t8;
			}
			var this38 = this36;
			var out2 = this38;
			var pi2 = Math.PI;
			var step4 = pi2 * 2 / 36;
			var positive2 = dif >= 0;
			var totalSteps2 = Math.ceil(Math.abs(dif) / step4);
			var step5 = dif / totalSteps2;
			var angle2 = theta0;
			var cx2;
			var cy2;
			var bx2 = 0;
			var by2 = 0;
			var p22 = edgePoly1.length;
			var count1 = 0;
			var _g6 = 0;
			var _g13 = totalSteps2 + 1;
			while(_g6 < _g13) {
				var i4 = _g6++;
				cx2 = ax_ + radius2 * Math.sin(angle2);
				cy2 = ay_ + radius2 * Math.cos(angle2);
				if(i4 != 0) {
					var t10 = new trilateral_tri_Trilateral(ax_,ay_,bx2,by2,cx2,cy2);
					out2[out2.length] = t10;
					edgePoly1[p22++] = cx2;
					edgePoly1[p22++] = cy2;
				}
				angle2 += step5;
				bx2 = cx2;
				by2 = cy2;
			}
			var trilateralArray1 = out2;
			var this39 = _this.triArr;
			var _g7 = 0;
			while(_g7 < trilateralArray1.length) {
				var t11 = trilateralArray1[_g7];
				++_g7;
				this39[this39.length] = t11;
			}
		}
		_this.kax = _this.dxPrev;
		_this.kay = _this.dyPrev;
		_this.kbx = _this.dx;
		_this.kby = _this.dy;
		_this.ncx = _this.exPrev;
		_this.ncy = _this.eyPrev;
		_this.kcx = _this.ex;
		_this.kcy = _this.ey;
		if(_this.count != 0) {
			if(clockWise) {
				var this40 = _this.triArr;
				var tri10 = new trilateral_tri_Trilateral(_this.ax,_this.ay,_this.dxOld,_this.dyOld,_this.jx,_this.jy,0);
				this40[this40.length] = tri10;
				var this41 = _this.triArr;
				var tri11 = new trilateral_tri_Trilateral(_this.ax,_this.ay,_this.exPrev,_this.eyPrev,_this.jx,_this.jy,0);
				this41[this41.length] = tri11;
			} else {
				var this42 = _this.triArr;
				var tri12 = new trilateral_tri_Trilateral(_this.ax,_this.ay,_this.exOld,_this.eyOld,_this.jx,_this.jy,0);
				this42[this42.length] = tri12;
				var this43 = _this.triArr;
				var tri13 = new trilateral_tri_Trilateral(_this.ax,_this.ay,_this.dxPrev,_this.dyPrev,_this.jx,_this.jy,0);
				this43[this43.length] = tri13;
			}
		}
		_this.jxOld = _this.jx;
		_this.jyOld = _this.jy;
		_this.lastClock = clockWise;
		_this.count++;
	}
});
var trilateral_polys_Poly = function() { };
trilateral_polys_Poly.__name__ = true;
trilateral_polys_Poly.circle = function(ax,ay,radius,sides,omega) {
	if(omega == null) {
		omega = 0.;
	}
	if(sides == null) {
		sides = 36;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var theta = pi / 2 + omega;
	var step = pi * 2 / sides;
	var bx;
	var by;
	var cx;
	var cy;
	var _g = 0;
	var _g1 = sides;
	while(_g < _g1) {
		var i = _g++;
		bx = ax + radius * Math.sin(theta);
		by = ay + radius * Math.cos(theta);
		theta += step;
		cx = ax + radius * Math.sin(theta);
		cy = ay + radius * Math.cos(theta);
		var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
		out[out.length] = tri;
	}
	return out;
};
trilateral_polys_Poly.ellipse = function(ax,ay,rx,ry,sides) {
	if(sides == null) {
		sides = 36;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var theta = pi / 2;
	var step = pi * 2 / sides;
	var bx;
	var by;
	var cx;
	var cy;
	var _g = 0;
	var _g1 = sides;
	while(_g < _g1) {
		var i = _g++;
		bx = ax + rx * Math.sin(theta);
		by = ay + ry * Math.cos(theta);
		theta += step;
		cx = ax + rx * Math.sin(theta);
		cy = ay + ry * Math.cos(theta);
		var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
		out[out.length] = tri;
	}
	return out;
};
trilateral_polys_Poly.pie = function(ax,ay,radius,beta,gamma,prefer,mark,sides) {
	if(sides == null) {
		sides = 36;
	}
	if(mark == null) {
		mark = 0;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var step = pi * 2 / sides;
	var dif;
	switch(prefer._hx_index) {
	case 0:
		var f;
		if(beta >= 0 && beta > Math.PI) {
			f = beta;
		} else {
			var a = beta % (2 * Math.PI);
			f = a >= 0 ? a : a + 2 * Math.PI;
		}
		var this3 = f;
		var za = this3;
		var f1;
		if(gamma >= 0 && gamma > Math.PI) {
			f1 = gamma;
		} else {
			var a1 = gamma % (2 * Math.PI);
			f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this4 = f1;
		var zb = this4;
		var fa = za;
		var fb = zb;
		var theta = Math.abs(beta - gamma);
		var clockwise = beta < gamma;
		var dif1 = clockwise ? theta : -theta;
		dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
		break;
	case 1:
		var f2;
		if(beta >= 0 && beta > Math.PI) {
			f2 = beta;
		} else {
			var a2 = beta % (2 * Math.PI);
			f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
		}
		var this5 = f2;
		var za1 = this5;
		var f3;
		if(gamma >= 0 && gamma > Math.PI) {
			f3 = gamma;
		} else {
			var a3 = gamma % (2 * Math.PI);
			f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
		}
		var this6 = f3;
		var zb1 = this6;
		var fa1 = za1;
		var fb1 = zb1;
		var theta1 = Math.abs(beta - gamma);
		var clockwise1 = beta < gamma;
		var dif2 = clockwise1 ? theta1 : -theta1;
		dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
		break;
	case 2:
		var f4;
		if(beta >= 0 && beta > Math.PI) {
			f4 = beta;
		} else {
			var a4 = beta % (2 * Math.PI);
			f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
		}
		var this7 = f4;
		var za2 = this7;
		var f5;
		if(gamma >= 0 && gamma > Math.PI) {
			f5 = gamma;
		} else {
			var a5 = gamma % (2 * Math.PI);
			f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
		}
		var this8 = f5;
		var zb2 = this8;
		var fa2 = beta;
		var fb2 = gamma;
		var theta2 = Math.abs(beta - gamma);
		var smallest = theta2 <= Math.PI;
		var clockwise2 = beta < gamma;
		var dif3 = clockwise2 ? theta2 : -theta2;
		dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
		break;
	case 3:
		var f6;
		if(beta >= 0 && beta > Math.PI) {
			f6 = beta;
		} else {
			var a6 = beta % (2 * Math.PI);
			f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
		}
		var this9 = f6;
		var za3 = this9;
		var f7;
		if(gamma >= 0 && gamma > Math.PI) {
			f7 = gamma;
		} else {
			var a7 = gamma % (2 * Math.PI);
			f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
		}
		var this10 = f7;
		var zb3 = this10;
		var fa3 = beta;
		var fb3 = gamma;
		var theta3 = Math.abs(beta - gamma);
		var largest = theta3 > Math.PI;
		var clockwise3 = beta < gamma;
		var dif4 = clockwise3 ? theta3 : -theta3;
		dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
		break;
	}
	var positive = dif >= 0;
	var totalSteps = Math.ceil(Math.abs(dif) / step);
	var step1 = dif / totalSteps;
	var angle = beta;
	var cx;
	var cy;
	var bx = 0;
	var by = 0;
	var _g = 0;
	var _g1 = totalSteps + 1;
	while(_g < _g1) {
		var i = _g++;
		cx = ax + radius * Math.sin(angle);
		cy = ay + radius * Math.cos(angle);
		if(i != 0) {
			var t1 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
			out[out.length] = t1;
			if(mark != 0) {
				t1.mark = mark;
			}
		}
		angle += step1;
		bx = cx;
		by = cy;
	}
	return out;
};
trilateral_polys_Poly.pieX = function(ax,ay,radius,beta,gamma,prefer,edgePoly,mark,sides) {
	if(sides == null) {
		sides = 36;
	}
	if(mark == null) {
		mark = 0;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var step = pi * 2 / sides;
	var dif;
	switch(prefer._hx_index) {
	case 0:
		var f;
		if(beta >= 0 && beta > Math.PI) {
			f = beta;
		} else {
			var a = beta % (2 * Math.PI);
			f = a >= 0 ? a : a + 2 * Math.PI;
		}
		var this3 = f;
		var za = this3;
		var f1;
		if(gamma >= 0 && gamma > Math.PI) {
			f1 = gamma;
		} else {
			var a1 = gamma % (2 * Math.PI);
			f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this4 = f1;
		var zb = this4;
		var fa = za;
		var fb = zb;
		var theta = Math.abs(beta - gamma);
		var clockwise = beta < gamma;
		var dif1 = clockwise ? theta : -theta;
		dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
		break;
	case 1:
		var f2;
		if(beta >= 0 && beta > Math.PI) {
			f2 = beta;
		} else {
			var a2 = beta % (2 * Math.PI);
			f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
		}
		var this5 = f2;
		var za1 = this5;
		var f3;
		if(gamma >= 0 && gamma > Math.PI) {
			f3 = gamma;
		} else {
			var a3 = gamma % (2 * Math.PI);
			f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
		}
		var this6 = f3;
		var zb1 = this6;
		var fa1 = za1;
		var fb1 = zb1;
		var theta1 = Math.abs(beta - gamma);
		var clockwise1 = beta < gamma;
		var dif2 = clockwise1 ? theta1 : -theta1;
		dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
		break;
	case 2:
		var f4;
		if(beta >= 0 && beta > Math.PI) {
			f4 = beta;
		} else {
			var a4 = beta % (2 * Math.PI);
			f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
		}
		var this7 = f4;
		var za2 = this7;
		var f5;
		if(gamma >= 0 && gamma > Math.PI) {
			f5 = gamma;
		} else {
			var a5 = gamma % (2 * Math.PI);
			f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
		}
		var this8 = f5;
		var zb2 = this8;
		var fa2 = beta;
		var fb2 = gamma;
		var theta2 = Math.abs(beta - gamma);
		var smallest = theta2 <= Math.PI;
		var clockwise2 = beta < gamma;
		var dif3 = clockwise2 ? theta2 : -theta2;
		dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
		break;
	case 3:
		var f6;
		if(beta >= 0 && beta > Math.PI) {
			f6 = beta;
		} else {
			var a6 = beta % (2 * Math.PI);
			f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
		}
		var this9 = f6;
		var za3 = this9;
		var f7;
		if(gamma >= 0 && gamma > Math.PI) {
			f7 = gamma;
		} else {
			var a7 = gamma % (2 * Math.PI);
			f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
		}
		var this10 = f7;
		var zb3 = this10;
		var fa3 = beta;
		var fb3 = gamma;
		var theta3 = Math.abs(beta - gamma);
		var largest = theta3 > Math.PI;
		var clockwise3 = beta < gamma;
		var dif4 = clockwise3 ? theta3 : -theta3;
		dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
		break;
	}
	var positive = dif >= 0;
	var totalSteps = Math.ceil(Math.abs(dif) / step);
	var step1 = dif / totalSteps;
	var angle = beta;
	var cx;
	var cy;
	var bx = 0;
	var by = 0;
	var p2 = edgePoly.length;
	var _g = 0;
	var _g1 = totalSteps + 1;
	while(_g < _g1) {
		var i = _g++;
		cx = ax + radius * Math.sin(angle);
		cy = ay + radius * Math.cos(angle);
		edgePoly[p2++] = cx;
		edgePoly[p2++] = cy;
		if(i != 0) {
			var t1 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
			out[out.length] = t1;
			if(mark != 0) {
				t1.mark = mark;
			}
		}
		angle += step1;
		bx = cx;
		by = cy;
	}
	return out;
};
trilateral_polys_Poly.ellpisePie = function(ax,ay,rx,ry,beta,gamma,prefer,mark,sides) {
	if(sides == null) {
		sides = 36;
	}
	if(mark == null) {
		mark = 0;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var step = pi * 2 / sides;
	var dif;
	switch(prefer._hx_index) {
	case 0:
		var f;
		if(beta >= 0 && beta > Math.PI) {
			f = beta;
		} else {
			var a = beta % (2 * Math.PI);
			f = a >= 0 ? a : a + 2 * Math.PI;
		}
		var this3 = f;
		var za = this3;
		var f1;
		if(gamma >= 0 && gamma > Math.PI) {
			f1 = gamma;
		} else {
			var a1 = gamma % (2 * Math.PI);
			f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this4 = f1;
		var zb = this4;
		var fa = za;
		var fb = zb;
		var theta = Math.abs(beta - gamma);
		var clockwise = beta < gamma;
		var dif1 = clockwise ? theta : -theta;
		dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
		break;
	case 1:
		var f2;
		if(beta >= 0 && beta > Math.PI) {
			f2 = beta;
		} else {
			var a2 = beta % (2 * Math.PI);
			f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
		}
		var this5 = f2;
		var za1 = this5;
		var f3;
		if(gamma >= 0 && gamma > Math.PI) {
			f3 = gamma;
		} else {
			var a3 = gamma % (2 * Math.PI);
			f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
		}
		var this6 = f3;
		var zb1 = this6;
		var fa1 = za1;
		var fb1 = zb1;
		var theta1 = Math.abs(beta - gamma);
		var clockwise1 = beta < gamma;
		var dif2 = clockwise1 ? theta1 : -theta1;
		dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
		break;
	case 2:
		var f4;
		if(beta >= 0 && beta > Math.PI) {
			f4 = beta;
		} else {
			var a4 = beta % (2 * Math.PI);
			f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
		}
		var this7 = f4;
		var za2 = this7;
		var f5;
		if(gamma >= 0 && gamma > Math.PI) {
			f5 = gamma;
		} else {
			var a5 = gamma % (2 * Math.PI);
			f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
		}
		var this8 = f5;
		var zb2 = this8;
		var fa2 = beta;
		var fb2 = gamma;
		var theta2 = Math.abs(beta - gamma);
		var smallest = theta2 <= Math.PI;
		var clockwise2 = beta < gamma;
		var dif3 = clockwise2 ? theta2 : -theta2;
		dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
		break;
	case 3:
		var f6;
		if(beta >= 0 && beta > Math.PI) {
			f6 = beta;
		} else {
			var a6 = beta % (2 * Math.PI);
			f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
		}
		var this9 = f6;
		var za3 = this9;
		var f7;
		if(gamma >= 0 && gamma > Math.PI) {
			f7 = gamma;
		} else {
			var a7 = gamma % (2 * Math.PI);
			f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
		}
		var this10 = f7;
		var zb3 = this10;
		var fa3 = beta;
		var fb3 = gamma;
		var theta3 = Math.abs(beta - gamma);
		var largest = theta3 > Math.PI;
		var clockwise3 = beta < gamma;
		var dif4 = clockwise3 ? theta3 : -theta3;
		dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
		break;
	}
	var positive = dif >= 0;
	var totalSteps = Math.ceil(Math.abs(dif) / step);
	var step1 = dif / totalSteps;
	var angle = beta;
	var cx;
	var cy;
	var bx = 0;
	var by = 0;
	var _g = 0;
	var _g1 = totalSteps + 1;
	while(_g < _g1) {
		var i = _g++;
		cx = ax + rx * Math.sin(angle);
		cy = ay + ry * Math.cos(angle);
		if(i != 0) {
			var t1 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
			out[out.length] = t1;
			if(mark != 0) {
				t1.mark = mark;
			}
		}
		angle += step1;
		bx = cx;
		by = cy;
	}
	return out;
};
trilateral_polys_Poly.pieDif = function(ax,ay,radius,beta,dif,mark,sides) {
	if(sides == null) {
		sides = 36;
	}
	if(mark == null) {
		mark = 0;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var step = pi * 2 / sides;
	var positive = dif >= 0;
	var totalSteps = Math.ceil(Math.abs(dif) / step);
	var step1 = dif / totalSteps;
	var angle = beta;
	var cx;
	var cy;
	var bx = 0;
	var by = 0;
	var _g = 0;
	var _g1 = totalSteps + 1;
	while(_g < _g1) {
		var i = _g++;
		cx = ax + radius * Math.sin(angle);
		cy = ay + radius * Math.cos(angle);
		if(i != 0) {
			var t1 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
			out[out.length] = t1;
			if(mark != 0) {
				t1.mark = mark;
			}
		}
		angle += step1;
		bx = cx;
		by = cy;
	}
	return out;
};
trilateral_polys_Poly.pieDifX = function(ax,ay,radius,beta,dif,edgePoly,mark,sides) {
	if(sides == null) {
		sides = 36;
	}
	if(mark == null) {
		mark = 0;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var step = pi * 2 / sides;
	var positive = dif >= 0;
	var totalSteps = Math.ceil(Math.abs(dif) / step);
	var step1 = dif / totalSteps;
	var angle = beta;
	var cx;
	var cy;
	var bx = 0;
	var by = 0;
	var p2 = edgePoly.length;
	var count = 0;
	var _g = 0;
	var _g1 = totalSteps + 1;
	while(_g < _g1) {
		var i = _g++;
		cx = ax + radius * Math.sin(angle);
		cy = ay + radius * Math.cos(angle);
		if(i != 0) {
			var t1 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
			out[out.length] = t1;
			if(mark != 0) {
				t1.mark = mark;
			}
			edgePoly[p2++] = cx;
			edgePoly[p2++] = cy;
		}
		angle += step1;
		bx = cx;
		by = cy;
	}
	return out;
};
trilateral_polys_Poly.arc = function(ax,ay,radius,width,beta,gamma,prefer,mark,sides) {
	if(sides == null) {
		sides = 36;
	}
	if(mark == null) {
		mark = 0;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var step = pi * 2 / sides;
	var dif;
	switch(prefer._hx_index) {
	case 0:
		var f;
		if(beta >= 0 && beta > Math.PI) {
			f = beta;
		} else {
			var a = beta % (2 * Math.PI);
			f = a >= 0 ? a : a + 2 * Math.PI;
		}
		var this3 = f;
		var za = this3;
		var f1;
		if(gamma >= 0 && gamma > Math.PI) {
			f1 = gamma;
		} else {
			var a1 = gamma % (2 * Math.PI);
			f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this4 = f1;
		var zb = this4;
		var fa = za;
		var fb = zb;
		var theta = Math.abs(beta - gamma);
		var clockwise = beta < gamma;
		var dif1 = clockwise ? theta : -theta;
		dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
		break;
	case 1:
		var f2;
		if(beta >= 0 && beta > Math.PI) {
			f2 = beta;
		} else {
			var a2 = beta % (2 * Math.PI);
			f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
		}
		var this5 = f2;
		var za1 = this5;
		var f3;
		if(gamma >= 0 && gamma > Math.PI) {
			f3 = gamma;
		} else {
			var a3 = gamma % (2 * Math.PI);
			f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
		}
		var this6 = f3;
		var zb1 = this6;
		var fa1 = za1;
		var fb1 = zb1;
		var theta1 = Math.abs(beta - gamma);
		var clockwise1 = beta < gamma;
		var dif2 = clockwise1 ? theta1 : -theta1;
		dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
		break;
	case 2:
		var f4;
		if(beta >= 0 && beta > Math.PI) {
			f4 = beta;
		} else {
			var a4 = beta % (2 * Math.PI);
			f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
		}
		var this7 = f4;
		var za2 = this7;
		var f5;
		if(gamma >= 0 && gamma > Math.PI) {
			f5 = gamma;
		} else {
			var a5 = gamma % (2 * Math.PI);
			f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
		}
		var this8 = f5;
		var zb2 = this8;
		var fa2 = beta;
		var fb2 = gamma;
		var theta2 = Math.abs(beta - gamma);
		var smallest = theta2 <= Math.PI;
		var clockwise2 = beta < gamma;
		var dif3 = clockwise2 ? theta2 : -theta2;
		dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
		break;
	case 3:
		var f6;
		if(beta >= 0 && beta > Math.PI) {
			f6 = beta;
		} else {
			var a6 = beta % (2 * Math.PI);
			f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
		}
		var this9 = f6;
		var za3 = this9;
		var f7;
		if(gamma >= 0 && gamma > Math.PI) {
			f7 = gamma;
		} else {
			var a7 = gamma % (2 * Math.PI);
			f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
		}
		var this10 = f7;
		var zb3 = this10;
		var fa3 = beta;
		var fb3 = gamma;
		var theta3 = Math.abs(beta - gamma);
		var largest = theta3 > Math.PI;
		var clockwise3 = beta < gamma;
		var dif4 = clockwise3 ? theta3 : -theta3;
		dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
		break;
	}
	var positive = dif >= 0;
	var totalSteps = Math.ceil(Math.abs(dif) / step);
	var step1 = dif / totalSteps;
	var angle = beta;
	var cx;
	var cy;
	var bx = 0;
	var by = 0;
	var dx = 0;
	var dy = 0;
	var ex = 0;
	var ey = 0;
	var r2 = radius - width;
	var _g = 0;
	var _g1 = totalSteps + 1;
	while(_g < _g1) {
		var i = _g++;
		cx = ax + radius * Math.sin(angle);
		cy = ay + radius * Math.cos(angle);
		ex = ax + r2 * Math.sin(angle);
		ey = ay + r2 * Math.cos(angle);
		if(i != 0) {
			var t0 = new trilateral_tri_Trilateral(dx,dy,bx,by,cx,cy);
			var t1 = new trilateral_tri_Trilateral(dx,dy,cx,cy,ex,ey);
			out[out.length] = t0;
			out[out.length] = t1;
			if(mark != 0) {
				t0.mark = mark;
				t1.mark = mark;
			}
		}
		angle += step1;
		bx = cx;
		by = cy;
		dx = ex;
		dy = ey;
	}
	return out;
};
trilateral_polys_Poly.circleMarked = function(ax,ay,radius,mark,sides,omega) {
	if(omega == null) {
		omega = 0.;
	}
	if(sides == null) {
		sides = 36;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var theta = pi / 2 + omega;
	var step = pi * 2 / sides;
	var bx;
	var by;
	var cx;
	var cy;
	var _g = 0;
	var _g1 = sides;
	while(_g < _g1) {
		var i = _g++;
		bx = ax + radius * Math.sin(theta);
		by = ay + radius * Math.cos(theta);
		theta += step;
		cx = ax + radius * Math.sin(theta);
		cy = ay + radius * Math.cos(theta);
		var t1 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
		out[out.length] = t1;
		t1.mark = mark;
	}
	return out;
};
trilateral_polys_Poly.circleOnSide = function(ax,ay,radius,sides,omega) {
	if(omega == null) {
		omega = 0.;
	}
	if(sides == null) {
		sides = 36;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var theta = pi / 2;
	var step = pi * 2 / sides;
	theta -= step / 2 + omega;
	var bx;
	var by;
	var cx;
	var cy;
	var _g = 0;
	var _g1 = sides;
	while(_g < _g1) {
		var i = _g++;
		bx = ax + radius * Math.sin(theta);
		by = ay + radius * Math.cos(theta);
		theta += step;
		cx = ax + radius * Math.sin(theta);
		cy = ay + radius * Math.cos(theta);
		var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
		out[out.length] = tri;
	}
	return out;
};
trilateral_polys_Poly.ellipseOnSide = function(ax,ay,rx,ry,sides) {
	if(sides == null) {
		sides = 36;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var theta = pi / 2;
	var step = pi * 2 / sides;
	theta -= step / 2;
	var bx;
	var by;
	var cx;
	var cy;
	var _g = 0;
	var _g1 = sides;
	while(_g < _g1) {
		var i = _g++;
		bx = ax + rx * Math.sin(theta);
		by = ay + rx * Math.cos(theta);
		theta += step;
		cx = ax + rx * Math.sin(theta);
		cy = ay + ry * Math.cos(theta);
		var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
		out[out.length] = tri;
	}
	return out;
};
trilateral_polys_Poly.shape = function(x,y,radius,p,omega) {
	if(omega == null) {
		omega = 0.;
	}
	if((p & 1) == 0) {
		var t = [];
		var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
		var this2 = this1;
		var out = this2;
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / p;
		theta -= step / 2 + omega;
		var bx;
		var by;
		var cx;
		var cy;
		var _g = 0;
		var _g1 = p;
		while(_g < _g1) {
			var i = _g++;
			bx = x + radius * Math.sin(theta);
			by = y + radius * Math.cos(theta);
			theta += step;
			cx = x + radius * Math.sin(theta);
			cy = y + radius * Math.cos(theta);
			var tri = new trilateral_tri_Trilateral(x,y,bx,by,cx,cy);
			out[out.length] = tri;
		}
		return out;
	} else {
		var t1 = [];
		var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
		var this4 = this3;
		var out1 = this4;
		var pi1 = Math.PI;
		var theta1 = pi1 / 2 + omega;
		var step1 = pi1 * 2 / p;
		var bx1;
		var by1;
		var cx1;
		var cy1;
		var _g2 = 0;
		var _g11 = p;
		while(_g2 < _g11) {
			var i1 = _g2++;
			bx1 = x + radius * Math.sin(theta1);
			by1 = y + radius * Math.cos(theta1);
			theta1 += step1;
			cx1 = x + radius * Math.sin(theta1);
			cy1 = y + radius * Math.cos(theta1);
			var tri1 = new trilateral_tri_Trilateral(x,y,bx1,by1,cx1,cy1);
			out1[out1.length] = tri1;
		}
		return out1;
	}
};
trilateral_polys_Poly.roundedRectangle = function(x,y,width,height,radius) {
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var pi_2 = Math.PI / 2;
	var ax = x + radius;
	var ay = y + radius;
	var bx = x + width - radius;
	var by = y + radius;
	var cx = bx;
	var cy = y + height - radius;
	var dx = ax;
	var dy = cy;
	var ax1 = ax;
	var ay1 = y;
	var bx1 = ax + (width - radius * 2);
	var by1 = ay1;
	var cx1 = bx1;
	var cy1 = ay1 + height;
	var dx1 = ax;
	var dy1 = cy1;
	var tp_t0 = new trilateral_tri_Trilateral(ax1,ay1,bx1,by1,dx1,dy1);
	var tp_t1 = new trilateral_tri_Trilateral(bx1,by1,cx1,cy1,dx1,dy1);
	out[out.length] = tp_t0;
	out[out.length] = tp_t1;
	var dimY = height - 2 * radius;
	var ax2 = x;
	var ay2 = ay;
	var bx2 = x + radius;
	var by2 = ay2;
	var cx2 = bx2;
	var cy2 = ay2 + dimY;
	var dx2 = x;
	var dy2 = cy2;
	var tp_t01 = new trilateral_tri_Trilateral(ax2,ay2,bx2,by2,dx2,dy2);
	var tp_t11 = new trilateral_tri_Trilateral(bx2,by2,cx2,cy2,dx2,dy2);
	out[out.length] = tp_t01;
	out[out.length] = tp_t11;
	var ax3 = bx;
	var ay3 = by;
	var bx3 = bx + radius;
	var by3 = ay3;
	var cx3 = bx3;
	var cy3 = ay3 + dimY;
	var dx3 = bx;
	var dy3 = cy3;
	var tp_t02 = new trilateral_tri_Trilateral(ax3,ay3,bx3,by3,dx3,dy3);
	var tp_t12 = new trilateral_tri_Trilateral(bx3,by3,cx3,cy3,dx3,dy3);
	out[out.length] = tp_t02;
	out[out.length] = tp_t12;
	var beta = -pi;
	var gamma = -pi_2;
	var t1 = [];
	var this3;
	if(t1 == null) {
		var t2 = [];
		var this4 = t2 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t2;
		this3 = this4;
	} else {
		this3 = t1;
	}
	var this5 = this3;
	var out1 = this5;
	var pi1 = Math.PI;
	var step = pi1 * 2 / 36;
	var dif;
	switch(trilateral_angle_DifferencePreference.CLOCKWISE._hx_index) {
	case 0:
		var f;
		if(beta >= 0 && beta > Math.PI) {
			f = beta;
		} else {
			var a = beta % (2 * Math.PI);
			f = a >= 0 ? a : a + 2 * Math.PI;
		}
		var this6 = f;
		var za = this6;
		var f1;
		if(gamma >= 0 && gamma > Math.PI) {
			f1 = gamma;
		} else {
			var a1 = gamma % (2 * Math.PI);
			f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this7 = f1;
		var zb = this7;
		var fa = za;
		var fb = zb;
		var theta = Math.abs(beta - gamma);
		var clockwise = beta < gamma;
		var dif1 = clockwise ? theta : -theta;
		dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
		break;
	case 1:
		var f2;
		if(beta >= 0 && beta > Math.PI) {
			f2 = beta;
		} else {
			var a2 = beta % (2 * Math.PI);
			f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
		}
		var this8 = f2;
		var za1 = this8;
		var f3;
		if(gamma >= 0 && gamma > Math.PI) {
			f3 = gamma;
		} else {
			var a3 = gamma % (2 * Math.PI);
			f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
		}
		var this9 = f3;
		var zb1 = this9;
		var fa1 = za1;
		var fb1 = zb1;
		var theta1 = Math.abs(beta - gamma);
		var clockwise1 = beta < gamma;
		var dif2 = clockwise1 ? theta1 : -theta1;
		dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
		break;
	case 2:
		var f4;
		if(beta >= 0 && beta > Math.PI) {
			f4 = beta;
		} else {
			var a4 = beta % (2 * Math.PI);
			f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
		}
		var this10 = f4;
		var za2 = this10;
		var f5;
		if(gamma >= 0 && gamma > Math.PI) {
			f5 = gamma;
		} else {
			var a5 = gamma % (2 * Math.PI);
			f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
		}
		var this11 = f5;
		var zb2 = this11;
		var fa2 = beta;
		var fb2 = gamma;
		var theta2 = Math.abs(beta - gamma);
		var smallest = theta2 <= Math.PI;
		var clockwise2 = beta < gamma;
		var dif3 = clockwise2 ? theta2 : -theta2;
		dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
		break;
	case 3:
		var f6;
		if(beta >= 0 && beta > Math.PI) {
			f6 = beta;
		} else {
			var a6 = beta % (2 * Math.PI);
			f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
		}
		var this12 = f6;
		var za3 = this12;
		var f7;
		if(gamma >= 0 && gamma > Math.PI) {
			f7 = gamma;
		} else {
			var a7 = gamma % (2 * Math.PI);
			f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
		}
		var this13 = f7;
		var zb3 = this13;
		var fa3 = beta;
		var fb3 = gamma;
		var theta3 = Math.abs(beta - gamma);
		var largest = theta3 > Math.PI;
		var clockwise3 = beta < gamma;
		var dif4 = clockwise3 ? theta3 : -theta3;
		dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
		break;
	}
	var positive = dif >= 0;
	var totalSteps = Math.ceil(Math.abs(dif) / step);
	var step1 = dif / totalSteps;
	var angle = beta;
	var cx4;
	var cy4;
	var bx4 = 0;
	var by4 = 0;
	var _g = 0;
	var _g1 = totalSteps + 1;
	while(_g < _g1) {
		var i = _g++;
		cx4 = ax + radius * Math.sin(angle);
		cy4 = ay + radius * Math.cos(angle);
		if(i != 0) {
			var t3 = new trilateral_tri_Trilateral(ax,ay,bx4,by4,cx4,cy4);
			out1[out1.length] = t3;
		}
		angle += step1;
		bx4 = cx4;
		by4 = cy4;
	}
	var triArr = out1;
	var _g2 = 0;
	while(_g2 < triArr.length) {
		var t4 = triArr[_g2];
		++_g2;
		out[out.length] = t4;
	}
	var t5 = [];
	var this14;
	if(t5 == null) {
		var t6 = [];
		var this15 = t6 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t6;
		this14 = this15;
	} else {
		this14 = t5;
	}
	var this16 = this14;
	var out2 = this16;
	var pi2 = Math.PI;
	var step2 = pi2 * 2 / 36;
	var dif5;
	switch(trilateral_angle_DifferencePreference.CLOCKWISE._hx_index) {
	case 0:
		var f8;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f8 = pi_2;
		} else {
			var a8 = pi_2 % (2 * Math.PI);
			f8 = a8 >= 0 ? a8 : a8 + 2 * Math.PI;
		}
		var this17 = f8;
		var za4 = this17;
		var f9;
		if(pi >= 0 && pi > Math.PI) {
			f9 = pi;
		} else {
			var a9 = pi % (2 * Math.PI);
			f9 = a9 >= 0 ? a9 : a9 + 2 * Math.PI;
		}
		var this18 = f9;
		var zb4 = this18;
		var fa4 = za4;
		var fb4 = zb4;
		var theta4 = Math.abs(pi_2 - pi);
		var clockwise4 = pi_2 < pi;
		var dif6 = clockwise4 ? theta4 : -theta4;
		dif5 = dif6 > 0 ? dif6 : 2 * Math.PI + dif6;
		break;
	case 1:
		var f10;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f10 = pi_2;
		} else {
			var a10 = pi_2 % (2 * Math.PI);
			f10 = a10 >= 0 ? a10 : a10 + 2 * Math.PI;
		}
		var this19 = f10;
		var za5 = this19;
		var f11;
		if(pi >= 0 && pi > Math.PI) {
			f11 = pi;
		} else {
			var a11 = pi % (2 * Math.PI);
			f11 = a11 >= 0 ? a11 : a11 + 2 * Math.PI;
		}
		var this20 = f11;
		var zb5 = this20;
		var fa5 = za5;
		var fb5 = zb5;
		var theta5 = Math.abs(pi_2 - pi);
		var clockwise5 = pi_2 < pi;
		var dif7 = clockwise5 ? theta5 : -theta5;
		dif5 = dif7 < 0 ? dif7 : -2 * Math.PI + dif7;
		break;
	case 2:
		var f12;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f12 = pi_2;
		} else {
			var a12 = pi_2 % (2 * Math.PI);
			f12 = a12 >= 0 ? a12 : a12 + 2 * Math.PI;
		}
		var this21 = f12;
		var za6 = this21;
		var f13;
		if(pi >= 0 && pi > Math.PI) {
			f13 = pi;
		} else {
			var a13 = pi % (2 * Math.PI);
			f13 = a13 >= 0 ? a13 : a13 + 2 * Math.PI;
		}
		var this22 = f13;
		var zb6 = this22;
		var fa6 = pi_2;
		var fb6 = pi;
		var theta6 = Math.abs(pi_2 - pi);
		var smallest1 = theta6 <= Math.PI;
		var clockwise6 = pi_2 < pi;
		var dif8 = clockwise6 ? theta6 : -theta6;
		dif5 = smallest1 ? dif8 : clockwise6 ? -(2 * Math.PI - theta6) : 2 * Math.PI - theta6;
		break;
	case 3:
		var f14;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f14 = pi_2;
		} else {
			var a14 = pi_2 % (2 * Math.PI);
			f14 = a14 >= 0 ? a14 : a14 + 2 * Math.PI;
		}
		var this23 = f14;
		var za7 = this23;
		var f15;
		if(pi >= 0 && pi > Math.PI) {
			f15 = pi;
		} else {
			var a15 = pi % (2 * Math.PI);
			f15 = a15 >= 0 ? a15 : a15 + 2 * Math.PI;
		}
		var this24 = f15;
		var zb7 = this24;
		var fa7 = pi_2;
		var fb7 = pi;
		var theta7 = Math.abs(pi_2 - pi);
		var largest1 = theta7 > Math.PI;
		var clockwise7 = pi_2 < pi;
		var dif9 = clockwise7 ? theta7 : -theta7;
		dif5 = largest1 ? dif9 : clockwise7 ? -(2 * Math.PI - theta7) : 2 * Math.PI - theta7;
		break;
	}
	var positive1 = dif5 >= 0;
	var totalSteps1 = Math.ceil(Math.abs(dif5) / step2);
	var step3 = dif5 / totalSteps1;
	var angle1 = pi_2;
	var cx5;
	var cy5;
	var bx5 = 0;
	var by5 = 0;
	var _g3 = 0;
	var _g11 = totalSteps1 + 1;
	while(_g3 < _g11) {
		var i1 = _g3++;
		cx5 = bx + radius * Math.sin(angle1);
		cy5 = by + radius * Math.cos(angle1);
		if(i1 != 0) {
			var t7 = new trilateral_tri_Trilateral(bx,by,bx5,by5,cx5,cy5);
			out2[out2.length] = t7;
		}
		angle1 += step3;
		bx5 = cx5;
		by5 = cy5;
	}
	var triArr1 = out2;
	var _g4 = 0;
	while(_g4 < triArr1.length) {
		var t8 = triArr1[_g4];
		++_g4;
		out[out.length] = t8;
	}
	var t9 = [];
	var this25;
	if(t9 == null) {
		var t10 = [];
		var this26 = t10 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t10;
		this25 = this26;
	} else {
		this25 = t9;
	}
	var this27 = this25;
	var out3 = this27;
	var pi3 = Math.PI;
	var step4 = pi3 * 2 / 36;
	var dif10;
	switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE._hx_index) {
	case 0:
		var f16;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f16 = pi_2;
		} else {
			var a16 = pi_2 % (2 * Math.PI);
			f16 = a16 >= 0 ? a16 : a16 + 2 * Math.PI;
		}
		var this28 = f16;
		var za8 = this28;
		var f17;
		if(0 > Math.PI) {
			f17 = 0;
		} else {
			var a17 = 0 % (2 * Math.PI);
			f17 = a17 >= 0 ? a17 : a17 + 2 * Math.PI;
		}
		var this29 = f17;
		var zb8 = this29;
		var fa8 = za8;
		var fb8 = zb8;
		var theta8 = Math.abs(pi_2);
		var clockwise8 = pi_2 < 0;
		var dif11 = clockwise8 ? theta8 : -theta8;
		dif10 = dif11 > 0 ? dif11 : 2 * Math.PI + dif11;
		break;
	case 1:
		var f18;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f18 = pi_2;
		} else {
			var a18 = pi_2 % (2 * Math.PI);
			f18 = a18 >= 0 ? a18 : a18 + 2 * Math.PI;
		}
		var this30 = f18;
		var za9 = this30;
		var f19;
		if(0 > Math.PI) {
			f19 = 0;
		} else {
			var a19 = 0 % (2 * Math.PI);
			f19 = a19 >= 0 ? a19 : a19 + 2 * Math.PI;
		}
		var this31 = f19;
		var zb9 = this31;
		var fa9 = za9;
		var fb9 = zb9;
		var theta9 = Math.abs(pi_2);
		var clockwise9 = pi_2 < 0;
		var dif12 = clockwise9 ? theta9 : -theta9;
		dif10 = dif12 < 0 ? dif12 : -2 * Math.PI + dif12;
		break;
	case 2:
		var f20;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f20 = pi_2;
		} else {
			var a20 = pi_2 % (2 * Math.PI);
			f20 = a20 >= 0 ? a20 : a20 + 2 * Math.PI;
		}
		var this32 = f20;
		var za10 = this32;
		var f21;
		if(0 > Math.PI) {
			f21 = 0;
		} else {
			var a21 = 0 % (2 * Math.PI);
			f21 = a21 >= 0 ? a21 : a21 + 2 * Math.PI;
		}
		var this33 = f21;
		var zb10 = this33;
		var fa10 = pi_2;
		var fb10 = 0;
		var theta10 = Math.abs(pi_2);
		var smallest2 = theta10 <= Math.PI;
		var clockwise10 = pi_2 < 0;
		var dif13 = clockwise10 ? theta10 : -theta10;
		dif10 = smallest2 ? dif13 : clockwise10 ? -(2 * Math.PI - theta10) : 2 * Math.PI - theta10;
		break;
	case 3:
		var f22;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f22 = pi_2;
		} else {
			var a22 = pi_2 % (2 * Math.PI);
			f22 = a22 >= 0 ? a22 : a22 + 2 * Math.PI;
		}
		var this34 = f22;
		var za11 = this34;
		var f23;
		if(0 > Math.PI) {
			f23 = 0;
		} else {
			var a23 = 0 % (2 * Math.PI);
			f23 = a23 >= 0 ? a23 : a23 + 2 * Math.PI;
		}
		var this35 = f23;
		var zb11 = this35;
		var fa11 = pi_2;
		var fb11 = 0;
		var theta11 = Math.abs(pi_2);
		var largest2 = theta11 > Math.PI;
		var clockwise11 = pi_2 < 0;
		var dif14 = clockwise11 ? theta11 : -theta11;
		dif10 = largest2 ? dif14 : clockwise11 ? -(2 * Math.PI - theta11) : 2 * Math.PI - theta11;
		break;
	}
	var positive2 = dif10 >= 0;
	var totalSteps2 = Math.ceil(Math.abs(dif10) / step4);
	var step5 = dif10 / totalSteps2;
	var angle2 = pi_2;
	var cx6;
	var cy6;
	var bx6 = 0;
	var by6 = 0;
	var _g5 = 0;
	var _g12 = totalSteps2 + 1;
	while(_g5 < _g12) {
		var i2 = _g5++;
		cx6 = cx + radius * Math.sin(angle2);
		cy6 = cy + radius * Math.cos(angle2);
		if(i2 != 0) {
			var t11 = new trilateral_tri_Trilateral(cx,cy,bx6,by6,cx6,cy6);
			out3[out3.length] = t11;
		}
		angle2 += step5;
		bx6 = cx6;
		by6 = cy6;
	}
	var triArr2 = out3;
	var _g6 = 0;
	while(_g6 < triArr2.length) {
		var t12 = triArr2[_g6];
		++_g6;
		out[out.length] = t12;
	}
	var gamma1 = -pi_2;
	var t13 = [];
	var this36;
	if(t13 == null) {
		var t14 = [];
		var this37 = t14 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t14;
		this36 = this37;
	} else {
		this36 = t13;
	}
	var this38 = this36;
	var out4 = this38;
	var pi4 = Math.PI;
	var step6 = pi4 * 2 / 36;
	var dif15;
	switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE._hx_index) {
	case 0:
		var f24;
		if(0 > Math.PI) {
			f24 = 0;
		} else {
			var a24 = 0 % (2 * Math.PI);
			f24 = a24 >= 0 ? a24 : a24 + 2 * Math.PI;
		}
		var this39 = f24;
		var za12 = this39;
		var f25;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f25 = gamma1;
		} else {
			var a25 = gamma1 % (2 * Math.PI);
			f25 = a25 >= 0 ? a25 : a25 + 2 * Math.PI;
		}
		var this40 = f25;
		var zb12 = this40;
		var fa12 = za12;
		var fb12 = zb12;
		var theta12 = Math.abs(0 - gamma1);
		var clockwise12 = 0 < gamma1;
		var dif16 = clockwise12 ? theta12 : -theta12;
		dif15 = dif16 > 0 ? dif16 : 2 * Math.PI + dif16;
		break;
	case 1:
		var f26;
		if(0 > Math.PI) {
			f26 = 0;
		} else {
			var a26 = 0 % (2 * Math.PI);
			f26 = a26 >= 0 ? a26 : a26 + 2 * Math.PI;
		}
		var this41 = f26;
		var za13 = this41;
		var f27;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f27 = gamma1;
		} else {
			var a27 = gamma1 % (2 * Math.PI);
			f27 = a27 >= 0 ? a27 : a27 + 2 * Math.PI;
		}
		var this42 = f27;
		var zb13 = this42;
		var fa13 = za13;
		var fb13 = zb13;
		var theta13 = Math.abs(0 - gamma1);
		var clockwise13 = 0 < gamma1;
		var dif17 = clockwise13 ? theta13 : -theta13;
		dif15 = dif17 < 0 ? dif17 : -2 * Math.PI + dif17;
		break;
	case 2:
		var f28;
		if(0 > Math.PI) {
			f28 = 0;
		} else {
			var a28 = 0 % (2 * Math.PI);
			f28 = a28 >= 0 ? a28 : a28 + 2 * Math.PI;
		}
		var this43 = f28;
		var za14 = this43;
		var f29;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f29 = gamma1;
		} else {
			var a29 = gamma1 % (2 * Math.PI);
			f29 = a29 >= 0 ? a29 : a29 + 2 * Math.PI;
		}
		var this44 = f29;
		var zb14 = this44;
		var fa14 = 0;
		var fb14 = gamma1;
		var theta14 = Math.abs(0 - gamma1);
		var smallest3 = theta14 <= Math.PI;
		var clockwise14 = 0 < gamma1;
		var dif18 = clockwise14 ? theta14 : -theta14;
		dif15 = smallest3 ? dif18 : clockwise14 ? -(2 * Math.PI - theta14) : 2 * Math.PI - theta14;
		break;
	case 3:
		var f30;
		if(0 > Math.PI) {
			f30 = 0;
		} else {
			var a30 = 0 % (2 * Math.PI);
			f30 = a30 >= 0 ? a30 : a30 + 2 * Math.PI;
		}
		var this45 = f30;
		var za15 = this45;
		var f31;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f31 = gamma1;
		} else {
			var a31 = gamma1 % (2 * Math.PI);
			f31 = a31 >= 0 ? a31 : a31 + 2 * Math.PI;
		}
		var this46 = f31;
		var zb15 = this46;
		var fa15 = 0;
		var fb15 = gamma1;
		var theta15 = Math.abs(0 - gamma1);
		var largest3 = theta15 > Math.PI;
		var clockwise15 = 0 < gamma1;
		var dif19 = clockwise15 ? theta15 : -theta15;
		dif15 = largest3 ? dif19 : clockwise15 ? -(2 * Math.PI - theta15) : 2 * Math.PI - theta15;
		break;
	}
	var positive3 = dif15 >= 0;
	var totalSteps3 = Math.ceil(Math.abs(dif15) / step6);
	var step7 = dif15 / totalSteps3;
	var angle3 = 0;
	var cx7;
	var cy7;
	var bx7 = 0;
	var by7 = 0;
	var _g7 = 0;
	var _g13 = totalSteps3 + 1;
	while(_g7 < _g13) {
		var i3 = _g7++;
		cx7 = dx + radius * Math.sin(angle3);
		cy7 = dy + radius * Math.cos(angle3);
		if(i3 != 0) {
			var t15 = new trilateral_tri_Trilateral(dx,dy,bx7,by7,cx7,cy7);
			out4[out4.length] = t15;
		}
		angle3 += step7;
		bx7 = cx7;
		by7 = cy7;
	}
	var triArr3 = out4;
	var _g8 = 0;
	while(_g8 < triArr3.length) {
		var t16 = triArr3[_g8];
		++_g8;
		out[out.length] = t16;
	}
	return out;
};
trilateral_polys_Poly.roundedRectangleOutline = function(x,y,width,height,thick,radius) {
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var pi_2 = Math.PI / 2;
	var ax = x + radius;
	var ay = y + radius;
	var bx = x + width - radius;
	var by = y + radius;
	var cx = bx;
	var cy = y + height - radius;
	var dx = ax;
	var dy = cy;
	var ax1 = ax;
	var ay1 = y;
	var bx1 = ax + (width - radius * 2);
	var by1 = ay1;
	var cx1 = bx1;
	var cy1 = ay1 + thick;
	var dx1 = ax;
	var dy1 = cy1;
	var tp_t0 = new trilateral_tri_Trilateral(ax1,ay1,bx1,by1,dx1,dy1);
	var tp_t1 = new trilateral_tri_Trilateral(bx1,by1,cx1,cy1,dx1,dy1);
	out[out.length] = tp_t0;
	out[out.length] = tp_t1;
	var ax2 = ax;
	var ay2 = y + height - thick;
	var bx2 = ax + (width - radius * 2);
	var by2 = ay2;
	var cx2 = bx2;
	var cy2 = ay2 + thick;
	var dx2 = ax;
	var dy2 = cy2;
	var tp_t01 = new trilateral_tri_Trilateral(ax2,ay2,bx2,by2,dx2,dy2);
	var tp_t11 = new trilateral_tri_Trilateral(bx2,by2,cx2,cy2,dx2,dy2);
	out[out.length] = tp_t01;
	out[out.length] = tp_t11;
	var dimY = height - 2 * radius;
	var ax3 = x;
	var ay3 = ay;
	var bx3 = x + thick;
	var by3 = ay3;
	var cx3 = bx3;
	var cy3 = ay3 + dimY;
	var dx3 = x;
	var dy3 = cy3;
	var tp_t02 = new trilateral_tri_Trilateral(ax3,ay3,bx3,by3,dx3,dy3);
	var tp_t12 = new trilateral_tri_Trilateral(bx3,by3,cx3,cy3,dx3,dy3);
	out[out.length] = tp_t02;
	out[out.length] = tp_t12;
	var x1 = x + width - thick;
	var ax4 = x1;
	var ay4 = by;
	var bx4 = x1 + thick;
	var by4 = ay4;
	var cx4 = bx4;
	var cy4 = ay4 + dimY;
	var dx4 = x1;
	var dy4 = cy4;
	var tp_t03 = new trilateral_tri_Trilateral(ax4,ay4,bx4,by4,dx4,dy4);
	var tp_t13 = new trilateral_tri_Trilateral(bx4,by4,cx4,cy4,dx4,dy4);
	out[out.length] = tp_t03;
	out[out.length] = tp_t13;
	var beta = -pi;
	var gamma = -pi_2;
	var t1 = [];
	var this3;
	if(t1 == null) {
		var t2 = [];
		var this4 = t2 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t2;
		this3 = this4;
	} else {
		this3 = t1;
	}
	var this5 = this3;
	var out1 = this5;
	var pi1 = Math.PI;
	var step = pi1 * 2 / 36;
	var dif;
	switch(trilateral_angle_DifferencePreference.CLOCKWISE._hx_index) {
	case 0:
		var f;
		if(beta >= 0 && beta > Math.PI) {
			f = beta;
		} else {
			var a = beta % (2 * Math.PI);
			f = a >= 0 ? a : a + 2 * Math.PI;
		}
		var this6 = f;
		var za = this6;
		var f1;
		if(gamma >= 0 && gamma > Math.PI) {
			f1 = gamma;
		} else {
			var a1 = gamma % (2 * Math.PI);
			f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this7 = f1;
		var zb = this7;
		var fa = za;
		var fb = zb;
		var theta = Math.abs(beta - gamma);
		var clockwise = beta < gamma;
		var dif1 = clockwise ? theta : -theta;
		dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
		break;
	case 1:
		var f2;
		if(beta >= 0 && beta > Math.PI) {
			f2 = beta;
		} else {
			var a2 = beta % (2 * Math.PI);
			f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
		}
		var this8 = f2;
		var za1 = this8;
		var f3;
		if(gamma >= 0 && gamma > Math.PI) {
			f3 = gamma;
		} else {
			var a3 = gamma % (2 * Math.PI);
			f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
		}
		var this9 = f3;
		var zb1 = this9;
		var fa1 = za1;
		var fb1 = zb1;
		var theta1 = Math.abs(beta - gamma);
		var clockwise1 = beta < gamma;
		var dif2 = clockwise1 ? theta1 : -theta1;
		dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
		break;
	case 2:
		var f4;
		if(beta >= 0 && beta > Math.PI) {
			f4 = beta;
		} else {
			var a4 = beta % (2 * Math.PI);
			f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
		}
		var this10 = f4;
		var za2 = this10;
		var f5;
		if(gamma >= 0 && gamma > Math.PI) {
			f5 = gamma;
		} else {
			var a5 = gamma % (2 * Math.PI);
			f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
		}
		var this11 = f5;
		var zb2 = this11;
		var fa2 = beta;
		var fb2 = gamma;
		var theta2 = Math.abs(beta - gamma);
		var smallest = theta2 <= Math.PI;
		var clockwise2 = beta < gamma;
		var dif3 = clockwise2 ? theta2 : -theta2;
		dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
		break;
	case 3:
		var f6;
		if(beta >= 0 && beta > Math.PI) {
			f6 = beta;
		} else {
			var a6 = beta % (2 * Math.PI);
			f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
		}
		var this12 = f6;
		var za3 = this12;
		var f7;
		if(gamma >= 0 && gamma > Math.PI) {
			f7 = gamma;
		} else {
			var a7 = gamma % (2 * Math.PI);
			f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
		}
		var this13 = f7;
		var zb3 = this13;
		var fa3 = beta;
		var fb3 = gamma;
		var theta3 = Math.abs(beta - gamma);
		var largest = theta3 > Math.PI;
		var clockwise3 = beta < gamma;
		var dif4 = clockwise3 ? theta3 : -theta3;
		dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
		break;
	}
	var positive = dif >= 0;
	var totalSteps = Math.ceil(Math.abs(dif) / step);
	var step1 = dif / totalSteps;
	var angle = beta;
	var cx5;
	var cy5;
	var bx5 = 0;
	var by5 = 0;
	var dx5 = 0;
	var dy5 = 0;
	var ex = 0;
	var ey = 0;
	var r2 = radius - thick;
	var _g = 0;
	var _g1 = totalSteps + 1;
	while(_g < _g1) {
		var i = _g++;
		cx5 = ax + radius * Math.sin(angle);
		cy5 = ay + radius * Math.cos(angle);
		ex = ax + r2 * Math.sin(angle);
		ey = ay + r2 * Math.cos(angle);
		if(i != 0) {
			var t0 = new trilateral_tri_Trilateral(dx5,dy5,bx5,by5,cx5,cy5);
			var t11 = new trilateral_tri_Trilateral(dx5,dy5,cx5,cy5,ex,ey);
			out1[out1.length] = t0;
			out1[out1.length] = t11;
		}
		angle += step1;
		bx5 = cx5;
		by5 = cy5;
		dx5 = ex;
		dy5 = ey;
	}
	var triArr = out1;
	var _g2 = 0;
	while(_g2 < triArr.length) {
		var t3 = triArr[_g2];
		++_g2;
		out[out.length] = t3;
	}
	var t4 = [];
	var this14;
	if(t4 == null) {
		var t5 = [];
		var this15 = t5 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t5;
		this14 = this15;
	} else {
		this14 = t4;
	}
	var this16 = this14;
	var out2 = this16;
	var pi2 = Math.PI;
	var step2 = pi2 * 2 / 36;
	var dif5;
	switch(trilateral_angle_DifferencePreference.CLOCKWISE._hx_index) {
	case 0:
		var f8;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f8 = pi_2;
		} else {
			var a8 = pi_2 % (2 * Math.PI);
			f8 = a8 >= 0 ? a8 : a8 + 2 * Math.PI;
		}
		var this17 = f8;
		var za4 = this17;
		var f9;
		if(pi >= 0 && pi > Math.PI) {
			f9 = pi;
		} else {
			var a9 = pi % (2 * Math.PI);
			f9 = a9 >= 0 ? a9 : a9 + 2 * Math.PI;
		}
		var this18 = f9;
		var zb4 = this18;
		var fa4 = za4;
		var fb4 = zb4;
		var theta4 = Math.abs(pi_2 - pi);
		var clockwise4 = pi_2 < pi;
		var dif6 = clockwise4 ? theta4 : -theta4;
		dif5 = dif6 > 0 ? dif6 : 2 * Math.PI + dif6;
		break;
	case 1:
		var f10;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f10 = pi_2;
		} else {
			var a10 = pi_2 % (2 * Math.PI);
			f10 = a10 >= 0 ? a10 : a10 + 2 * Math.PI;
		}
		var this19 = f10;
		var za5 = this19;
		var f11;
		if(pi >= 0 && pi > Math.PI) {
			f11 = pi;
		} else {
			var a11 = pi % (2 * Math.PI);
			f11 = a11 >= 0 ? a11 : a11 + 2 * Math.PI;
		}
		var this20 = f11;
		var zb5 = this20;
		var fa5 = za5;
		var fb5 = zb5;
		var theta5 = Math.abs(pi_2 - pi);
		var clockwise5 = pi_2 < pi;
		var dif7 = clockwise5 ? theta5 : -theta5;
		dif5 = dif7 < 0 ? dif7 : -2 * Math.PI + dif7;
		break;
	case 2:
		var f12;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f12 = pi_2;
		} else {
			var a12 = pi_2 % (2 * Math.PI);
			f12 = a12 >= 0 ? a12 : a12 + 2 * Math.PI;
		}
		var this21 = f12;
		var za6 = this21;
		var f13;
		if(pi >= 0 && pi > Math.PI) {
			f13 = pi;
		} else {
			var a13 = pi % (2 * Math.PI);
			f13 = a13 >= 0 ? a13 : a13 + 2 * Math.PI;
		}
		var this22 = f13;
		var zb6 = this22;
		var fa6 = pi_2;
		var fb6 = pi;
		var theta6 = Math.abs(pi_2 - pi);
		var smallest1 = theta6 <= Math.PI;
		var clockwise6 = pi_2 < pi;
		var dif8 = clockwise6 ? theta6 : -theta6;
		dif5 = smallest1 ? dif8 : clockwise6 ? -(2 * Math.PI - theta6) : 2 * Math.PI - theta6;
		break;
	case 3:
		var f14;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f14 = pi_2;
		} else {
			var a14 = pi_2 % (2 * Math.PI);
			f14 = a14 >= 0 ? a14 : a14 + 2 * Math.PI;
		}
		var this23 = f14;
		var za7 = this23;
		var f15;
		if(pi >= 0 && pi > Math.PI) {
			f15 = pi;
		} else {
			var a15 = pi % (2 * Math.PI);
			f15 = a15 >= 0 ? a15 : a15 + 2 * Math.PI;
		}
		var this24 = f15;
		var zb7 = this24;
		var fa7 = pi_2;
		var fb7 = pi;
		var theta7 = Math.abs(pi_2 - pi);
		var largest1 = theta7 > Math.PI;
		var clockwise7 = pi_2 < pi;
		var dif9 = clockwise7 ? theta7 : -theta7;
		dif5 = largest1 ? dif9 : clockwise7 ? -(2 * Math.PI - theta7) : 2 * Math.PI - theta7;
		break;
	}
	var positive1 = dif5 >= 0;
	var totalSteps1 = Math.ceil(Math.abs(dif5) / step2);
	var step3 = dif5 / totalSteps1;
	var angle1 = pi_2;
	var cx6;
	var cy6;
	var bx6 = 0;
	var by6 = 0;
	var dx6 = 0;
	var dy6 = 0;
	var ex1 = 0;
	var ey1 = 0;
	var r21 = radius - thick;
	var _g3 = 0;
	var _g11 = totalSteps1 + 1;
	while(_g3 < _g11) {
		var i1 = _g3++;
		cx6 = bx + radius * Math.sin(angle1);
		cy6 = by + radius * Math.cos(angle1);
		ex1 = bx + r21 * Math.sin(angle1);
		ey1 = by + r21 * Math.cos(angle1);
		if(i1 != 0) {
			var t01 = new trilateral_tri_Trilateral(dx6,dy6,bx6,by6,cx6,cy6);
			var t12 = new trilateral_tri_Trilateral(dx6,dy6,cx6,cy6,ex1,ey1);
			out2[out2.length] = t01;
			out2[out2.length] = t12;
		}
		angle1 += step3;
		bx6 = cx6;
		by6 = cy6;
		dx6 = ex1;
		dy6 = ey1;
	}
	var triArr1 = out2;
	var _g4 = 0;
	while(_g4 < triArr1.length) {
		var t6 = triArr1[_g4];
		++_g4;
		out[out.length] = t6;
	}
	var t7 = [];
	var this25;
	if(t7 == null) {
		var t8 = [];
		var this26 = t8 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t8;
		this25 = this26;
	} else {
		this25 = t7;
	}
	var this27 = this25;
	var out3 = this27;
	var pi3 = Math.PI;
	var step4 = pi3 * 2 / 36;
	var dif10;
	switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE._hx_index) {
	case 0:
		var f16;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f16 = pi_2;
		} else {
			var a16 = pi_2 % (2 * Math.PI);
			f16 = a16 >= 0 ? a16 : a16 + 2 * Math.PI;
		}
		var this28 = f16;
		var za8 = this28;
		var f17;
		if(0 > Math.PI) {
			f17 = 0;
		} else {
			var a17 = 0 % (2 * Math.PI);
			f17 = a17 >= 0 ? a17 : a17 + 2 * Math.PI;
		}
		var this29 = f17;
		var zb8 = this29;
		var fa8 = za8;
		var fb8 = zb8;
		var theta8 = Math.abs(pi_2);
		var clockwise8 = pi_2 < 0;
		var dif11 = clockwise8 ? theta8 : -theta8;
		dif10 = dif11 > 0 ? dif11 : 2 * Math.PI + dif11;
		break;
	case 1:
		var f18;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f18 = pi_2;
		} else {
			var a18 = pi_2 % (2 * Math.PI);
			f18 = a18 >= 0 ? a18 : a18 + 2 * Math.PI;
		}
		var this30 = f18;
		var za9 = this30;
		var f19;
		if(0 > Math.PI) {
			f19 = 0;
		} else {
			var a19 = 0 % (2 * Math.PI);
			f19 = a19 >= 0 ? a19 : a19 + 2 * Math.PI;
		}
		var this31 = f19;
		var zb9 = this31;
		var fa9 = za9;
		var fb9 = zb9;
		var theta9 = Math.abs(pi_2);
		var clockwise9 = pi_2 < 0;
		var dif12 = clockwise9 ? theta9 : -theta9;
		dif10 = dif12 < 0 ? dif12 : -2 * Math.PI + dif12;
		break;
	case 2:
		var f20;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f20 = pi_2;
		} else {
			var a20 = pi_2 % (2 * Math.PI);
			f20 = a20 >= 0 ? a20 : a20 + 2 * Math.PI;
		}
		var this32 = f20;
		var za10 = this32;
		var f21;
		if(0 > Math.PI) {
			f21 = 0;
		} else {
			var a21 = 0 % (2 * Math.PI);
			f21 = a21 >= 0 ? a21 : a21 + 2 * Math.PI;
		}
		var this33 = f21;
		var zb10 = this33;
		var fa10 = pi_2;
		var fb10 = 0;
		var theta10 = Math.abs(pi_2);
		var smallest2 = theta10 <= Math.PI;
		var clockwise10 = pi_2 < 0;
		var dif13 = clockwise10 ? theta10 : -theta10;
		dif10 = smallest2 ? dif13 : clockwise10 ? -(2 * Math.PI - theta10) : 2 * Math.PI - theta10;
		break;
	case 3:
		var f22;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f22 = pi_2;
		} else {
			var a22 = pi_2 % (2 * Math.PI);
			f22 = a22 >= 0 ? a22 : a22 + 2 * Math.PI;
		}
		var this34 = f22;
		var za11 = this34;
		var f23;
		if(0 > Math.PI) {
			f23 = 0;
		} else {
			var a23 = 0 % (2 * Math.PI);
			f23 = a23 >= 0 ? a23 : a23 + 2 * Math.PI;
		}
		var this35 = f23;
		var zb11 = this35;
		var fa11 = pi_2;
		var fb11 = 0;
		var theta11 = Math.abs(pi_2);
		var largest2 = theta11 > Math.PI;
		var clockwise11 = pi_2 < 0;
		var dif14 = clockwise11 ? theta11 : -theta11;
		dif10 = largest2 ? dif14 : clockwise11 ? -(2 * Math.PI - theta11) : 2 * Math.PI - theta11;
		break;
	}
	var positive2 = dif10 >= 0;
	var totalSteps2 = Math.ceil(Math.abs(dif10) / step4);
	var step5 = dif10 / totalSteps2;
	var angle2 = pi_2;
	var cx7;
	var cy7;
	var bx7 = 0;
	var by7 = 0;
	var dx7 = 0;
	var dy7 = 0;
	var ex2 = 0;
	var ey2 = 0;
	var r22 = radius - thick;
	var _g5 = 0;
	var _g12 = totalSteps2 + 1;
	while(_g5 < _g12) {
		var i2 = _g5++;
		cx7 = cx + radius * Math.sin(angle2);
		cy7 = cy + radius * Math.cos(angle2);
		ex2 = cx + r22 * Math.sin(angle2);
		ey2 = cy + r22 * Math.cos(angle2);
		if(i2 != 0) {
			var t02 = new trilateral_tri_Trilateral(dx7,dy7,bx7,by7,cx7,cy7);
			var t13 = new trilateral_tri_Trilateral(dx7,dy7,cx7,cy7,ex2,ey2);
			out3[out3.length] = t02;
			out3[out3.length] = t13;
		}
		angle2 += step5;
		bx7 = cx7;
		by7 = cy7;
		dx7 = ex2;
		dy7 = ey2;
	}
	var triArr2 = out3;
	var _g6 = 0;
	while(_g6 < triArr2.length) {
		var t9 = triArr2[_g6];
		++_g6;
		out[out.length] = t9;
	}
	var gamma1 = -pi_2;
	var t10 = [];
	var this36;
	if(t10 == null) {
		var t14 = [];
		var this37 = t14 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t14;
		this36 = this37;
	} else {
		this36 = t10;
	}
	var this38 = this36;
	var out4 = this38;
	var pi4 = Math.PI;
	var step6 = pi4 * 2 / 36;
	var dif15;
	switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE._hx_index) {
	case 0:
		var f24;
		if(0 > Math.PI) {
			f24 = 0;
		} else {
			var a24 = 0 % (2 * Math.PI);
			f24 = a24 >= 0 ? a24 : a24 + 2 * Math.PI;
		}
		var this39 = f24;
		var za12 = this39;
		var f25;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f25 = gamma1;
		} else {
			var a25 = gamma1 % (2 * Math.PI);
			f25 = a25 >= 0 ? a25 : a25 + 2 * Math.PI;
		}
		var this40 = f25;
		var zb12 = this40;
		var fa12 = za12;
		var fb12 = zb12;
		var theta12 = Math.abs(0 - gamma1);
		var clockwise12 = 0 < gamma1;
		var dif16 = clockwise12 ? theta12 : -theta12;
		dif15 = dif16 > 0 ? dif16 : 2 * Math.PI + dif16;
		break;
	case 1:
		var f26;
		if(0 > Math.PI) {
			f26 = 0;
		} else {
			var a26 = 0 % (2 * Math.PI);
			f26 = a26 >= 0 ? a26 : a26 + 2 * Math.PI;
		}
		var this41 = f26;
		var za13 = this41;
		var f27;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f27 = gamma1;
		} else {
			var a27 = gamma1 % (2 * Math.PI);
			f27 = a27 >= 0 ? a27 : a27 + 2 * Math.PI;
		}
		var this42 = f27;
		var zb13 = this42;
		var fa13 = za13;
		var fb13 = zb13;
		var theta13 = Math.abs(0 - gamma1);
		var clockwise13 = 0 < gamma1;
		var dif17 = clockwise13 ? theta13 : -theta13;
		dif15 = dif17 < 0 ? dif17 : -2 * Math.PI + dif17;
		break;
	case 2:
		var f28;
		if(0 > Math.PI) {
			f28 = 0;
		} else {
			var a28 = 0 % (2 * Math.PI);
			f28 = a28 >= 0 ? a28 : a28 + 2 * Math.PI;
		}
		var this43 = f28;
		var za14 = this43;
		var f29;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f29 = gamma1;
		} else {
			var a29 = gamma1 % (2 * Math.PI);
			f29 = a29 >= 0 ? a29 : a29 + 2 * Math.PI;
		}
		var this44 = f29;
		var zb14 = this44;
		var fa14 = 0;
		var fb14 = gamma1;
		var theta14 = Math.abs(0 - gamma1);
		var smallest3 = theta14 <= Math.PI;
		var clockwise14 = 0 < gamma1;
		var dif18 = clockwise14 ? theta14 : -theta14;
		dif15 = smallest3 ? dif18 : clockwise14 ? -(2 * Math.PI - theta14) : 2 * Math.PI - theta14;
		break;
	case 3:
		var f30;
		if(0 > Math.PI) {
			f30 = 0;
		} else {
			var a30 = 0 % (2 * Math.PI);
			f30 = a30 >= 0 ? a30 : a30 + 2 * Math.PI;
		}
		var this45 = f30;
		var za15 = this45;
		var f31;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f31 = gamma1;
		} else {
			var a31 = gamma1 % (2 * Math.PI);
			f31 = a31 >= 0 ? a31 : a31 + 2 * Math.PI;
		}
		var this46 = f31;
		var zb15 = this46;
		var fa15 = 0;
		var fb15 = gamma1;
		var theta15 = Math.abs(0 - gamma1);
		var largest3 = theta15 > Math.PI;
		var clockwise15 = 0 < gamma1;
		var dif19 = clockwise15 ? theta15 : -theta15;
		dif15 = largest3 ? dif19 : clockwise15 ? -(2 * Math.PI - theta15) : 2 * Math.PI - theta15;
		break;
	}
	var positive3 = dif15 >= 0;
	var totalSteps3 = Math.ceil(Math.abs(dif15) / step6);
	var step7 = dif15 / totalSteps3;
	var angle3 = 0;
	var cx8;
	var cy8;
	var bx8 = 0;
	var by8 = 0;
	var dx8 = 0;
	var dy8 = 0;
	var ex3 = 0;
	var ey3 = 0;
	var r23 = radius - thick;
	var _g7 = 0;
	var _g13 = totalSteps3 + 1;
	while(_g7 < _g13) {
		var i3 = _g7++;
		cx8 = dx + radius * Math.sin(angle3);
		cy8 = dy + radius * Math.cos(angle3);
		ex3 = dx + r23 * Math.sin(angle3);
		ey3 = dy + r23 * Math.cos(angle3);
		if(i3 != 0) {
			var t03 = new trilateral_tri_Trilateral(dx8,dy8,bx8,by8,cx8,cy8);
			var t15 = new trilateral_tri_Trilateral(dx8,dy8,cx8,cy8,ex3,ey3);
			out4[out4.length] = t03;
			out4[out4.length] = t15;
		}
		angle3 += step7;
		bx8 = cx8;
		by8 = cy8;
		dx8 = ex3;
		dy8 = ey3;
	}
	var triArr3 = out4;
	var _g8 = 0;
	while(_g8 < triArr3.length) {
		var t16 = triArr3[_g8];
		++_g8;
		out[out.length] = t16;
	}
	return out;
};
var trilateral_polys_Shapes = function(triangleArray_,colors_) {
	this.refCount = 0;
	this.triangles = triangleArray_;
	this.colors = colors_;
};
trilateral_polys_Shapes.__name__ = true;
trilateral_polys_Shapes.prototype = {
	findShapeById: function(id) {
		var this1 = this.triangles;
		var t = [];
		var this2 = t == null ? trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new([]) : t;
		var this3 = this2;
		var out = this3;
		var _g = 0;
		var _g1 = this1.length;
		while(_g < _g1) {
			var i = _g++;
			if(this1[i].id == id) {
				out[out.length] = this1[i];
			}
		}
		return out;
	}
	,star: function(x,y,radius,color,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var pi = Math.PI;
		var omega = -pi + theta;
		var a0x = x + radius * Math.sin(omega);
		var a0y = y + radius * Math.cos(omega);
		omega += pi / 3;
		var a1x = x + radius * Math.sin(omega);
		var a1y = y + radius * Math.cos(omega);
		omega += pi / 3;
		var b0x = x + radius * Math.sin(omega);
		var b0y = y + radius * Math.cos(omega);
		omega += pi / 3;
		var b1x = x + radius * Math.sin(omega);
		var b1y = y + radius * Math.cos(omega);
		omega += pi / 3;
		var c0x = x + radius * Math.sin(omega);
		var c0y = y + radius * Math.cos(omega);
		omega += pi / 3;
		var c1x = x + radius * Math.sin(omega);
		var c1y = y + radius * Math.cos(omega);
		var tri_t0 = new trilateral_tri_Trilateral(a0x,a0y,b0x,b0y,c0x,c0y);
		var tri_t1 = new trilateral_tri_Trilateral(a1x,a1y,b1x,b1y,c1x,c1y);
		var tri = tri_t0;
		var t = Object.create(trilateral_tri_Triangle.prototype);
		t.id = id;
		t.ax = tri.ax;
		t.ay = tri.ay;
		t.bx = tri.bx;
		t.by = tri.by;
		t.cx = tri.cx;
		t.cy = tri.cy;
		t.mark = tri.mark;
		t.depth = 0;
		t.alpha = 1.;
		t.colorID = color;
		t.colorA = color;
		t.colorB = color;
		t.colorC = color;
		t.windingAdjusted = tri.windingAdjusted;
		var tri0 = t;
		this1[this1.length] = tri0;
		var tri1 = tri_t1;
		var t1 = Object.create(trilateral_tri_Triangle.prototype);
		t1.id = id;
		t1.ax = tri1.ax;
		t1.ay = tri1.ay;
		t1.bx = tri1.bx;
		t1.by = tri1.by;
		t1.cx = tri1.cx;
		t1.cy = tri1.cy;
		t1.mark = tri1.mark;
		t1.depth = 0;
		t1.alpha = 1.;
		t1.colorID = color;
		t1.colorA = color;
		t1.colorB = color;
		t1.colorC = color;
		t1.windingAdjusted = tri1.windingAdjusted;
		var tri11 = t1;
		this1[this1.length] = tri11;
		return this.refCount - 1;
	}
	,diamond: function(x,y,radius,color,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var theta1 = Math.PI / 4;
		var ax = 0.;
		var ay = 0.;
		var bx = 0.;
		var by = 0.;
		var cx = 0.;
		var cy = 0.;
		var dx = 0.;
		var dy = 0.;
		if(theta1 != 0) {
			var pi = Math.PI;
			var pi4 = pi / 4;
			var pi2 = pi / 2;
			var sqrt2 = Math.sqrt(2);
			var r = radius * sqrt2;
			var aTheta = -pi + theta1 - pi4;
			var dTheta = -pi + theta1 + pi / 2 - pi / 4;
			var cTheta = theta1 - pi4;
			var bTheta = -pi + theta1 - pi2 - pi4;
			ax = x + r * Math.sin(aTheta);
			ay = y + r * Math.cos(aTheta);
			bx = x + r * Math.sin(bTheta);
			by = y + r * Math.cos(bTheta);
			cx = x + r * Math.sin(cTheta);
			cy = y + r * Math.cos(cTheta);
			dx = x + r * Math.sin(dTheta);
			dy = y + r * Math.cos(dTheta);
		} else {
			ax = x - radius;
			ay = y - radius;
			var lx = radius * 2;
			var ly = lx;
			bx = ax + lx;
			by = ay;
			cx = bx;
			cy = ay + ly;
			dx = ax;
			dy = cy;
		}
		var tri_t0 = new trilateral_tri_Trilateral(ax,ay,bx,by,dx,dy);
		var tri_t1 = new trilateral_tri_Trilateral(bx,by,cx,cy,dx,dy);
		var tri = tri_t0;
		var t = Object.create(trilateral_tri_Triangle.prototype);
		t.id = id;
		t.ax = tri.ax;
		t.ay = tri.ay;
		t.bx = tri.bx;
		t.by = tri.by;
		t.cx = tri.cx;
		t.cy = tri.cy;
		t.mark = tri.mark;
		t.depth = 0;
		t.alpha = 1.;
		t.colorID = color;
		t.colorA = color;
		t.colorB = color;
		t.colorC = color;
		t.windingAdjusted = tri.windingAdjusted;
		var tri0 = t;
		this1[this1.length] = tri0;
		var tri1 = tri_t1;
		var t1 = Object.create(trilateral_tri_Triangle.prototype);
		t1.id = id;
		t1.ax = tri1.ax;
		t1.ay = tri1.ay;
		t1.bx = tri1.bx;
		t1.by = tri1.by;
		t1.cx = tri1.cx;
		t1.cy = tri1.cy;
		t1.mark = tri1.mark;
		t1.depth = 0;
		t1.alpha = 1.;
		t1.colorID = color;
		t1.colorA = color;
		t1.colorB = color;
		t1.colorC = color;
		t1.windingAdjusted = tri1.windingAdjusted;
		var tri11 = t1;
		this1[this1.length] = tri11;
		return this.refCount - 1;
	}
	,diamondOutline: function(x,y,radius,thick,color,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var theta1 = Math.PI / 4;
		var t = [];
		var this2;
		if(t == null) {
			var t1 = [];
			var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this2 = this3;
		} else {
			this2 = t;
		}
		var this4 = this2;
		var out = this4;
		var ax = 0.;
		var ay = 0.;
		var bx = 0.;
		var by = 0.;
		var cx = 0.;
		var cy = 0.;
		var dx = 0.;
		var dy = 0.;
		var a0x = 0.;
		var a0y = 0.;
		var b0x = 0.;
		var b0y = 0.;
		var c0x = 0.;
		var c0y = 0.;
		var d0x = 0.;
		var d0y = 0.;
		if(theta1 != 0) {
			var pi = Math.PI;
			var pi4 = pi / 4;
			var pi2 = pi / 2;
			var sqrt2 = Math.sqrt(2);
			var r = radius * sqrt2;
			var aTheta = -pi + theta1 - pi4;
			var dTheta = -pi + theta1 + pi / 2 - pi / 4;
			var cTheta = theta1 - pi4;
			var bTheta = -pi + theta1 - pi2 - pi4;
			var as = Math.sin(aTheta);
			var ac = Math.cos(aTheta);
			var bs = Math.sin(bTheta);
			var bc = Math.cos(bTheta);
			var cs = Math.sin(cTheta);
			var cc = Math.cos(cTheta);
			var ds = Math.sin(dTheta);
			var dc = Math.cos(dTheta);
			var r0 = r - thick;
			ax = x + r * as;
			ay = y + r * ac;
			bx = x + r * bs;
			by = y + r * bc;
			cx = x + r * cs;
			cy = y + r * cc;
			dx = x + r * ds;
			dy = y + r * dc;
			a0x = x + r0 * as;
			a0y = y + r0 * ac;
			b0x = x + r0 * bs;
			b0y = y + r0 * bc;
			c0x = x + r0 * cs;
			c0y = y + r0 * cc;
			d0x = x + r0 * ds;
			d0y = y + r0 * dc;
		} else {
			ax = x - radius;
			ay = y - radius;
			var lx = radius * 2;
			var ly = lx;
			bx = ax + lx;
			by = ay;
			cx = bx;
			cy = ay + ly;
			dx = ax;
			dy = cy;
			var radius0 = radius - thick;
			a0x = x - radius0;
			a0y = y - radius0;
			var l0x = radius0 * 2;
			var l0y = l0x;
			b0x = a0x + l0x;
			b0y = a0y;
			c0x = b0x;
			c0y = a0y + l0y;
			d0x = a0x;
			d0y = c0y;
		}
		var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,a0x,a0y);
		out[out.length] = tri;
		var tri1 = new trilateral_tri_Trilateral(bx,by,b0x,b0y,a0x,a0y);
		out[out.length] = tri1;
		var tri2 = new trilateral_tri_Trilateral(d0x,d0y,c0x,c0y,dx,dy);
		out[out.length] = tri2;
		var tri3 = new trilateral_tri_Trilateral(c0x,c0y,cx,cy,dx,dy);
		out[out.length] = tri3;
		var tri4 = new trilateral_tri_Trilateral(ax,ay,a0x,a0y,d0x,d0y);
		out[out.length] = tri4;
		var tri5 = new trilateral_tri_Trilateral(ax,ay,d0x,d0y,dx,dy);
		out[out.length] = tri5;
		var tri6 = new trilateral_tri_Trilateral(b0x,b0y,bx,by,c0x,c0y);
		out[out.length] = tri6;
		var tri7 = new trilateral_tri_Trilateral(bx,by,cx,cy,c0x,c0y);
		out[out.length] = tri7;
		var triArr = out;
		var tri8;
		var _g = 0;
		while(_g < triArr.length) {
			var t2 = triArr[_g];
			++_g;
			if(t2 != null) {
				var t3 = Object.create(trilateral_tri_Triangle.prototype);
				t3.id = id;
				t3.ax = t2.ax;
				t3.ay = t2.ay;
				t3.bx = t2.bx;
				t3.by = t2.by;
				t3.cx = t2.cx;
				t3.cy = t2.cy;
				t3.mark = t2.mark;
				t3.depth = 0;
				t3.alpha = 1.;
				t3.colorID = color;
				t3.colorA = color;
				t3.colorB = color;
				t3.colorC = color;
				t3.windingAdjusted = t2.windingAdjusted;
				tri8 = t3;
				this1[this1.length] = tri8;
			}
		}
		return this.refCount - 1;
	}
	,square: function(x,y,radius,color,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var ax = 0.;
		var ay = 0.;
		var bx = 0.;
		var by = 0.;
		var cx = 0.;
		var cy = 0.;
		var dx = 0.;
		var dy = 0.;
		ax = x - radius;
		ay = y - radius;
		var lx = radius * 2;
		var ly = lx;
		bx = ax + lx;
		by = ay;
		cx = bx;
		cy = ay + ly;
		dx = ax;
		dy = cy;
		var tri_t0 = new trilateral_tri_Trilateral(ax,ay,bx,by,dx,dy);
		var tri_t1 = new trilateral_tri_Trilateral(bx,by,cx,cy,dx,dy);
		var tri = tri_t0;
		var t = Object.create(trilateral_tri_Triangle.prototype);
		t.id = id;
		t.ax = tri.ax;
		t.ay = tri.ay;
		t.bx = tri.bx;
		t.by = tri.by;
		t.cx = tri.cx;
		t.cy = tri.cy;
		t.mark = tri.mark;
		t.depth = 0;
		t.alpha = 1.;
		t.colorID = color;
		t.colorA = color;
		t.colorB = color;
		t.colorC = color;
		t.windingAdjusted = tri.windingAdjusted;
		var tri0 = t;
		this1[this1.length] = tri0;
		var tri1 = tri_t1;
		var t1 = Object.create(trilateral_tri_Triangle.prototype);
		t1.id = id;
		t1.ax = tri1.ax;
		t1.ay = tri1.ay;
		t1.bx = tri1.bx;
		t1.by = tri1.by;
		t1.cx = tri1.cx;
		t1.cy = tri1.cy;
		t1.mark = tri1.mark;
		t1.depth = 0;
		t1.alpha = 1.;
		t1.colorID = color;
		t1.colorA = color;
		t1.colorB = color;
		t1.colorC = color;
		t1.windingAdjusted = tri1.windingAdjusted;
		var tri11 = t1;
		this1[this1.length] = tri11;
		return this.refCount - 1;
	}
	,squareOutline: function(x,y,radius,thick,color,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var t = [];
		var this2;
		if(t == null) {
			var t1 = [];
			var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this2 = this3;
		} else {
			this2 = t;
		}
		var this4 = this2;
		var out = this4;
		var ax = 0.;
		var ay = 0.;
		var bx = 0.;
		var by = 0.;
		var cx = 0.;
		var cy = 0.;
		var dx = 0.;
		var dy = 0.;
		var a0x = 0.;
		var a0y = 0.;
		var b0x = 0.;
		var b0y = 0.;
		var c0x = 0.;
		var c0y = 0.;
		var d0x = 0.;
		var d0y = 0.;
		ax = x - radius;
		ay = y - radius;
		var lx = radius * 2;
		var ly = lx;
		bx = ax + lx;
		by = ay;
		cx = bx;
		cy = ay + ly;
		dx = ax;
		dy = cy;
		var radius0 = radius - thick;
		a0x = x - radius0;
		a0y = y - radius0;
		var l0x = radius0 * 2;
		var l0y = l0x;
		b0x = a0x + l0x;
		b0y = a0y;
		c0x = b0x;
		c0y = a0y + l0y;
		d0x = a0x;
		d0y = c0y;
		var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,a0x,a0y);
		out[out.length] = tri;
		var tri1 = new trilateral_tri_Trilateral(bx,by,b0x,b0y,a0x,a0y);
		out[out.length] = tri1;
		var tri2 = new trilateral_tri_Trilateral(d0x,d0y,c0x,c0y,dx,dy);
		out[out.length] = tri2;
		var tri3 = new trilateral_tri_Trilateral(c0x,c0y,cx,cy,dx,dy);
		out[out.length] = tri3;
		var tri4 = new trilateral_tri_Trilateral(ax,ay,a0x,a0y,d0x,d0y);
		out[out.length] = tri4;
		var tri5 = new trilateral_tri_Trilateral(ax,ay,d0x,d0y,dx,dy);
		out[out.length] = tri5;
		var tri6 = new trilateral_tri_Trilateral(b0x,b0y,bx,by,c0x,c0y);
		out[out.length] = tri6;
		var tri7 = new trilateral_tri_Trilateral(bx,by,cx,cy,c0x,c0y);
		out[out.length] = tri7;
		var triArr = out;
		var tri8;
		var _g = 0;
		while(_g < triArr.length) {
			var t2 = triArr[_g];
			++_g;
			if(t2 != null) {
				var t3 = Object.create(trilateral_tri_Triangle.prototype);
				t3.id = id;
				t3.ax = t2.ax;
				t3.ay = t2.ay;
				t3.bx = t2.bx;
				t3.by = t2.by;
				t3.cx = t2.cx;
				t3.cy = t2.cy;
				t3.mark = t2.mark;
				t3.depth = 0;
				t3.alpha = 1.;
				t3.colorID = color;
				t3.colorA = color;
				t3.colorB = color;
				t3.colorC = color;
				t3.windingAdjusted = t2.windingAdjusted;
				tri8 = t3;
				this1[this1.length] = tri8;
			}
		}
		return this.refCount - 1;
	}
	,rectangle: function(x,y,width,height,color) {
		var this1 = this.triangles;
		var id = this.refCount++;
		var ax = x;
		var ay = y;
		var bx = x + width;
		var by = ay;
		var cx = bx;
		var cy = ay + height;
		var dx = x;
		var dy = cy;
		var tri_t0 = new trilateral_tri_Trilateral(ax,ay,bx,by,dx,dy);
		var tri_t1 = new trilateral_tri_Trilateral(bx,by,cx,cy,dx,dy);
		var tri = tri_t0;
		var t = Object.create(trilateral_tri_Triangle.prototype);
		t.id = id;
		t.ax = tri.ax;
		t.ay = tri.ay;
		t.bx = tri.bx;
		t.by = tri.by;
		t.cx = tri.cx;
		t.cy = tri.cy;
		t.mark = tri.mark;
		t.depth = 0;
		t.alpha = 1.;
		t.colorID = color;
		t.colorA = color;
		t.colorB = color;
		t.colorC = color;
		t.windingAdjusted = tri.windingAdjusted;
		var tri0 = t;
		this1[this1.length] = tri0;
		var tri1 = tri_t1;
		var t1 = Object.create(trilateral_tri_Triangle.prototype);
		t1.id = id;
		t1.ax = tri1.ax;
		t1.ay = tri1.ay;
		t1.bx = tri1.bx;
		t1.by = tri1.by;
		t1.cx = tri1.cx;
		t1.cy = tri1.cy;
		t1.mark = tri1.mark;
		t1.depth = 0;
		t1.alpha = 1.;
		t1.colorID = color;
		t1.colorA = color;
		t1.colorB = color;
		t1.colorC = color;
		t1.windingAdjusted = tri1.windingAdjusted;
		var tri11 = t1;
		this1[this1.length] = tri11;
		return this.refCount - 1;
	}
	,circle: function(x,y,radius,color,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var t = [];
		var this2;
		if(t == null) {
			var t1 = [];
			var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this2 = this3;
		} else {
			this2 = t;
		}
		var this4 = this2;
		var out = this4;
		var pi = Math.PI;
		var theta1 = pi / 2;
		var step = pi * 2 / 36;
		var bx;
		var by;
		var cx;
		var cy;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = x + radius * Math.sin(theta1);
			by = y + radius * Math.cos(theta1);
			theta1 += step;
			cx = x + radius * Math.sin(theta1);
			cy = y + radius * Math.cos(theta1);
			var tri = new trilateral_tri_Trilateral(x,y,bx,by,cx,cy);
			out[out.length] = tri;
		}
		var triArr = out;
		var tri1;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t2 = triArr[_g2];
			++_g2;
			if(t2 != null) {
				var t3 = Object.create(trilateral_tri_Triangle.prototype);
				t3.id = id;
				t3.ax = t2.ax;
				t3.ay = t2.ay;
				t3.bx = t2.bx;
				t3.by = t2.by;
				t3.cx = t2.cx;
				t3.cy = t2.cy;
				t3.mark = t2.mark;
				t3.depth = 0;
				t3.alpha = 1.;
				t3.colorID = color;
				t3.colorA = color;
				t3.colorB = color;
				t3.colorC = color;
				t3.windingAdjusted = t2.windingAdjusted;
				tri1 = t3;
				this1[this1.length] = tri1;
			}
		}
		return this.refCount - 1;
	}
	,shape: function(x,y,radius,color,sides,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var triArr;
		if((sides & 1) == 0) {
			var t = [];
			var this2;
			if(t == null) {
				var t1 = [];
				var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
				this2 = this3;
			} else {
				this2 = t;
			}
			var this4 = this2;
			var out = this4;
			var pi = Math.PI;
			var theta1 = pi / 2;
			var step = pi * 2 / sides;
			theta1 -= step / 2 + theta;
			var bx;
			var by;
			var cx;
			var cy;
			var _g = 0;
			var _g1 = sides;
			while(_g < _g1) {
				var i = _g++;
				bx = x + radius * Math.sin(theta1);
				by = y + radius * Math.cos(theta1);
				theta1 += step;
				cx = x + radius * Math.sin(theta1);
				cy = y + radius * Math.cos(theta1);
				var tri = new trilateral_tri_Trilateral(x,y,bx,by,cx,cy);
				out[out.length] = tri;
			}
			triArr = out;
		} else {
			var t2 = [];
			var this5;
			if(t2 == null) {
				var t3 = [];
				var this6 = t3 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t3;
				this5 = this6;
			} else {
				this5 = t2;
			}
			var this7 = this5;
			var out1 = this7;
			var pi1 = Math.PI;
			var theta2 = pi1 / 2 + theta;
			var step1 = pi1 * 2 / sides;
			var bx1;
			var by1;
			var cx1;
			var cy1;
			var _g2 = 0;
			var _g11 = sides;
			while(_g2 < _g11) {
				var i1 = _g2++;
				bx1 = x + radius * Math.sin(theta2);
				by1 = y + radius * Math.cos(theta2);
				theta2 += step1;
				cx1 = x + radius * Math.sin(theta2);
				cy1 = y + radius * Math.cos(theta2);
				var tri1 = new trilateral_tri_Trilateral(x,y,bx1,by1,cx1,cy1);
				out1[out1.length] = tri1;
			}
			triArr = out1;
		}
		var tri2;
		var _g3 = 0;
		while(_g3 < triArr.length) {
			var t4 = triArr[_g3];
			++_g3;
			if(t4 != null) {
				var t5 = Object.create(trilateral_tri_Triangle.prototype);
				t5.id = id;
				t5.ax = t4.ax;
				t5.ay = t4.ay;
				t5.bx = t4.bx;
				t5.by = t4.by;
				t5.cx = t4.cx;
				t5.cy = t4.cy;
				t5.mark = t4.mark;
				t5.depth = 0;
				t5.alpha = 1.;
				t5.colorID = color;
				t5.colorA = color;
				t5.colorB = color;
				t5.colorC = color;
				t5.windingAdjusted = t4.windingAdjusted;
				tri2 = t5;
				this1[this1.length] = tri2;
			}
		}
		return this.refCount - 1;
	}
	,ellipse: function(x,y,rx,ry,color,sides,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var t = [];
		var this2;
		if(t == null) {
			var t1 = [];
			var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this2 = this3;
		} else {
			this2 = t;
		}
		var this4 = this2;
		var out = this4;
		var pi = Math.PI;
		var theta1 = pi / 2;
		var step = pi * 2 / sides;
		var bx;
		var by;
		var cx;
		var cy;
		var _g = 0;
		var _g1 = sides;
		while(_g < _g1) {
			var i = _g++;
			bx = x + rx * Math.sin(theta1);
			by = y + ry * Math.cos(theta1);
			theta1 += step;
			cx = x + rx * Math.sin(theta1);
			cy = y + ry * Math.cos(theta1);
			var tri = new trilateral_tri_Trilateral(x,y,bx,by,cx,cy);
			out[out.length] = tri;
		}
		var triArr = out;
		var tri1;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t2 = triArr[_g2];
			++_g2;
			if(t2 != null) {
				var t3 = Object.create(trilateral_tri_Triangle.prototype);
				t3.id = id;
				t3.ax = t2.ax;
				t3.ay = t2.ay;
				t3.bx = t2.bx;
				t3.by = t2.by;
				t3.cx = t2.cx;
				t3.cy = t2.cy;
				t3.mark = t2.mark;
				t3.depth = 0;
				t3.alpha = 1.;
				t3.colorID = color;
				t3.colorA = color;
				t3.colorB = color;
				t3.colorC = color;
				t3.windingAdjusted = t2.windingAdjusted;
				tri1 = t3;
				this1[this1.length] = tri1;
			}
		}
		return this.refCount - 1;
	}
	,roundedRectangle: function(x,y,width,height,radius,color) {
		var this1 = this.triangles;
		var id = this.refCount++;
		var t = [];
		var this2;
		if(t == null) {
			var t1 = [];
			var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this2 = this3;
		} else {
			this2 = t;
		}
		var this4 = this2;
		var out = this4;
		var pi = Math.PI;
		var pi_2 = Math.PI / 2;
		var ax = x + radius;
		var ay = y + radius;
		var bx = x + width - radius;
		var by = y + radius;
		var cx = bx;
		var cy = y + height - radius;
		var dx = ax;
		var dy = cy;
		var ax1 = ax;
		var ay1 = y;
		var bx1 = ax + (width - radius * 2);
		var by1 = ay1;
		var cx1 = bx1;
		var cy1 = ay1 + height;
		var dx1 = ax;
		var dy1 = cy1;
		var tp_t0 = new trilateral_tri_Trilateral(ax1,ay1,bx1,by1,dx1,dy1);
		var tp_t1 = new trilateral_tri_Trilateral(bx1,by1,cx1,cy1,dx1,dy1);
		out[out.length] = tp_t0;
		out[out.length] = tp_t1;
		var dimY = height - 2 * radius;
		var ax2 = x;
		var ay2 = ay;
		var bx2 = x + radius;
		var by2 = ay2;
		var cx2 = bx2;
		var cy2 = ay2 + dimY;
		var dx2 = x;
		var dy2 = cy2;
		var tp_t01 = new trilateral_tri_Trilateral(ax2,ay2,bx2,by2,dx2,dy2);
		var tp_t11 = new trilateral_tri_Trilateral(bx2,by2,cx2,cy2,dx2,dy2);
		out[out.length] = tp_t01;
		out[out.length] = tp_t11;
		var ax3 = bx;
		var ay3 = by;
		var bx3 = bx + radius;
		var by3 = ay3;
		var cx3 = bx3;
		var cy3 = ay3 + dimY;
		var dx3 = bx;
		var dy3 = cy3;
		var tp_t02 = new trilateral_tri_Trilateral(ax3,ay3,bx3,by3,dx3,dy3);
		var tp_t12 = new trilateral_tri_Trilateral(bx3,by3,cx3,cy3,dx3,dy3);
		out[out.length] = tp_t02;
		out[out.length] = tp_t12;
		var beta = -pi;
		var gamma = -pi_2;
		var t2 = [];
		var this5;
		if(t2 == null) {
			var t3 = [];
			var this6;
			if(t3 == null) {
				var t4 = [];
				var this7 = t4 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t4;
				this6 = this7;
			} else {
				this6 = t3;
			}
			this5 = this6;
		} else {
			this5 = t2;
		}
		var this8 = this5;
		var out1 = this8;
		var pi1 = Math.PI;
		var step = pi1 * 2 / 36;
		var dif;
		switch(trilateral_angle_DifferencePreference.CLOCKWISE._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this9 = f;
			var za = this9;
			var f1;
			if(gamma >= 0 && gamma > Math.PI) {
				f1 = gamma;
			} else {
				var a1 = gamma % (2 * Math.PI);
				f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
			}
			var this10 = f1;
			var zb = this10;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(beta - gamma);
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f2;
			if(beta >= 0 && beta > Math.PI) {
				f2 = beta;
			} else {
				var a2 = beta % (2 * Math.PI);
				f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
			}
			var this11 = f2;
			var za1 = this11;
			var f3;
			if(gamma >= 0 && gamma > Math.PI) {
				f3 = gamma;
			} else {
				var a3 = gamma % (2 * Math.PI);
				f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
			}
			var this12 = f3;
			var zb1 = this12;
			var fa1 = za1;
			var fb1 = zb1;
			var theta1 = Math.abs(beta - gamma);
			var clockwise1 = beta < gamma;
			var dif2 = clockwise1 ? theta1 : -theta1;
			dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
			break;
		case 2:
			var f4;
			if(beta >= 0 && beta > Math.PI) {
				f4 = beta;
			} else {
				var a4 = beta % (2 * Math.PI);
				f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
			}
			var this13 = f4;
			var za2 = this13;
			var f5;
			if(gamma >= 0 && gamma > Math.PI) {
				f5 = gamma;
			} else {
				var a5 = gamma % (2 * Math.PI);
				f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
			}
			var this14 = f5;
			var zb2 = this14;
			var fa2 = beta;
			var fb2 = gamma;
			var theta2 = Math.abs(beta - gamma);
			var smallest = theta2 <= Math.PI;
			var clockwise2 = beta < gamma;
			var dif3 = clockwise2 ? theta2 : -theta2;
			dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
			break;
		case 3:
			var f6;
			if(beta >= 0 && beta > Math.PI) {
				f6 = beta;
			} else {
				var a6 = beta % (2 * Math.PI);
				f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
			}
			var this15 = f6;
			var za3 = this15;
			var f7;
			if(gamma >= 0 && gamma > Math.PI) {
				f7 = gamma;
			} else {
				var a7 = gamma % (2 * Math.PI);
				f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
			}
			var this16 = f7;
			var zb3 = this16;
			var fa3 = beta;
			var fb3 = gamma;
			var theta3 = Math.abs(beta - gamma);
			var largest = theta3 > Math.PI;
			var clockwise3 = beta < gamma;
			var dif4 = clockwise3 ? theta3 : -theta3;
			dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step1 = dif / totalSteps;
		var angle = beta;
		var cx4;
		var cy4;
		var bx4 = 0;
		var by4 = 0;
		var _g = 0;
		var _g1 = totalSteps + 1;
		while(_g < _g1) {
			var i = _g++;
			cx4 = ax + radius * Math.sin(angle);
			cy4 = ay + radius * Math.cos(angle);
			if(i != 0) {
				var t5 = new trilateral_tri_Trilateral(ax,ay,bx4,by4,cx4,cy4);
				out1[out1.length] = t5;
			}
			angle += step1;
			bx4 = cx4;
			by4 = cy4;
		}
		var triArr = out1;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t6 = triArr[_g2];
			++_g2;
			out[out.length] = t6;
		}
		var t7 = [];
		var this17;
		if(t7 == null) {
			var t8 = [];
			var this18;
			if(t8 == null) {
				var t9 = [];
				var this19 = t9 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t9;
				this18 = this19;
			} else {
				this18 = t8;
			}
			this17 = this18;
		} else {
			this17 = t7;
		}
		var this20 = this17;
		var out2 = this20;
		var pi2 = Math.PI;
		var step2 = pi2 * 2 / 36;
		var dif5;
		switch(trilateral_angle_DifferencePreference.CLOCKWISE._hx_index) {
		case 0:
			var f8;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f8 = pi_2;
			} else {
				var a8 = pi_2 % (2 * Math.PI);
				f8 = a8 >= 0 ? a8 : a8 + 2 * Math.PI;
			}
			var this21 = f8;
			var za4 = this21;
			var f9;
			if(pi >= 0 && pi > Math.PI) {
				f9 = pi;
			} else {
				var a9 = pi % (2 * Math.PI);
				f9 = a9 >= 0 ? a9 : a9 + 2 * Math.PI;
			}
			var this22 = f9;
			var zb4 = this22;
			var fa4 = za4;
			var fb4 = zb4;
			var theta4 = Math.abs(pi_2 - pi);
			var clockwise4 = pi_2 < pi;
			var dif6 = clockwise4 ? theta4 : -theta4;
			dif5 = dif6 > 0 ? dif6 : 2 * Math.PI + dif6;
			break;
		case 1:
			var f10;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f10 = pi_2;
			} else {
				var a10 = pi_2 % (2 * Math.PI);
				f10 = a10 >= 0 ? a10 : a10 + 2 * Math.PI;
			}
			var this23 = f10;
			var za5 = this23;
			var f11;
			if(pi >= 0 && pi > Math.PI) {
				f11 = pi;
			} else {
				var a11 = pi % (2 * Math.PI);
				f11 = a11 >= 0 ? a11 : a11 + 2 * Math.PI;
			}
			var this24 = f11;
			var zb5 = this24;
			var fa5 = za5;
			var fb5 = zb5;
			var theta5 = Math.abs(pi_2 - pi);
			var clockwise5 = pi_2 < pi;
			var dif7 = clockwise5 ? theta5 : -theta5;
			dif5 = dif7 < 0 ? dif7 : -2 * Math.PI + dif7;
			break;
		case 2:
			var f12;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f12 = pi_2;
			} else {
				var a12 = pi_2 % (2 * Math.PI);
				f12 = a12 >= 0 ? a12 : a12 + 2 * Math.PI;
			}
			var this25 = f12;
			var za6 = this25;
			var f13;
			if(pi >= 0 && pi > Math.PI) {
				f13 = pi;
			} else {
				var a13 = pi % (2 * Math.PI);
				f13 = a13 >= 0 ? a13 : a13 + 2 * Math.PI;
			}
			var this26 = f13;
			var zb6 = this26;
			var fa6 = pi_2;
			var fb6 = pi;
			var theta6 = Math.abs(pi_2 - pi);
			var smallest1 = theta6 <= Math.PI;
			var clockwise6 = pi_2 < pi;
			var dif8 = clockwise6 ? theta6 : -theta6;
			dif5 = smallest1 ? dif8 : clockwise6 ? -(2 * Math.PI - theta6) : 2 * Math.PI - theta6;
			break;
		case 3:
			var f14;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f14 = pi_2;
			} else {
				var a14 = pi_2 % (2 * Math.PI);
				f14 = a14 >= 0 ? a14 : a14 + 2 * Math.PI;
			}
			var this27 = f14;
			var za7 = this27;
			var f15;
			if(pi >= 0 && pi > Math.PI) {
				f15 = pi;
			} else {
				var a15 = pi % (2 * Math.PI);
				f15 = a15 >= 0 ? a15 : a15 + 2 * Math.PI;
			}
			var this28 = f15;
			var zb7 = this28;
			var fa7 = pi_2;
			var fb7 = pi;
			var theta7 = Math.abs(pi_2 - pi);
			var largest1 = theta7 > Math.PI;
			var clockwise7 = pi_2 < pi;
			var dif9 = clockwise7 ? theta7 : -theta7;
			dif5 = largest1 ? dif9 : clockwise7 ? -(2 * Math.PI - theta7) : 2 * Math.PI - theta7;
			break;
		}
		var positive1 = dif5 >= 0;
		var totalSteps1 = Math.ceil(Math.abs(dif5) / step2);
		var step3 = dif5 / totalSteps1;
		var angle1 = pi_2;
		var cx5;
		var cy5;
		var bx5 = 0;
		var by5 = 0;
		var _g3 = 0;
		var _g11 = totalSteps1 + 1;
		while(_g3 < _g11) {
			var i1 = _g3++;
			cx5 = bx + radius * Math.sin(angle1);
			cy5 = by + radius * Math.cos(angle1);
			if(i1 != 0) {
				var t10 = new trilateral_tri_Trilateral(bx,by,bx5,by5,cx5,cy5);
				out2[out2.length] = t10;
			}
			angle1 += step3;
			bx5 = cx5;
			by5 = cy5;
		}
		var triArr1 = out2;
		var _g4 = 0;
		while(_g4 < triArr1.length) {
			var t11 = triArr1[_g4];
			++_g4;
			out[out.length] = t11;
		}
		var t12 = [];
		var this29;
		if(t12 == null) {
			var t13 = [];
			var this30;
			if(t13 == null) {
				var t14 = [];
				var this31 = t14 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t14;
				this30 = this31;
			} else {
				this30 = t13;
			}
			this29 = this30;
		} else {
			this29 = t12;
		}
		var this32 = this29;
		var out3 = this32;
		var pi3 = Math.PI;
		var step4 = pi3 * 2 / 36;
		var dif10;
		switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE._hx_index) {
		case 0:
			var f16;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f16 = pi_2;
			} else {
				var a16 = pi_2 % (2 * Math.PI);
				f16 = a16 >= 0 ? a16 : a16 + 2 * Math.PI;
			}
			var this33 = f16;
			var za8 = this33;
			var f17;
			if(0 > Math.PI) {
				f17 = 0;
			} else {
				var a17 = 0 % (2 * Math.PI);
				f17 = a17 >= 0 ? a17 : a17 + 2 * Math.PI;
			}
			var this34 = f17;
			var zb8 = this34;
			var fa8 = za8;
			var fb8 = zb8;
			var theta8 = Math.abs(pi_2);
			var clockwise8 = pi_2 < 0;
			var dif11 = clockwise8 ? theta8 : -theta8;
			dif10 = dif11 > 0 ? dif11 : 2 * Math.PI + dif11;
			break;
		case 1:
			var f18;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f18 = pi_2;
			} else {
				var a18 = pi_2 % (2 * Math.PI);
				f18 = a18 >= 0 ? a18 : a18 + 2 * Math.PI;
			}
			var this35 = f18;
			var za9 = this35;
			var f19;
			if(0 > Math.PI) {
				f19 = 0;
			} else {
				var a19 = 0 % (2 * Math.PI);
				f19 = a19 >= 0 ? a19 : a19 + 2 * Math.PI;
			}
			var this36 = f19;
			var zb9 = this36;
			var fa9 = za9;
			var fb9 = zb9;
			var theta9 = Math.abs(pi_2);
			var clockwise9 = pi_2 < 0;
			var dif12 = clockwise9 ? theta9 : -theta9;
			dif10 = dif12 < 0 ? dif12 : -2 * Math.PI + dif12;
			break;
		case 2:
			var f20;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f20 = pi_2;
			} else {
				var a20 = pi_2 % (2 * Math.PI);
				f20 = a20 >= 0 ? a20 : a20 + 2 * Math.PI;
			}
			var this37 = f20;
			var za10 = this37;
			var f21;
			if(0 > Math.PI) {
				f21 = 0;
			} else {
				var a21 = 0 % (2 * Math.PI);
				f21 = a21 >= 0 ? a21 : a21 + 2 * Math.PI;
			}
			var this38 = f21;
			var zb10 = this38;
			var fa10 = pi_2;
			var fb10 = 0;
			var theta10 = Math.abs(pi_2);
			var smallest2 = theta10 <= Math.PI;
			var clockwise10 = pi_2 < 0;
			var dif13 = clockwise10 ? theta10 : -theta10;
			dif10 = smallest2 ? dif13 : clockwise10 ? -(2 * Math.PI - theta10) : 2 * Math.PI - theta10;
			break;
		case 3:
			var f22;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f22 = pi_2;
			} else {
				var a22 = pi_2 % (2 * Math.PI);
				f22 = a22 >= 0 ? a22 : a22 + 2 * Math.PI;
			}
			var this39 = f22;
			var za11 = this39;
			var f23;
			if(0 > Math.PI) {
				f23 = 0;
			} else {
				var a23 = 0 % (2 * Math.PI);
				f23 = a23 >= 0 ? a23 : a23 + 2 * Math.PI;
			}
			var this40 = f23;
			var zb11 = this40;
			var fa11 = pi_2;
			var fb11 = 0;
			var theta11 = Math.abs(pi_2);
			var largest2 = theta11 > Math.PI;
			var clockwise11 = pi_2 < 0;
			var dif14 = clockwise11 ? theta11 : -theta11;
			dif10 = largest2 ? dif14 : clockwise11 ? -(2 * Math.PI - theta11) : 2 * Math.PI - theta11;
			break;
		}
		var positive2 = dif10 >= 0;
		var totalSteps2 = Math.ceil(Math.abs(dif10) / step4);
		var step5 = dif10 / totalSteps2;
		var angle2 = pi_2;
		var cx6;
		var cy6;
		var bx6 = 0;
		var by6 = 0;
		var _g5 = 0;
		var _g12 = totalSteps2 + 1;
		while(_g5 < _g12) {
			var i2 = _g5++;
			cx6 = cx + radius * Math.sin(angle2);
			cy6 = cy + radius * Math.cos(angle2);
			if(i2 != 0) {
				var t15 = new trilateral_tri_Trilateral(cx,cy,bx6,by6,cx6,cy6);
				out3[out3.length] = t15;
			}
			angle2 += step5;
			bx6 = cx6;
			by6 = cy6;
		}
		var triArr2 = out3;
		var _g6 = 0;
		while(_g6 < triArr2.length) {
			var t16 = triArr2[_g6];
			++_g6;
			out[out.length] = t16;
		}
		var gamma1 = -pi_2;
		var t17 = [];
		var this41;
		if(t17 == null) {
			var t18 = [];
			var this42;
			if(t18 == null) {
				var t19 = [];
				var this43 = t19 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t19;
				this42 = this43;
			} else {
				this42 = t18;
			}
			this41 = this42;
		} else {
			this41 = t17;
		}
		var this44 = this41;
		var out4 = this44;
		var pi4 = Math.PI;
		var step6 = pi4 * 2 / 36;
		var dif15;
		switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE._hx_index) {
		case 0:
			var f24;
			if(0 > Math.PI) {
				f24 = 0;
			} else {
				var a24 = 0 % (2 * Math.PI);
				f24 = a24 >= 0 ? a24 : a24 + 2 * Math.PI;
			}
			var this45 = f24;
			var za12 = this45;
			var f25;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f25 = gamma1;
			} else {
				var a25 = gamma1 % (2 * Math.PI);
				f25 = a25 >= 0 ? a25 : a25 + 2 * Math.PI;
			}
			var this46 = f25;
			var zb12 = this46;
			var fa12 = za12;
			var fb12 = zb12;
			var theta12 = Math.abs(0 - gamma1);
			var clockwise12 = 0 < gamma1;
			var dif16 = clockwise12 ? theta12 : -theta12;
			dif15 = dif16 > 0 ? dif16 : 2 * Math.PI + dif16;
			break;
		case 1:
			var f26;
			if(0 > Math.PI) {
				f26 = 0;
			} else {
				var a26 = 0 % (2 * Math.PI);
				f26 = a26 >= 0 ? a26 : a26 + 2 * Math.PI;
			}
			var this47 = f26;
			var za13 = this47;
			var f27;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f27 = gamma1;
			} else {
				var a27 = gamma1 % (2 * Math.PI);
				f27 = a27 >= 0 ? a27 : a27 + 2 * Math.PI;
			}
			var this48 = f27;
			var zb13 = this48;
			var fa13 = za13;
			var fb13 = zb13;
			var theta13 = Math.abs(0 - gamma1);
			var clockwise13 = 0 < gamma1;
			var dif17 = clockwise13 ? theta13 : -theta13;
			dif15 = dif17 < 0 ? dif17 : -2 * Math.PI + dif17;
			break;
		case 2:
			var f28;
			if(0 > Math.PI) {
				f28 = 0;
			} else {
				var a28 = 0 % (2 * Math.PI);
				f28 = a28 >= 0 ? a28 : a28 + 2 * Math.PI;
			}
			var this49 = f28;
			var za14 = this49;
			var f29;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f29 = gamma1;
			} else {
				var a29 = gamma1 % (2 * Math.PI);
				f29 = a29 >= 0 ? a29 : a29 + 2 * Math.PI;
			}
			var this50 = f29;
			var zb14 = this50;
			var fa14 = 0;
			var fb14 = gamma1;
			var theta14 = Math.abs(0 - gamma1);
			var smallest3 = theta14 <= Math.PI;
			var clockwise14 = 0 < gamma1;
			var dif18 = clockwise14 ? theta14 : -theta14;
			dif15 = smallest3 ? dif18 : clockwise14 ? -(2 * Math.PI - theta14) : 2 * Math.PI - theta14;
			break;
		case 3:
			var f30;
			if(0 > Math.PI) {
				f30 = 0;
			} else {
				var a30 = 0 % (2 * Math.PI);
				f30 = a30 >= 0 ? a30 : a30 + 2 * Math.PI;
			}
			var this51 = f30;
			var za15 = this51;
			var f31;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f31 = gamma1;
			} else {
				var a31 = gamma1 % (2 * Math.PI);
				f31 = a31 >= 0 ? a31 : a31 + 2 * Math.PI;
			}
			var this52 = f31;
			var zb15 = this52;
			var fa15 = 0;
			var fb15 = gamma1;
			var theta15 = Math.abs(0 - gamma1);
			var largest3 = theta15 > Math.PI;
			var clockwise15 = 0 < gamma1;
			var dif19 = clockwise15 ? theta15 : -theta15;
			dif15 = largest3 ? dif19 : clockwise15 ? -(2 * Math.PI - theta15) : 2 * Math.PI - theta15;
			break;
		}
		var positive3 = dif15 >= 0;
		var totalSteps3 = Math.ceil(Math.abs(dif15) / step6);
		var step7 = dif15 / totalSteps3;
		var angle3 = 0;
		var cx7;
		var cy7;
		var bx7 = 0;
		var by7 = 0;
		var _g7 = 0;
		var _g13 = totalSteps3 + 1;
		while(_g7 < _g13) {
			var i3 = _g7++;
			cx7 = dx + radius * Math.sin(angle3);
			cy7 = dy + radius * Math.cos(angle3);
			if(i3 != 0) {
				var t20 = new trilateral_tri_Trilateral(dx,dy,bx7,by7,cx7,cy7);
				out4[out4.length] = t20;
			}
			angle3 += step7;
			bx7 = cx7;
			by7 = cy7;
		}
		var triArr3 = out4;
		var _g8 = 0;
		while(_g8 < triArr3.length) {
			var t21 = triArr3[_g8];
			++_g8;
			out[out.length] = t21;
		}
		var triArr4 = out;
		var tri;
		var _g9 = 0;
		while(_g9 < triArr4.length) {
			var t22 = triArr4[_g9];
			++_g9;
			if(t22 != null) {
				var t23 = Object.create(trilateral_tri_Triangle.prototype);
				t23.id = id;
				t23.ax = t22.ax;
				t23.ay = t22.ay;
				t23.bx = t22.bx;
				t23.by = t22.by;
				t23.cx = t22.cx;
				t23.cy = t22.cy;
				t23.mark = t22.mark;
				t23.depth = 0;
				t23.alpha = 1.;
				t23.colorID = color;
				t23.colorA = color;
				t23.colorB = color;
				t23.colorC = color;
				t23.windingAdjusted = t22.windingAdjusted;
				tri = t23;
				this1[this1.length] = tri;
			}
		}
		return this.refCount - 1;
	}
	,roundedRectangleOutline: function(x,y,width,height,thick,radius,color) {
		var this1 = this.triangles;
		var id = this.refCount++;
		var t = [];
		var this2;
		if(t == null) {
			var t1 = [];
			var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this2 = this3;
		} else {
			this2 = t;
		}
		var this4 = this2;
		var out = this4;
		var pi = Math.PI;
		var pi_2 = Math.PI / 2;
		var ax = x + radius;
		var ay = y + radius;
		var bx = x + width - radius;
		var by = y + radius;
		var cx = bx;
		var cy = y + height - radius;
		var dx = ax;
		var dy = cy;
		var ax1 = ax;
		var ay1 = y;
		var bx1 = ax + (width - radius * 2);
		var by1 = ay1;
		var cx1 = bx1;
		var cy1 = ay1 + thick;
		var dx1 = ax;
		var dy1 = cy1;
		var tp_t0 = new trilateral_tri_Trilateral(ax1,ay1,bx1,by1,dx1,dy1);
		var tp_t1 = new trilateral_tri_Trilateral(bx1,by1,cx1,cy1,dx1,dy1);
		out[out.length] = tp_t0;
		out[out.length] = tp_t1;
		var ax2 = ax;
		var ay2 = y + height - thick;
		var bx2 = ax + (width - radius * 2);
		var by2 = ay2;
		var cx2 = bx2;
		var cy2 = ay2 + thick;
		var dx2 = ax;
		var dy2 = cy2;
		var tp_t01 = new trilateral_tri_Trilateral(ax2,ay2,bx2,by2,dx2,dy2);
		var tp_t11 = new trilateral_tri_Trilateral(bx2,by2,cx2,cy2,dx2,dy2);
		out[out.length] = tp_t01;
		out[out.length] = tp_t11;
		var dimY = height - 2 * radius;
		var ax3 = x;
		var ay3 = ay;
		var bx3 = x + thick;
		var by3 = ay3;
		var cx3 = bx3;
		var cy3 = ay3 + dimY;
		var dx3 = x;
		var dy3 = cy3;
		var tp_t02 = new trilateral_tri_Trilateral(ax3,ay3,bx3,by3,dx3,dy3);
		var tp_t12 = new trilateral_tri_Trilateral(bx3,by3,cx3,cy3,dx3,dy3);
		out[out.length] = tp_t02;
		out[out.length] = tp_t12;
		var x1 = x + width - thick;
		var ax4 = x1;
		var ay4 = by;
		var bx4 = x1 + thick;
		var by4 = ay4;
		var cx4 = bx4;
		var cy4 = ay4 + dimY;
		var dx4 = x1;
		var dy4 = cy4;
		var tp_t03 = new trilateral_tri_Trilateral(ax4,ay4,bx4,by4,dx4,dy4);
		var tp_t13 = new trilateral_tri_Trilateral(bx4,by4,cx4,cy4,dx4,dy4);
		out[out.length] = tp_t03;
		out[out.length] = tp_t13;
		var beta = -pi;
		var gamma = -pi_2;
		var t2 = [];
		var this5;
		if(t2 == null) {
			var t3 = [];
			var this6;
			if(t3 == null) {
				var t4 = [];
				var this7 = t4 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t4;
				this6 = this7;
			} else {
				this6 = t3;
			}
			this5 = this6;
		} else {
			this5 = t2;
		}
		var this8 = this5;
		var out1 = this8;
		var pi1 = Math.PI;
		var step = pi1 * 2 / 36;
		var dif;
		switch(trilateral_angle_DifferencePreference.CLOCKWISE._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this9 = f;
			var za = this9;
			var f1;
			if(gamma >= 0 && gamma > Math.PI) {
				f1 = gamma;
			} else {
				var a1 = gamma % (2 * Math.PI);
				f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
			}
			var this10 = f1;
			var zb = this10;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(beta - gamma);
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f2;
			if(beta >= 0 && beta > Math.PI) {
				f2 = beta;
			} else {
				var a2 = beta % (2 * Math.PI);
				f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
			}
			var this11 = f2;
			var za1 = this11;
			var f3;
			if(gamma >= 0 && gamma > Math.PI) {
				f3 = gamma;
			} else {
				var a3 = gamma % (2 * Math.PI);
				f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
			}
			var this12 = f3;
			var zb1 = this12;
			var fa1 = za1;
			var fb1 = zb1;
			var theta1 = Math.abs(beta - gamma);
			var clockwise1 = beta < gamma;
			var dif2 = clockwise1 ? theta1 : -theta1;
			dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
			break;
		case 2:
			var f4;
			if(beta >= 0 && beta > Math.PI) {
				f4 = beta;
			} else {
				var a4 = beta % (2 * Math.PI);
				f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
			}
			var this13 = f4;
			var za2 = this13;
			var f5;
			if(gamma >= 0 && gamma > Math.PI) {
				f5 = gamma;
			} else {
				var a5 = gamma % (2 * Math.PI);
				f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
			}
			var this14 = f5;
			var zb2 = this14;
			var fa2 = beta;
			var fb2 = gamma;
			var theta2 = Math.abs(beta - gamma);
			var smallest = theta2 <= Math.PI;
			var clockwise2 = beta < gamma;
			var dif3 = clockwise2 ? theta2 : -theta2;
			dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
			break;
		case 3:
			var f6;
			if(beta >= 0 && beta > Math.PI) {
				f6 = beta;
			} else {
				var a6 = beta % (2 * Math.PI);
				f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
			}
			var this15 = f6;
			var za3 = this15;
			var f7;
			if(gamma >= 0 && gamma > Math.PI) {
				f7 = gamma;
			} else {
				var a7 = gamma % (2 * Math.PI);
				f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
			}
			var this16 = f7;
			var zb3 = this16;
			var fa3 = beta;
			var fb3 = gamma;
			var theta3 = Math.abs(beta - gamma);
			var largest = theta3 > Math.PI;
			var clockwise3 = beta < gamma;
			var dif4 = clockwise3 ? theta3 : -theta3;
			dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step1 = dif / totalSteps;
		var angle = beta;
		var cx5;
		var cy5;
		var bx5 = 0;
		var by5 = 0;
		var dx5 = 0;
		var dy5 = 0;
		var ex = 0;
		var ey = 0;
		var r2 = radius - thick;
		var _g = 0;
		var _g1 = totalSteps + 1;
		while(_g < _g1) {
			var i = _g++;
			cx5 = ax + radius * Math.sin(angle);
			cy5 = ay + radius * Math.cos(angle);
			ex = ax + r2 * Math.sin(angle);
			ey = ay + r2 * Math.cos(angle);
			if(i != 0) {
				var t0 = new trilateral_tri_Trilateral(dx5,dy5,bx5,by5,cx5,cy5);
				var t11 = new trilateral_tri_Trilateral(dx5,dy5,cx5,cy5,ex,ey);
				out1[out1.length] = t0;
				out1[out1.length] = t11;
			}
			angle += step1;
			bx5 = cx5;
			by5 = cy5;
			dx5 = ex;
			dy5 = ey;
		}
		var triArr = out1;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t5 = triArr[_g2];
			++_g2;
			out[out.length] = t5;
		}
		var t6 = [];
		var this17;
		if(t6 == null) {
			var t7 = [];
			var this18;
			if(t7 == null) {
				var t8 = [];
				var this19 = t8 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t8;
				this18 = this19;
			} else {
				this18 = t7;
			}
			this17 = this18;
		} else {
			this17 = t6;
		}
		var this20 = this17;
		var out2 = this20;
		var pi2 = Math.PI;
		var step2 = pi2 * 2 / 36;
		var dif5;
		switch(trilateral_angle_DifferencePreference.CLOCKWISE._hx_index) {
		case 0:
			var f8;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f8 = pi_2;
			} else {
				var a8 = pi_2 % (2 * Math.PI);
				f8 = a8 >= 0 ? a8 : a8 + 2 * Math.PI;
			}
			var this21 = f8;
			var za4 = this21;
			var f9;
			if(pi >= 0 && pi > Math.PI) {
				f9 = pi;
			} else {
				var a9 = pi % (2 * Math.PI);
				f9 = a9 >= 0 ? a9 : a9 + 2 * Math.PI;
			}
			var this22 = f9;
			var zb4 = this22;
			var fa4 = za4;
			var fb4 = zb4;
			var theta4 = Math.abs(pi_2 - pi);
			var clockwise4 = pi_2 < pi;
			var dif6 = clockwise4 ? theta4 : -theta4;
			dif5 = dif6 > 0 ? dif6 : 2 * Math.PI + dif6;
			break;
		case 1:
			var f10;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f10 = pi_2;
			} else {
				var a10 = pi_2 % (2 * Math.PI);
				f10 = a10 >= 0 ? a10 : a10 + 2 * Math.PI;
			}
			var this23 = f10;
			var za5 = this23;
			var f11;
			if(pi >= 0 && pi > Math.PI) {
				f11 = pi;
			} else {
				var a11 = pi % (2 * Math.PI);
				f11 = a11 >= 0 ? a11 : a11 + 2 * Math.PI;
			}
			var this24 = f11;
			var zb5 = this24;
			var fa5 = za5;
			var fb5 = zb5;
			var theta5 = Math.abs(pi_2 - pi);
			var clockwise5 = pi_2 < pi;
			var dif7 = clockwise5 ? theta5 : -theta5;
			dif5 = dif7 < 0 ? dif7 : -2 * Math.PI + dif7;
			break;
		case 2:
			var f12;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f12 = pi_2;
			} else {
				var a12 = pi_2 % (2 * Math.PI);
				f12 = a12 >= 0 ? a12 : a12 + 2 * Math.PI;
			}
			var this25 = f12;
			var za6 = this25;
			var f13;
			if(pi >= 0 && pi > Math.PI) {
				f13 = pi;
			} else {
				var a13 = pi % (2 * Math.PI);
				f13 = a13 >= 0 ? a13 : a13 + 2 * Math.PI;
			}
			var this26 = f13;
			var zb6 = this26;
			var fa6 = pi_2;
			var fb6 = pi;
			var theta6 = Math.abs(pi_2 - pi);
			var smallest1 = theta6 <= Math.PI;
			var clockwise6 = pi_2 < pi;
			var dif8 = clockwise6 ? theta6 : -theta6;
			dif5 = smallest1 ? dif8 : clockwise6 ? -(2 * Math.PI - theta6) : 2 * Math.PI - theta6;
			break;
		case 3:
			var f14;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f14 = pi_2;
			} else {
				var a14 = pi_2 % (2 * Math.PI);
				f14 = a14 >= 0 ? a14 : a14 + 2 * Math.PI;
			}
			var this27 = f14;
			var za7 = this27;
			var f15;
			if(pi >= 0 && pi > Math.PI) {
				f15 = pi;
			} else {
				var a15 = pi % (2 * Math.PI);
				f15 = a15 >= 0 ? a15 : a15 + 2 * Math.PI;
			}
			var this28 = f15;
			var zb7 = this28;
			var fa7 = pi_2;
			var fb7 = pi;
			var theta7 = Math.abs(pi_2 - pi);
			var largest1 = theta7 > Math.PI;
			var clockwise7 = pi_2 < pi;
			var dif9 = clockwise7 ? theta7 : -theta7;
			dif5 = largest1 ? dif9 : clockwise7 ? -(2 * Math.PI - theta7) : 2 * Math.PI - theta7;
			break;
		}
		var positive1 = dif5 >= 0;
		var totalSteps1 = Math.ceil(Math.abs(dif5) / step2);
		var step3 = dif5 / totalSteps1;
		var angle1 = pi_2;
		var cx6;
		var cy6;
		var bx6 = 0;
		var by6 = 0;
		var dx6 = 0;
		var dy6 = 0;
		var ex1 = 0;
		var ey1 = 0;
		var r21 = radius - thick;
		var _g3 = 0;
		var _g11 = totalSteps1 + 1;
		while(_g3 < _g11) {
			var i1 = _g3++;
			cx6 = bx + radius * Math.sin(angle1);
			cy6 = by + radius * Math.cos(angle1);
			ex1 = bx + r21 * Math.sin(angle1);
			ey1 = by + r21 * Math.cos(angle1);
			if(i1 != 0) {
				var t01 = new trilateral_tri_Trilateral(dx6,dy6,bx6,by6,cx6,cy6);
				var t12 = new trilateral_tri_Trilateral(dx6,dy6,cx6,cy6,ex1,ey1);
				out2[out2.length] = t01;
				out2[out2.length] = t12;
			}
			angle1 += step3;
			bx6 = cx6;
			by6 = cy6;
			dx6 = ex1;
			dy6 = ey1;
		}
		var triArr1 = out2;
		var _g4 = 0;
		while(_g4 < triArr1.length) {
			var t9 = triArr1[_g4];
			++_g4;
			out[out.length] = t9;
		}
		var t10 = [];
		var this29;
		if(t10 == null) {
			var t13 = [];
			var this30;
			if(t13 == null) {
				var t14 = [];
				var this31 = t14 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t14;
				this30 = this31;
			} else {
				this30 = t13;
			}
			this29 = this30;
		} else {
			this29 = t10;
		}
		var this32 = this29;
		var out3 = this32;
		var pi3 = Math.PI;
		var step4 = pi3 * 2 / 36;
		var dif10;
		switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE._hx_index) {
		case 0:
			var f16;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f16 = pi_2;
			} else {
				var a16 = pi_2 % (2 * Math.PI);
				f16 = a16 >= 0 ? a16 : a16 + 2 * Math.PI;
			}
			var this33 = f16;
			var za8 = this33;
			var f17;
			if(0 > Math.PI) {
				f17 = 0;
			} else {
				var a17 = 0 % (2 * Math.PI);
				f17 = a17 >= 0 ? a17 : a17 + 2 * Math.PI;
			}
			var this34 = f17;
			var zb8 = this34;
			var fa8 = za8;
			var fb8 = zb8;
			var theta8 = Math.abs(pi_2);
			var clockwise8 = pi_2 < 0;
			var dif11 = clockwise8 ? theta8 : -theta8;
			dif10 = dif11 > 0 ? dif11 : 2 * Math.PI + dif11;
			break;
		case 1:
			var f18;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f18 = pi_2;
			} else {
				var a18 = pi_2 % (2 * Math.PI);
				f18 = a18 >= 0 ? a18 : a18 + 2 * Math.PI;
			}
			var this35 = f18;
			var za9 = this35;
			var f19;
			if(0 > Math.PI) {
				f19 = 0;
			} else {
				var a19 = 0 % (2 * Math.PI);
				f19 = a19 >= 0 ? a19 : a19 + 2 * Math.PI;
			}
			var this36 = f19;
			var zb9 = this36;
			var fa9 = za9;
			var fb9 = zb9;
			var theta9 = Math.abs(pi_2);
			var clockwise9 = pi_2 < 0;
			var dif12 = clockwise9 ? theta9 : -theta9;
			dif10 = dif12 < 0 ? dif12 : -2 * Math.PI + dif12;
			break;
		case 2:
			var f20;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f20 = pi_2;
			} else {
				var a20 = pi_2 % (2 * Math.PI);
				f20 = a20 >= 0 ? a20 : a20 + 2 * Math.PI;
			}
			var this37 = f20;
			var za10 = this37;
			var f21;
			if(0 > Math.PI) {
				f21 = 0;
			} else {
				var a21 = 0 % (2 * Math.PI);
				f21 = a21 >= 0 ? a21 : a21 + 2 * Math.PI;
			}
			var this38 = f21;
			var zb10 = this38;
			var fa10 = pi_2;
			var fb10 = 0;
			var theta10 = Math.abs(pi_2);
			var smallest2 = theta10 <= Math.PI;
			var clockwise10 = pi_2 < 0;
			var dif13 = clockwise10 ? theta10 : -theta10;
			dif10 = smallest2 ? dif13 : clockwise10 ? -(2 * Math.PI - theta10) : 2 * Math.PI - theta10;
			break;
		case 3:
			var f22;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f22 = pi_2;
			} else {
				var a22 = pi_2 % (2 * Math.PI);
				f22 = a22 >= 0 ? a22 : a22 + 2 * Math.PI;
			}
			var this39 = f22;
			var za11 = this39;
			var f23;
			if(0 > Math.PI) {
				f23 = 0;
			} else {
				var a23 = 0 % (2 * Math.PI);
				f23 = a23 >= 0 ? a23 : a23 + 2 * Math.PI;
			}
			var this40 = f23;
			var zb11 = this40;
			var fa11 = pi_2;
			var fb11 = 0;
			var theta11 = Math.abs(pi_2);
			var largest2 = theta11 > Math.PI;
			var clockwise11 = pi_2 < 0;
			var dif14 = clockwise11 ? theta11 : -theta11;
			dif10 = largest2 ? dif14 : clockwise11 ? -(2 * Math.PI - theta11) : 2 * Math.PI - theta11;
			break;
		}
		var positive2 = dif10 >= 0;
		var totalSteps2 = Math.ceil(Math.abs(dif10) / step4);
		var step5 = dif10 / totalSteps2;
		var angle2 = pi_2;
		var cx7;
		var cy7;
		var bx7 = 0;
		var by7 = 0;
		var dx7 = 0;
		var dy7 = 0;
		var ex2 = 0;
		var ey2 = 0;
		var r22 = radius - thick;
		var _g5 = 0;
		var _g12 = totalSteps2 + 1;
		while(_g5 < _g12) {
			var i2 = _g5++;
			cx7 = cx + radius * Math.sin(angle2);
			cy7 = cy + radius * Math.cos(angle2);
			ex2 = cx + r22 * Math.sin(angle2);
			ey2 = cy + r22 * Math.cos(angle2);
			if(i2 != 0) {
				var t02 = new trilateral_tri_Trilateral(dx7,dy7,bx7,by7,cx7,cy7);
				var t15 = new trilateral_tri_Trilateral(dx7,dy7,cx7,cy7,ex2,ey2);
				out3[out3.length] = t02;
				out3[out3.length] = t15;
			}
			angle2 += step5;
			bx7 = cx7;
			by7 = cy7;
			dx7 = ex2;
			dy7 = ey2;
		}
		var triArr2 = out3;
		var _g6 = 0;
		while(_g6 < triArr2.length) {
			var t16 = triArr2[_g6];
			++_g6;
			out[out.length] = t16;
		}
		var gamma1 = -pi_2;
		var t17 = [];
		var this41;
		if(t17 == null) {
			var t18 = [];
			var this42;
			if(t18 == null) {
				var t19 = [];
				var this43 = t19 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t19;
				this42 = this43;
			} else {
				this42 = t18;
			}
			this41 = this42;
		} else {
			this41 = t17;
		}
		var this44 = this41;
		var out4 = this44;
		var pi4 = Math.PI;
		var step6 = pi4 * 2 / 36;
		var dif15;
		switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE._hx_index) {
		case 0:
			var f24;
			if(0 > Math.PI) {
				f24 = 0;
			} else {
				var a24 = 0 % (2 * Math.PI);
				f24 = a24 >= 0 ? a24 : a24 + 2 * Math.PI;
			}
			var this45 = f24;
			var za12 = this45;
			var f25;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f25 = gamma1;
			} else {
				var a25 = gamma1 % (2 * Math.PI);
				f25 = a25 >= 0 ? a25 : a25 + 2 * Math.PI;
			}
			var this46 = f25;
			var zb12 = this46;
			var fa12 = za12;
			var fb12 = zb12;
			var theta12 = Math.abs(0 - gamma1);
			var clockwise12 = 0 < gamma1;
			var dif16 = clockwise12 ? theta12 : -theta12;
			dif15 = dif16 > 0 ? dif16 : 2 * Math.PI + dif16;
			break;
		case 1:
			var f26;
			if(0 > Math.PI) {
				f26 = 0;
			} else {
				var a26 = 0 % (2 * Math.PI);
				f26 = a26 >= 0 ? a26 : a26 + 2 * Math.PI;
			}
			var this47 = f26;
			var za13 = this47;
			var f27;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f27 = gamma1;
			} else {
				var a27 = gamma1 % (2 * Math.PI);
				f27 = a27 >= 0 ? a27 : a27 + 2 * Math.PI;
			}
			var this48 = f27;
			var zb13 = this48;
			var fa13 = za13;
			var fb13 = zb13;
			var theta13 = Math.abs(0 - gamma1);
			var clockwise13 = 0 < gamma1;
			var dif17 = clockwise13 ? theta13 : -theta13;
			dif15 = dif17 < 0 ? dif17 : -2 * Math.PI + dif17;
			break;
		case 2:
			var f28;
			if(0 > Math.PI) {
				f28 = 0;
			} else {
				var a28 = 0 % (2 * Math.PI);
				f28 = a28 >= 0 ? a28 : a28 + 2 * Math.PI;
			}
			var this49 = f28;
			var za14 = this49;
			var f29;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f29 = gamma1;
			} else {
				var a29 = gamma1 % (2 * Math.PI);
				f29 = a29 >= 0 ? a29 : a29 + 2 * Math.PI;
			}
			var this50 = f29;
			var zb14 = this50;
			var fa14 = 0;
			var fb14 = gamma1;
			var theta14 = Math.abs(0 - gamma1);
			var smallest3 = theta14 <= Math.PI;
			var clockwise14 = 0 < gamma1;
			var dif18 = clockwise14 ? theta14 : -theta14;
			dif15 = smallest3 ? dif18 : clockwise14 ? -(2 * Math.PI - theta14) : 2 * Math.PI - theta14;
			break;
		case 3:
			var f30;
			if(0 > Math.PI) {
				f30 = 0;
			} else {
				var a30 = 0 % (2 * Math.PI);
				f30 = a30 >= 0 ? a30 : a30 + 2 * Math.PI;
			}
			var this51 = f30;
			var za15 = this51;
			var f31;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f31 = gamma1;
			} else {
				var a31 = gamma1 % (2 * Math.PI);
				f31 = a31 >= 0 ? a31 : a31 + 2 * Math.PI;
			}
			var this52 = f31;
			var zb15 = this52;
			var fa15 = 0;
			var fb15 = gamma1;
			var theta15 = Math.abs(0 - gamma1);
			var largest3 = theta15 > Math.PI;
			var clockwise15 = 0 < gamma1;
			var dif19 = clockwise15 ? theta15 : -theta15;
			dif15 = largest3 ? dif19 : clockwise15 ? -(2 * Math.PI - theta15) : 2 * Math.PI - theta15;
			break;
		}
		var positive3 = dif15 >= 0;
		var totalSteps3 = Math.ceil(Math.abs(dif15) / step6);
		var step7 = dif15 / totalSteps3;
		var angle3 = 0;
		var cx8;
		var cy8;
		var bx8 = 0;
		var by8 = 0;
		var dx8 = 0;
		var dy8 = 0;
		var ex3 = 0;
		var ey3 = 0;
		var r23 = radius - thick;
		var _g7 = 0;
		var _g13 = totalSteps3 + 1;
		while(_g7 < _g13) {
			var i3 = _g7++;
			cx8 = dx + radius * Math.sin(angle3);
			cy8 = dy + radius * Math.cos(angle3);
			ex3 = dx + r23 * Math.sin(angle3);
			ey3 = dy + r23 * Math.cos(angle3);
			if(i3 != 0) {
				var t03 = new trilateral_tri_Trilateral(dx8,dy8,bx8,by8,cx8,cy8);
				var t110 = new trilateral_tri_Trilateral(dx8,dy8,cx8,cy8,ex3,ey3);
				out4[out4.length] = t03;
				out4[out4.length] = t110;
			}
			angle3 += step7;
			bx8 = cx8;
			by8 = cy8;
			dx8 = ex3;
			dy8 = ey3;
		}
		var triArr3 = out4;
		var _g8 = 0;
		while(_g8 < triArr3.length) {
			var t20 = triArr3[_g8];
			++_g8;
			out[out.length] = t20;
		}
		var triArr4 = out;
		var tri;
		var _g9 = 0;
		while(_g9 < triArr4.length) {
			var t21 = triArr4[_g9];
			++_g9;
			if(t21 != null) {
				var t22 = Object.create(trilateral_tri_Triangle.prototype);
				t22.id = id;
				t22.ax = t21.ax;
				t22.ay = t21.ay;
				t22.bx = t21.bx;
				t22.by = t21.by;
				t22.cx = t21.cx;
				t22.cy = t21.cy;
				t22.mark = t21.mark;
				t22.depth = 0;
				t22.alpha = 1.;
				t22.colorID = color;
				t22.colorA = color;
				t22.colorB = color;
				t22.colorC = color;
				t22.windingAdjusted = t21.windingAdjusted;
				tri = t22;
				this1[this1.length] = tri;
			}
		}
		return this.refCount - 1;
	}
	,spiralLines: function(x,y,radius,nolines,startWid,stepWid,color) {
		var theta = 0.;
		var line;
		var wid = startWid;
		var _g = 0;
		var _g1 = nolines;
		while(_g < _g1) {
			var i = _g++;
			var p0_x = x;
			var p0_y = y;
			var p1_x = x + radius * Math.sin(theta);
			var p1_y = y + radius * Math.cos(theta);
			theta += Math.PI * 2 / nolines;
			var width = wid += stepWid;
			var dx = p0_x - p1_x;
			var dy = p0_y - p1_y;
			var P_x = p0_x - width / 2;
			var P_y = p0_y;
			var omega = Math.atan2(dy,dx);
			var dim_x = width;
			var dim_y = dx * dx + dy * dy;
			var pivotX = p0_x + width / 2;
			var pivotY = p0_y;
			var px = P_x;
			var py = P_y;
			var dx1 = dim_x;
			var dy1 = dim_y;
			var A_ = { x : px, y : py};
			var B_ = { x : px + dx1, y : py};
			var C_ = { x : px + dx1, y : py + dy1};
			var D_ = { x : px, y : py + dy1};
			if(omega != 0.) {
				var sin = Math.sin(omega);
				var cos = Math.cos(omega);
				var px1 = A_.x - pivotX;
				var py1 = A_.y - pivotY;
				var px2 = px1 * cos - py1 * sin;
				py1 = py1 * cos + px1 * sin;
				A_ = { x : px2 + pivotX, y : py1 + pivotY};
				var px3 = B_.x - pivotX;
				var py2 = B_.y - pivotY;
				var px21 = px3 * cos - py2 * sin;
				py2 = py2 * cos + px3 * sin;
				B_ = { x : px21 + pivotX, y : py2 + pivotY};
				var px4 = C_.x - pivotX;
				var py3 = C_.y - pivotY;
				var px22 = px4 * cos - py3 * sin;
				py3 = py3 * cos + px4 * sin;
				C_ = { x : px22 + pivotX, y : py3 + pivotY};
				var px5 = D_.x - pivotX;
				var py4 = D_.y - pivotY;
				var px23 = px5 * cos - py4 * sin;
				py4 = py4 * cos + px5 * sin;
				D_ = { x : px23 + pivotX, y : py4 + pivotY};
			}
			var q_A = A_;
			var q_B = B_;
			var q_C = C_;
			var q_D = D_;
			line = { t0 : new trilateral_tri_Trilateral(q_A.x,q_A.y,q_B.x,q_B.y,q_D.x,q_D.y), t1 : new trilateral_tri_Trilateral(q_B.x,q_B.y,q_C.x,q_C.y,q_D.x,q_D.y)};
			var this1 = this.triangles;
			var id = this.refCount;
			var tri = line.t0;
			var t = Object.create(trilateral_tri_Triangle.prototype);
			t.id = id;
			t.ax = tri.ax;
			t.ay = tri.ay;
			t.bx = tri.bx;
			t.by = tri.by;
			t.cx = tri.cx;
			t.cy = tri.cy;
			t.mark = tri.mark;
			t.depth = 0;
			t.alpha = 1.;
			t.colorID = color;
			t.colorA = color;
			t.colorB = color;
			t.colorC = color;
			t.windingAdjusted = tri.windingAdjusted;
			var tri0 = t;
			this1[this1.length] = tri0;
			var tri1 = line.t1;
			var t1 = Object.create(trilateral_tri_Triangle.prototype);
			t1.id = id;
			t1.ax = tri1.ax;
			t1.ay = tri1.ay;
			t1.bx = tri1.bx;
			t1.by = tri1.by;
			t1.cx = tri1.cx;
			t1.cy = tri1.cy;
			t1.mark = tri1.mark;
			t1.depth = 0;
			t1.alpha = 1.;
			t1.colorID = color;
			t1.colorA = color;
			t1.colorB = color;
			t1.colorC = color;
			t1.windingAdjusted = tri1.windingAdjusted;
			var tri11 = t1;
			this1[this1.length] = tri11;
		}
		this.refCount++;
		return this.refCount - 1;
	}
};
var trilateral_tri_Trilateral = function(ax_,ay_,bx_,by_,cx_,cy_,mark_) {
	if(mark_ == null) {
		mark_ = 0;
	}
	this.mark = 0;
	this.ax = ax_;
	this.ay = ay_;
	this.bx = bx_;
	this.by = by_;
	this.cx = cx_;
	this.cy = cy_;
	this.windingAdjusted = this.adjustWinding();
	if(this.windingAdjusted) {
		this.ax = ax_;
		this.ay = ay_;
		this.bx = cx_;
		this.by = cy_;
		this.cx = bx_;
		this.cy = by_;
	}
	this.mark = mark_;
};
trilateral_tri_Trilateral.__name__ = true;
trilateral_tri_Trilateral.prototype = {
	get_x: function() {
		return Math.min(Math.min(this.ax,this.bx),this.cx);
	}
	,set_x: function(x) {
		var dx = x - this.get_x();
		this.ax += dx;
		this.bx += dx;
		this.cx += dx;
		return x;
	}
	,get_y: function() {
		return Math.min(Math.min(this.ay,this.by),this.cy);
	}
	,set_y: function(y) {
		var dy = y - this.get_y();
		this.ay += dy;
		this.by += dy;
		this.cy += dy;
		return y;
	}
	,get_right: function() {
		return Math.max(Math.max(this.ax,this.bx),this.cx);
	}
	,get_bottom: function() {
		return Math.max(Math.max(this.ay,this.by),this.cy);
	}
	,moveDelta: function(dx,dy) {
		this.ax += dx;
		this.ay += dy;
		this.bx += dx;
		this.by += dy;
		this.cx += dx;
		this.cy += dy;
	}
	,liteHit: function(px,py) {
		var planeAB = (this.ax - px) * (this.by - py) - (this.bx - px) * (this.ay - py);
		var planeBC = (this.bx - px) * (this.cy - py) - (this.cx - px) * (this.by - py);
		var planeCA = (this.cx - px) * (this.ay - py) - (this.ax - px) * (this.cy - py);
		if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0)) {
			return (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0);
		} else {
			return false;
		}
	}
	,fullHit: function(px,py) {
		if(px > this.get_x() && px < this.get_right() && py > this.get_y() && py < this.get_bottom()) {
			return true;
		}
		var planeAB = (this.ax - px) * (this.by - py) - (this.bx - px) * (this.ay - py);
		var planeBC = (this.bx - px) * (this.cy - py) - (this.cx - px) * (this.by - py);
		var planeCA = (this.cx - px) * (this.ay - py) - (this.ax - px) * (this.cy - py);
		if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0)) {
			return (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0);
		} else {
			return false;
		}
	}
	,adjustWinding: function() {
		return this.ax * this.by - this.bx * this.ay + (this.bx * this.cy - this.cx * this.by) + (this.cx * this.ay - this.ax * this.cy) > 0;
	}
	,rotate: function(x,y,theta) {
		var cos = Math.cos(theta);
		var sin = Math.sin(theta);
		this.ax -= x;
		this.ay -= y;
		this.bx -= x;
		this.by -= y;
		this.cx -= x;
		this.cy -= y;
		var dx = this.ax;
		var dy = this.ay;
		this.ax = dx * cos - dy * sin;
		this.ay = dx * sin + dy * cos;
		dx = this.bx;
		dy = this.by;
		this.bx = dx * cos - dy * sin;
		this.by = dx * sin + dy * cos;
		dx = this.cx;
		dy = this.cy;
		this.cx = dx * cos - dy * sin;
		this.cy = dx * sin + dy * cos;
		this.ax += x;
		this.ay += y;
		this.bx += x;
		this.by += y;
		this.cx += x;
		this.cy += y;
	}
	,rotateTrig: function(x,y,cos,sin) {
		this.ax -= x;
		this.ay -= y;
		this.bx -= x;
		this.by -= y;
		this.cx -= x;
		this.cy -= y;
		var dx = this.ax;
		var dy = this.ay;
		this.ax = dx * cos - dy * sin;
		this.ay = dx * sin + dy * cos;
		dx = this.bx;
		dy = this.by;
		this.bx = dx * cos - dy * sin;
		this.by = dx * sin + dy * cos;
		dx = this.cx;
		dy = this.cy;
		this.cx = dx * cos - dy * sin;
		this.cy = dx * sin + dy * cos;
		this.ax += x;
		this.ay += y;
		this.bx += x;
		this.by += y;
		this.cx += x;
		this.cy += y;
	}
};
var trilateral_tri_Triangle = function(id_,A,B,C,depth_,colorID_) {
	this.id = id_;
	trilateral_tri_Trilateral.call(this,A.x,A.y,B.x,B.y,C.x,C.y);
	this.depth = depth_;
	this.alpha = 1.;
	this.colorID = colorID_;
	this.colorA = colorID_;
	this.colorB = colorID_;
	this.colorC = colorID_;
};
trilateral_tri_Triangle.__name__ = true;
trilateral_tri_Triangle.fromTrilateral = function(id_,tri,depth_,colorID_) {
	var t = Object.create(trilateral_tri_Triangle.prototype);
	t.id = id_;
	t.ax = tri.ax;
	t.ay = tri.ay;
	t.bx = tri.bx;
	t.by = tri.by;
	t.cx = tri.cx;
	t.cy = tri.cy;
	t.mark = tri.mark;
	t.depth = depth_;
	t.alpha = 1.;
	t.colorID = colorID_;
	t.colorA = colorID_;
	t.colorB = colorID_;
	t.colorC = colorID_;
	t.windingAdjusted = tri.windingAdjusted;
	return t;
};
trilateral_tri_Triangle.__super__ = trilateral_tri_Trilateral;
trilateral_tri_Triangle.prototype = $extend(trilateral_tri_Trilateral.prototype,{
	hitTest: function(P) {
		return this.fullHit(P.x,P.y);
	}
	,drawStrips: function(drawRect) {
		var xi = Math.floor(this.get_x());
		var yi = Math.floor(this.get_y());
		var righti = Math.ceil(this.get_right());
		var bottomi = Math.ceil(this.get_bottom());
		var sx = 0;
		var ex = 0;
		var sFound;
		var eFound;
		var _g = yi;
		var _g1 = bottomi;
		while(_g < _g1) {
			var y0 = _g++;
			sFound = false;
			eFound = false;
			var _g2 = xi;
			var _g11 = righti;
			while(_g2 < _g11) {
				var x0 = _g2++;
				var planeAB = (this.ax - x0) * (this.by - y0) - (this.bx - x0) * (this.ay - y0);
				var planeBC = (this.bx - x0) * (this.cy - y0) - (this.cx - x0) * (this.by - y0);
				var planeCA = (this.cx - x0) * (this.ay - y0) - (this.ax - x0) * (this.cy - y0);
				if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0) && (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0)) {
					sx = x0;
					sFound = true;
					break;
				}
			}
			if(sFound) {
				var _g21 = sx;
				var _g3 = righti;
				while(_g21 < _g3) {
					var x01 = _g21++;
					var planeAB1 = (this.ax - x01) * (this.by - y0) - (this.bx - x01) * (this.ay - y0);
					var planeBC1 = (this.bx - x01) * (this.cy - y0) - (this.cx - x01) * (this.by - y0);
					var planeCA1 = (this.cx - x01) * (this.ay - y0) - (this.ax - x01) * (this.cy - y0);
					if(!((Math.abs(planeAB1) / planeAB1 | 0) == (Math.abs(planeBC1) / planeBC1 | 0) && (Math.abs(planeBC1) / planeBC1 | 0) == (Math.abs(planeCA1) / planeCA1 | 0))) {
						ex = x01;
						eFound = true;
						break;
					}
				}
				if(eFound) {
					drawRect(sx,y0,ex - sx,1);
				}
			}
		}
	}
});
var trilateral_tri__$TriangleArray_TriangleArray_$Impl_$ = {};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.__name__ = true;
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new = function(t) {
	var this1 = t == null ? trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new([]) : t;
	return this1;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.changeFillColorByID = function(this1,id,colorID,startID,endID) {
	if(endID == null) {
		endID = 0;
	}
	if(startID == null) {
		startID = 0;
	}
	var tri;
	if(endID == 0) {
		endID = this1.length;
	}
	var _g = startID;
	var _g1 = endID;
	while(_g < _g1) {
		var i = _g++;
		tri = this1[i];
		if(tri.id == id) {
			tri.colorID = colorID;
			tri.colorA = colorID;
			tri.colorB = colorID;
			tri.colorC = colorID;
		}
	}
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.getEmpty = function() {
	var t = [];
	var this1 = t == null ? trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new([]) : t;
	return this1;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.clear = function(this1) {
	var t = [];
	var this2 = t == null ? trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new([]) : t;
	var this3 = this2;
	this1 = this3;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.pushPair = function(this1,tp) {
	this1[this1.length] = tp.t0;
	this1[this1.length] = tp.t1;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.drawTriangle = function(this1,id,p0,p1,p2,colorID) {
	var tri = new trilateral_tri_Triangle(id,p0,p1,p2,0,colorID);
	this1[this1.length] = tri;
	return tri;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.add = function(this1,id,tri,colorID) {
	var t = Object.create(trilateral_tri_Triangle.prototype);
	t.id = id;
	t.ax = tri.ax;
	t.ay = tri.ay;
	t.bx = tri.bx;
	t.by = tri.by;
	t.cx = tri.cx;
	t.cy = tri.cy;
	t.mark = tri.mark;
	t.depth = 0;
	t.alpha = 1.;
	t.colorID = colorID;
	t.colorA = colorID;
	t.colorB = colorID;
	t.colorC = colorID;
	t.windingAdjusted = tri.windingAdjusted;
	var tri1 = t;
	this1[this1.length] = tri1;
	return tri1;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.addPair = function(this1,id,tri,colorID) {
	var tri1 = tri.t0;
	var t = Object.create(trilateral_tri_Triangle.prototype);
	t.id = id;
	t.ax = tri1.ax;
	t.ay = tri1.ay;
	t.bx = tri1.bx;
	t.by = tri1.by;
	t.cx = tri1.cx;
	t.cy = tri1.cy;
	t.mark = tri1.mark;
	t.depth = 0;
	t.alpha = 1.;
	t.colorID = colorID;
	t.colorA = colorID;
	t.colorB = colorID;
	t.colorC = colorID;
	t.windingAdjusted = tri1.windingAdjusted;
	var tri0 = t;
	this1[this1.length] = tri0;
	var tri2 = tri.t1;
	var t1 = Object.create(trilateral_tri_Triangle.prototype);
	t1.id = id;
	t1.ax = tri2.ax;
	t1.ay = tri2.ay;
	t1.bx = tri2.bx;
	t1.by = tri2.by;
	t1.cx = tri2.cx;
	t1.cy = tri2.cy;
	t1.mark = tri2.mark;
	t1.depth = 0;
	t1.alpha = 1.;
	t1.colorID = colorID;
	t1.colorA = colorID;
	t1.colorB = colorID;
	t1.colorC = colorID;
	t1.windingAdjusted = tri2.windingAdjusted;
	var tri11 = t1;
	this1[this1.length] = tri11;
	return tri;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.addArray = function(this1,id,triArr,colorID) {
	var tri;
	var _g = 0;
	while(_g < triArr.length) {
		var t = triArr[_g];
		++_g;
		if(t != null) {
			var t1 = Object.create(trilateral_tri_Triangle.prototype);
			t1.id = id;
			t1.ax = t.ax;
			t1.ay = t.ay;
			t1.bx = t.bx;
			t1.by = t.by;
			t1.cx = t.cx;
			t1.cy = t.cy;
			t1.mark = t.mark;
			t1.depth = 0;
			t1.alpha = 1.;
			t1.colorID = colorID;
			t1.colorA = colorID;
			t1.colorB = colorID;
			t1.colorC = colorID;
			t1.windingAdjusted = t.windingAdjusted;
			tri = t1;
			this1[this1.length] = tri;
		}
	}
	return triArr;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.getTriangles = function(this1,id) {
	var t = [];
	var this2 = t == null ? trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new([]) : t;
	var this3 = this2;
	var out = this3;
	var _g = 0;
	var _g1 = this1.length;
	while(_g < _g1) {
		var i = _g++;
		if(this1[i].id == id) {
			out[out.length] = this1[i];
		}
	}
	return out;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.getHitTriangles = function(this1,p) {
	var t = [];
	var this2 = t == null ? trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new([]) : t;
	var this3 = this2;
	var out = this3;
	var _g = 0;
	var _g1 = this1.length;
	while(_g < _g1) {
		var i = _g++;
		if(this1[i].hitTest(p)) {
			out[out.length] = this1[i];
		}
	}
	return out;
};
var trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$ = {};
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$.__name__ = true;
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new = function(t) {
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	return this1;
};
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$.reversed = function(this1) {
	this1.reverse();
	return this1;
};
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$.getEmpty = function() {
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	return this1;
};
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$.clear = function(this1) {
	var t = [];
	var this2 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this3 = this2;
	this1 = this3;
};
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$.add = function(this1,tri) {
	this1[this1.length] = tri;
};
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$.addPair = function(this1,tp) {
	this1[this1.length] = tp.t0;
	this1[this1.length] = tp.t1;
};
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$.addArray = function(this1,triArr) {
	var _g = 0;
	while(_g < triArr.length) {
		var t = triArr[_g];
		++_g;
		this1[this1.length] = t;
	}
	return triArr;
};
var $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
String.__name__ = true;
Array.__name__ = true;
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
htmlHelper_tools_AnimateTimer.counter = 0;
justDrawing_Surface.cubicStep = 0.03;
trilateral_geom_Algebra.quadStep = 0.03;
trilateral_geom_Algebra.cubicStep = 0.03;
trilateral_geom_Contour.smallDotScale = 0.07;
Main.main();
})();

//# sourceMappingURL=constraintTest.js.map