// Generated by Haxe 4.0.0-preview.5+83d9c11
(function ($hx_exports) { "use strict";
$hx_exports["hxGeomAlgo"] = $hx_exports["hxGeomAlgo"] || {};
$hx_exports["hxGeomAlgo"]["_HxPoint"] = $hx_exports["hxGeomAlgo"]["_HxPoint"] || {};
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
var htmlHelper_webgl_WebGLSetup = function(width_,height_,autoChild) {
	if(autoChild == null) {
		autoChild = true;
	}
	this.colors = [];
	this.indices = [];
	this.vertices = [];
	this.matrix32Array = new Float32Array([1.0,0.0,0.0,0.0,0.0,1.1,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0]);
	this.modelViewProjection = new khaMath_Matrix4(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);
	this.bgAlpha = 1.;
	this.bgBlue = 1.;
	this.bgGreen = 1.;
	this.bgRed = 1.;
	this.width = width_;
	this.height = height_;
	this.canvas = window.document.createElement("canvas");
	this.canvas.width = this.width;
	this.canvas.height = this.height;
	var dom = this.canvas;
	var style = dom.style;
	style.paddingLeft = "0px";
	style.paddingTop = "0px";
	style.left = Std.string(0 + "px");
	style.top = Std.string(0 + "px");
	style.position = "absolute";
	if(autoChild) {
		window.document.body.appendChild(this.canvas);
	}
	this.gl = js_html__$CanvasElement_CanvasUtil.getContextWebGL(this.canvas,null);
};
htmlHelper_webgl_WebGLSetup.__name__ = true;
htmlHelper_webgl_WebGLSetup.createVertexShader = function(gl,str) {
	var vertexShader = gl.createShader(35633);
	gl.shaderSource(vertexShader,str);
	gl.compileShader(vertexShader);
	return vertexShader;
};
htmlHelper_webgl_WebGLSetup.createFragmentShader = function(gl,str) {
	var fragmentShader = gl.createShader(35632);
	gl.shaderSource(fragmentShader,str);
	gl.compileShader(fragmentShader);
	return fragmentShader;
};
htmlHelper_webgl_WebGLSetup.createShaderProgram = function(gl,vertex,fragment) {
	var program = gl.createProgram();
	gl.attachShader(program,vertex);
	gl.attachShader(program,fragment);
	gl.linkProgram(program);
	gl.useProgram(program);
	return program;
};
htmlHelper_webgl_WebGLSetup.uploadTriangleDataToBuffers = function(gl,program,vertices,indices) {
	var vertexBuffer = gl.createBuffer();
	gl.bindBuffer(34962,vertexBuffer);
	gl.bufferData(34962,new Float32Array(vertices),35044);
	var position = gl.getAttribLocation(program,"pos");
	gl.vertexAttribPointer(position,3,5126,false,0,0);
	gl.enableVertexAttribArray(position);
	gl.bindBuffer(34962,null);
};
htmlHelper_webgl_WebGLSetup.uploadDataToBuffers = function(gl,program,vertices,colors,indices) {
	var vertexBuffer = gl.createBuffer();
	gl.bindBuffer(34962,vertexBuffer);
	gl.bufferData(34962,new Float32Array(vertices),35044);
	var position = gl.getAttribLocation(program,"pos");
	gl.vertexAttribPointer(position,3,5126,false,0,0);
	gl.enableVertexAttribArray(position);
	gl.bindBuffer(34962,null);
	var colorBuffer = gl.createBuffer();
	gl.bindBuffer(34962,colorBuffer);
	gl.bufferData(34962,new Float32Array(colors),35044);
	var col = gl.getAttribLocation(program,"color");
	gl.vertexAttribPointer(col,4,5126,false,0,0);
	gl.enableVertexAttribArray(col);
	gl.bindBuffer(34962,null);
};
htmlHelper_webgl_WebGLSetup.uploadFloatToBuffers = function(gl,program,name,att,arr) {
	var floatBuffer = gl.createBuffer();
	gl.bindBuffer(34962,floatBuffer);
	gl.bufferData(34962,new Float32Array(arr),35044);
	var flo = gl.getAttribLocation(program,name);
	gl.vertexAttribPointer(flo,att,5126,false,0,0);
	gl.enableVertexAttribArray(flo);
	gl.bindBuffer(34962,null);
};
htmlHelper_webgl_WebGLSetup.uploadSimpleColorToBuffers = function(gl,program,colors) {
	var colorBuffer = gl.createBuffer();
	gl.bindBuffer(34962,colorBuffer);
	gl.bufferData(34962,new Float32Array(colors),35044);
	var col = gl.getAttribLocation(program,"color");
	gl.vertexAttribPointer(col,4,5126,false,0,0);
	gl.enableVertexAttribArray(col);
	gl.bindBuffer(34962,null);
};
htmlHelper_webgl_WebGLSetup.toRGB = function(int) {
	return { r : (int >> 16 & 255) / 255, g : (int >> 8 & 255) / 255, b : (int & 255) / 255};
};
htmlHelper_webgl_WebGLSetup.transferM4_arr32 = function(arr,m) {
	arr.set([m._00,m._10,m._20,m._30,m._01,m._11,m._21,m._31,m._02,m._12,m._22,m._32,m._03,m._13,m._23,m._33]);
};
htmlHelper_webgl_WebGLSetup.ident = function() {
	return [1.0,0.0,0.0,0.0,0.0,1.1,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0];
};
htmlHelper_webgl_WebGLSetup.prototype = {
	setupProgram: function(vertexString,fragmentString) {
		var gl = this.gl;
		var vertexShader = gl.createShader(35633);
		gl.shaderSource(vertexShader,vertexString);
		gl.compileShader(vertexShader);
		var vertex = vertexShader;
		var gl1 = this.gl;
		var fragmentShader = gl1.createShader(35632);
		gl1.shaderSource(fragmentShader,fragmentString);
		gl1.compileShader(fragmentShader);
		var fragment = fragmentShader;
		var gl2 = this.gl;
		var program = gl2.createProgram();
		gl2.attachShader(program,vertex);
		gl2.attachShader(program,fragment);
		gl2.linkProgram(program);
		gl2.useProgram(program);
		this.program = program;
		return this.program;
	}
	,clearVerticesAndColors: function() {
		this.vertices = [];
		this.indices = [];
		this.colors = [];
	}
	,setVerticesAndColors: function(vertices,triangleColors) {
		var rgb_r;
		var rgb_g;
		var rgb_b;
		var colorAlpha = 1.0;
		var _g = 0;
		var _g1 = vertices.length / 3 | 0;
		while(_g < _g1) {
			var i = _g++;
			var int = triangleColors[i];
			rgb_r = (int >> 16 & 255) / 255;
			rgb_g = (int >> 8 & 255) / 255;
			rgb_b = (int & 255) / 255;
			this.colors.push(rgb_r);
			this.colors.push(rgb_g);
			this.colors.push(rgb_b);
			this.colors.push(colorAlpha);
			this.colors.push(rgb_r);
			this.colors.push(rgb_g);
			this.colors.push(rgb_b);
			this.colors.push(colorAlpha);
			this.colors.push(rgb_r);
			this.colors.push(rgb_g);
			this.colors.push(rgb_b);
			this.colors.push(colorAlpha);
			this.indices.push(i);
		}
		var gl = this.gl;
		var program = this.program;
		var colors = this.colors;
		var indices = this.indices;
		var vertexBuffer = gl.createBuffer();
		gl.bindBuffer(34962,vertexBuffer);
		gl.bufferData(34962,new Float32Array(vertices),35044);
		var position = gl.getAttribLocation(program,"pos");
		gl.vertexAttribPointer(position,3,5126,false,0,0);
		gl.enableVertexAttribArray(position);
		gl.bindBuffer(34962,null);
		var colorBuffer = gl.createBuffer();
		gl.bindBuffer(34962,colorBuffer);
		gl.bufferData(34962,new Float32Array(colors),35044);
		var col = gl.getAttribLocation(program,"color");
		gl.vertexAttribPointer(col,4,5126,false,0,0);
		gl.enableVertexAttribArray(col);
		gl.bindBuffer(34962,null);
	}
	,render: function() {
		this.gl.clearColor(this.bgRed,this.bgGreen,this.bgBlue,this.bgAlpha);
		this.gl.enable(2884);
		this.gl.cullFace(1029);
		this.gl.clear(16384);
		this.gl.viewport(0,0,this.canvas.width,this.canvas.height);
		var modelViewProjectionID = this.gl.getUniformLocation(this.program,"modelViewProjection");
		var m = this.modelViewProjection;
		this.matrix32Array.set([m._00,m._10,m._20,m._30,m._01,m._11,m._21,m._31,m._02,m._12,m._22,m._32,m._03,m._13,m._23,m._33]);
		this.gl.uniformMatrix4fv(modelViewProjectionID,false,this.matrix32Array);
		this.gl.drawArrays(4,0,this.indices.length);
	}
};
var MainWebGL = function() {
	this.pos = 0;
	this.appColors = [0,16711680,16744192,16776960,65280,255,4915330,9699539,4473924,3355443,789516,1118481,16777215];
	this.theta = 0.;
	var t = [];
	var this2;
	if(t == null) {
		var t1 = [];
		var this3 = t1 == null ? trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new([]) : t1;
		this2 = this3;
	} else {
		this2 = t;
	}
	var this1 = this2;
	this.triangles = this1;
	var t2 = [];
	var this21;
	if(t2 == null) {
		var t11 = [];
		var this31 = t11 == null ? trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new([]) : t11;
		this21 = this31;
	} else {
		this21 = t2;
	}
	var this11 = this21;
	this.trianglesIn = this11;
	this.distance = 50;
	htmlHelper_webgl_WebGLSetup.call(this,1140,1140);
	htmlHelper_webgl_WebGLSetup.call(this,1140,1140);
	this.scale = 0.00175438596491228073;
	this.darkBackground();
	this.modelViewProjection = new khaMath_Matrix4(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);
	this.setupProgram("attribute vec3 pos;" + "attribute vec4 color;" + "varying vec4 vcol;" + "uniform mat4 modelViewProjection;" + "void main(void) {" + " gl_Position = modelViewProjection * vec4(pos, 1.0);" + " vcol = color;" + "}","precision mediump float;" + "varying vec4 vcol;" + "void main(void) {" + " gl_FragColor = vcol;" + "}");
	this.shapes = new trilateral_polys_Shapes(this.triangles,this.appColors);
	this.mousePos = new khaMath_Vector4(100,100,0);
	this.fillDraw = new trilateralXtra_parsing_FillDrawTess2(1024,768);
	this.fillDrawIn = new trilateralXtra_parsing_FillDrawTess2(1024,768);
	var bytes = haxe_Resource.getBytes("font");
	var bytesInput = new haxe_io_BytesInput(bytes);
	var ttfReader = new format_ttf_Reader(bytesInput);
	var ttf = ttfReader.read();
	var fontUtils = new truetype_TTFGlyphUtils(ttf);
	var haxe1 = "Haxe";
	var haxeLetters = haxe1.split("");
	var _g = 0;
	while(_g < haxeLetters.length) {
		var letter = haxeLetters[_g];
		++_g;
		this.displayGlyph(HxOverrides.cca(letter,0) - 28,fontUtils,4);
	}
};
MainWebGL.__name__ = true;
MainWebGL.main = function() {
	new MainWebGL();
};
MainWebGL.__super__ = htmlHelper_webgl_WebGLSetup;
MainWebGL.prototype = $extend(htmlHelper_webgl_WebGLSetup.prototype,{
	setupExperiments: function() {
		var bytes = haxe_Resource.getBytes("font");
		var bytesInput = new haxe_io_BytesInput(bytes);
		var ttfReader = new format_ttf_Reader(bytesInput);
		var ttf = ttfReader.read();
		var fontUtils = new truetype_TTFGlyphUtils(ttf);
		var haxe1 = "Haxe";
		var haxeLetters = haxe1.split("");
		var _g = 0;
		while(_g < haxeLetters.length) {
			var letter = haxeLetters[_g];
			++_g;
			this.displayGlyph(HxOverrides.cca(letter,0) - 28,fontUtils,4);
		}
	}
	,displayGlyph: function(index,utils,displayScale) {
		if(displayScale == null) {
			displayScale = 4;
		}
		var glyph = utils.getGlyphSimple(index);
		if(glyph == null) {
			return;
		}
		var glyphHeader = utils.getGlyphHeader(index);
		var contours = utils.getGlyphContours(index);
		var scale = 64 / utils.headdata.unitsPerEm * displayScale;
		var path = new trilateral_path_Fine(null,null,3);
		path.width = 2;
		var x = this.pos * 172. + 688 * scale;
		this.pos++;
		var y = -384.;
		var pathModify = path;
		var dy = utils.headdata.yMax;
		var _g = 0;
		while(_g < contours.length) {
			var contour = contours[_g];
			++_g;
			var offCurvePoint = null;
			var _g1 = 0;
			var _g11 = contour.length;
			while(_g1 < _g11) {
				var i = _g1++;
				var point = contour[i];
				if(i == 0) {
					pathModify.moveTo(scale * point.x + x,scale * point.y + y);
				} else {
					var prevPoint = contour[i - 1];
					if(point.onCurve) {
						if(prevPoint.onCurve) {
							var x_ = scale * point.x + x;
							var y_ = scale * point.y + y;
							var repeat = pathModify.x == x_ && pathModify.y == y_;
							if(!repeat) {
								if(pathModify.widthFunction != null) {
									pathModify.width = pathModify.widthFunction(pathModify.width,pathModify.x,pathModify.x,x_,y_);
								}
								var _this = pathModify.contour;
								var ax_ = pathModify.x;
								var ay_ = pathModify.y;
								var width_ = pathModify.width;
								var oldAngle = _this.dx != null ? _this.angle1 : null;
								_this.halfA = Math.PI / 2;
								_this.ax = x_;
								_this.ay = y_;
								_this.bx = ax_;
								_this.by = ay_;
								_this.beta = Math.PI / 2 - _this.halfA;
								_this.r = width_ / 2 * Math.cos(_this.beta);
								_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
								if(_this.theta > 0) {
									if(_this.halfA < 0) {
										_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
										_this.angle1 = _this.theta - _this.halfA;
									} else {
										_this.angle1 = _this.theta + _this.halfA - Math.PI;
										_this.angle2 = _this.theta + _this.halfA;
									}
								} else if(_this.halfA > 0) {
									_this.angle1 = _this.theta + _this.halfA - Math.PI;
									_this.angle2 = _this.theta + _this.halfA;
								} else {
									_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
									_this.angle1 = _this.theta - _this.halfA;
								}
								if(_this.dxPrev != null) {
									_this.dxOld = _this.dxPrev;
								}
								if(_this.dyPrev != null) {
									_this.dyOld = _this.dyPrev;
								}
								if(_this.exPrev != null) {
									_this.exOld = _this.exPrev;
								}
								if(_this.eyPrev != null) {
									_this.eyOld = _this.eyPrev;
								}
								if(_this.dx != null) {
									_this.dxPrev = _this.dx;
								}
								if(_this.dy != null) {
									_this.dyPrev = _this.dy;
								}
								if(_this.ex != null) {
									_this.exPrev = _this.ex;
								}
								if(_this.ey != null) {
									_this.eyPrev = _this.ey;
								}
								_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
								_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
								_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
								_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
								_this.ax = ax_;
								_this.ay = ay_;
								_this.bx = x_;
								_this.by = y_;
								_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
								if(_this.theta > 0) {
									if(_this.halfA < 0) {
										_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
										_this.angle1 = _this.theta - _this.halfA;
									} else {
										_this.angle1 = _this.theta + _this.halfA - Math.PI;
										_this.angle2 = _this.theta + _this.halfA;
									}
								} else if(_this.halfA > 0) {
									_this.angle1 = _this.theta + _this.halfA - Math.PI;
									_this.angle2 = _this.theta + _this.halfA;
								} else {
									_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
									_this.angle1 = _this.theta - _this.halfA;
								}
								if(_this.dxPrev != null) {
									_this.dxOld = _this.dxPrev;
								}
								if(_this.dyPrev != null) {
									_this.dyOld = _this.dyPrev;
								}
								if(_this.exPrev != null) {
									_this.exOld = _this.exPrev;
								}
								if(_this.eyPrev != null) {
									_this.eyOld = _this.eyPrev;
								}
								if(_this.dx != null) {
									_this.dxPrev = _this.dx;
								}
								if(_this.dy != null) {
									_this.dyPrev = _this.dy;
								}
								if(_this.ex != null) {
									_this.exPrev = _this.ex;
								}
								if(_this.ey != null) {
									_this.eyPrev = _this.ey;
								}
								_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
								_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
								_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
								_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
								var x1 = _this.dxOld - x_;
								var y1 = _this.dyOld - y_;
								var x2 = _this.exOld - x_;
								var y2 = _this.eyOld - y_;
								var clockWise = x1 * x1 + y1 * y1 > x2 * x2 + y2 * y2;
								var theta0;
								var theta1;
								if(clockWise) {
									theta0 = -Math.atan2(_this.ay - _this.dyOld,_this.ax - _this.dxOld) - Math.PI / 2;
									theta1 = -Math.atan2(_this.ay - _this.eyPrev,_this.ax - _this.exPrev) - Math.PI / 2;
								} else {
									theta0 = -Math.atan2(_this.ay - _this.eyOld,_this.ax - _this.exOld) - Math.PI / 2;
									theta1 = -Math.atan2(_this.ay - _this.dyPrev,_this.ax - _this.dxPrev) - Math.PI / 2;
								}
								var dif;
								switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
								case 0:
									var f;
									if(theta0 >= 0 && theta0 > Math.PI) {
										f = theta0;
									} else {
										var a = theta0 % (2 * Math.PI);
										f = a >= 0 ? a : a + 2 * Math.PI;
									}
									var this1 = f;
									var za = this1;
									var f1;
									if(theta1 >= 0 && theta1 > Math.PI) {
										f1 = theta1;
									} else {
										var a1 = theta1 % (2 * Math.PI);
										f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
									}
									var this2 = f1;
									var zb = this2;
									var fa = za;
									var fb = zb;
									var theta = Math.abs(theta0 - theta1);
									var clockwise = theta0 < theta1;
									var dif1 = clockwise ? theta : -theta;
									dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
									break;
								case 1:
									var f2;
									if(theta0 >= 0 && theta0 > Math.PI) {
										f2 = theta0;
									} else {
										var a2 = theta0 % (2 * Math.PI);
										f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
									}
									var this3 = f2;
									var za1 = this3;
									var f3;
									if(theta1 >= 0 && theta1 > Math.PI) {
										f3 = theta1;
									} else {
										var a3 = theta1 % (2 * Math.PI);
										f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
									}
									var this4 = f3;
									var zb1 = this4;
									var fa1 = za1;
									var fb1 = zb1;
									var theta2 = Math.abs(theta0 - theta1);
									var clockwise1 = theta0 < theta1;
									var dif2 = clockwise1 ? theta2 : -theta2;
									dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
									break;
								case 2:
									var f4;
									if(theta0 >= 0 && theta0 > Math.PI) {
										f4 = theta0;
									} else {
										var a4 = theta0 % (2 * Math.PI);
										f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
									}
									var this5 = f4;
									var za2 = this5;
									var f5;
									if(theta1 >= 0 && theta1 > Math.PI) {
										f5 = theta1;
									} else {
										var a5 = theta1 % (2 * Math.PI);
										f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
									}
									var this6 = f5;
									var zb2 = this6;
									var fa2 = theta0;
									var fb2 = theta1;
									var theta3 = Math.abs(theta0 - theta1);
									var smallest = theta3 <= Math.PI;
									var clockwise2 = theta0 < theta1;
									var dif3 = clockwise2 ? theta3 : -theta3;
									dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
									break;
								case 3:
									var f6;
									if(theta0 >= 0 && theta0 > Math.PI) {
										f6 = theta0;
									} else {
										var a6 = theta0 % (2 * Math.PI);
										f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
									}
									var this7 = f6;
									var za3 = this7;
									var f7;
									if(theta1 >= 0 && theta1 > Math.PI) {
										f7 = theta1;
									} else {
										var a7 = theta1 % (2 * Math.PI);
										f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
									}
									var this8 = f7;
									var zb3 = this8;
									var fa3 = theta0;
									var fb3 = theta1;
									var theta4 = Math.abs(theta0 - theta1);
									var largest = theta4 > Math.PI;
									var clockwise3 = theta0 < theta1;
									var dif4 = clockwise3 ? theta4 : -theta4;
									dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta4) : 2 * Math.PI - theta4;
									break;
								}
								if(_this.count != 0) {
									var gamma = Math.abs(dif) / 2;
									var h = width_ / 2 / Math.cos(gamma);
									var f8;
									if(theta0 <= Math.PI && theta0 > -Math.PI) {
										f8 = theta0;
									} else {
										var a8 = (theta0 + Math.PI) % (2 * Math.PI);
										f8 = a8 >= 0 ? a8 - Math.PI : a8 + Math.PI;
									}
									var this9 = f8;
									var start = this9;
									var start2 = start;
									var delta = start2 + dif / 2 + Math.PI;
									_this.jx = _this.ax + h * Math.sin(delta);
									_this.jy = _this.ay + h * Math.cos(delta);
								}
								if(_this.count == 0 && (_this.endLine == 1 || _this.endLine == 3)) {
									var ax = _this.ax;
									var ay = _this.ay;
									var radius = width_ / 2;
									var beta = -_this.angle1 - Math.PI / 2;
									var gamma1 = -_this.angle1 - Math.PI / 2 + Math.PI;
									var temp = [];
									var this10 = _this.triArr;
									var t = [];
									var this11;
									if(t == null) {
										var t1 = [];
										var this12 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
										this11 = this12;
									} else {
										this11 = t;
									}
									var this13 = this11;
									var out = this13;
									var pi = Math.PI;
									var step = pi * 2 / 36;
									var dif5;
									switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
									case 0:
										var f9;
										if(beta >= 0 && beta > Math.PI) {
											f9 = beta;
										} else {
											var a9 = beta % (2 * Math.PI);
											f9 = a9 >= 0 ? a9 : a9 + 2 * Math.PI;
										}
										var this14 = f9;
										var za4 = this14;
										var f10;
										if(gamma1 >= 0 && gamma1 > Math.PI) {
											f10 = gamma1;
										} else {
											var a10 = gamma1 % (2 * Math.PI);
											f10 = a10 >= 0 ? a10 : a10 + 2 * Math.PI;
										}
										var this15 = f10;
										var zb4 = this15;
										var fa4 = za4;
										var fb4 = zb4;
										var theta5 = Math.abs(beta - gamma1);
										var clockwise4 = beta < gamma1;
										var dif6 = clockwise4 ? theta5 : -theta5;
										dif5 = dif6 > 0 ? dif6 : 2 * Math.PI + dif6;
										break;
									case 1:
										var f11;
										if(beta >= 0 && beta > Math.PI) {
											f11 = beta;
										} else {
											var a11 = beta % (2 * Math.PI);
											f11 = a11 >= 0 ? a11 : a11 + 2 * Math.PI;
										}
										var this16 = f11;
										var za5 = this16;
										var f12;
										if(gamma1 >= 0 && gamma1 > Math.PI) {
											f12 = gamma1;
										} else {
											var a12 = gamma1 % (2 * Math.PI);
											f12 = a12 >= 0 ? a12 : a12 + 2 * Math.PI;
										}
										var this17 = f12;
										var zb5 = this17;
										var fa5 = za5;
										var fb5 = zb5;
										var theta6 = Math.abs(beta - gamma1);
										var clockwise5 = beta < gamma1;
										var dif7 = clockwise5 ? theta6 : -theta6;
										dif5 = dif7 < 0 ? dif7 : -2 * Math.PI + dif7;
										break;
									case 2:
										var f13;
										if(beta >= 0 && beta > Math.PI) {
											f13 = beta;
										} else {
											var a13 = beta % (2 * Math.PI);
											f13 = a13 >= 0 ? a13 : a13 + 2 * Math.PI;
										}
										var this18 = f13;
										var za6 = this18;
										var f14;
										if(gamma1 >= 0 && gamma1 > Math.PI) {
											f14 = gamma1;
										} else {
											var a14 = gamma1 % (2 * Math.PI);
											f14 = a14 >= 0 ? a14 : a14 + 2 * Math.PI;
										}
										var this19 = f14;
										var zb6 = this19;
										var fa6 = beta;
										var fb6 = gamma1;
										var theta7 = Math.abs(beta - gamma1);
										var smallest1 = theta7 <= Math.PI;
										var clockwise6 = beta < gamma1;
										var dif8 = clockwise6 ? theta7 : -theta7;
										dif5 = smallest1 ? dif8 : clockwise6 ? -(2 * Math.PI - theta7) : 2 * Math.PI - theta7;
										break;
									case 3:
										var f15;
										if(beta >= 0 && beta > Math.PI) {
											f15 = beta;
										} else {
											var a15 = beta % (2 * Math.PI);
											f15 = a15 >= 0 ? a15 : a15 + 2 * Math.PI;
										}
										var this20 = f15;
										var za7 = this20;
										var f16;
										if(gamma1 >= 0 && gamma1 > Math.PI) {
											f16 = gamma1;
										} else {
											var a16 = gamma1 % (2 * Math.PI);
											f16 = a16 >= 0 ? a16 : a16 + 2 * Math.PI;
										}
										var this21 = f16;
										var zb7 = this21;
										var fa7 = beta;
										var fb7 = gamma1;
										var theta8 = Math.abs(beta - gamma1);
										var largest1 = theta8 > Math.PI;
										var clockwise7 = beta < gamma1;
										var dif9 = clockwise7 ? theta8 : -theta8;
										dif5 = largest1 ? dif9 : clockwise7 ? -(2 * Math.PI - theta8) : 2 * Math.PI - theta8;
										break;
									}
									var positive = dif5 >= 0;
									var totalSteps = Math.ceil(Math.abs(dif5) / step);
									var step1 = dif5 / totalSteps;
									var angle = beta;
									var cx;
									var cy;
									var bx = 0;
									var by = 0;
									var p2 = temp.length;
									var _g2 = 0;
									var _g12 = totalSteps + 1;
									while(_g2 < _g12) {
										var i1 = _g2++;
										cx = ax + radius * Math.sin(angle);
										cy = ay + radius * Math.cos(angle);
										temp[p2++] = cx;
										temp[p2++] = cy;
										if(i1 != 0) {
											var t2 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
											out[out.length] = t2;
										}
										angle += step1;
										bx = cx;
										by = cy;
									}
									var triArr = out;
									var _g3 = 0;
									while(_g3 < triArr.length) {
										var t3 = triArr[_g3];
										++_g3;
										this10[this10.length] = t3;
									}
									var pA = _this.pointsAnti.length;
									var len = temp.length / 2 | 0;
									var p4 = temp.length / 4 | 0;
									var _g4 = 0;
									var _g13 = p4;
									while(_g4 < _g13) {
										var i2 = _g4++;
										_this.pointsAnti[pA++] = temp[len - 2 * i2 + 1];
										_this.pointsAnti[pA++] = temp[len - 2 * i2];
									}
									var pC = _this.pointsClock.length;
									var _g21 = 0;
									var _g31 = p4;
									while(_g21 < _g31) {
										var i3 = _g21++;
										_this.pointsClock[pC++] = temp[i3 * 2 + len + 1];
										_this.pointsClock[pC++] = temp[i3 * 2 + len];
									}
								}
								if(_this.count != 0) {
									_this.addQuads(clockWise,width_);
								}
								_this.quadIndex = _this.triArr.length;
								if(_this.count == 0) {
									_this.penultimateAX = _this.dxPrev;
									_this.penultimateAY = _this.dyPrev;
									_this.lastAntiX = _this.ex;
									_this.lastAntiY = _this.ey;
									_this.penultimateCX = _this.dx;
									_this.penultimateCY = _this.dy;
									_this.lastClockX = _this.exPrev;
									_this.lastClockY = _this.eyPrev;
									var this22 = _this.triArr;
									var tri = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.dx,_this.dy,_this.ex,_this.ey,0);
									this22[this22.length] = tri;
									var this23 = _this.triArr;
									var tri1 = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.dx,_this.dy,_this.exPrev,_this.eyPrev,0);
									this23[this23.length] = tri1;
								} else {
									if(clockWise && !_this.lastClock) {
										_this.penultimateAX = _this.jx;
										_this.penultimateAY = _this.jy;
										_this.lastAntiX = _this.ex;
										_this.lastAntiY = _this.ey;
										_this.penultimateCX = _this.dx;
										_this.penultimateCY = _this.dy;
										_this.lastClockX = _this.exPrev;
										_this.lastClockY = _this.eyPrev;
										var this24 = _this.triArr;
										var tri2 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.ex,_this.ey,0);
										this24[this24.length] = tri2;
										var this25 = _this.triArr;
										var tri3 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.exPrev,_this.eyPrev,0);
										this25[this25.length] = tri3;
									}
									if(clockWise && _this.lastClock) {
										_this.penultimateAX = _this.jx;
										_this.penultimateAY = _this.jy;
										_this.lastAntiX = _this.ex;
										_this.lastAntiY = _this.ey;
										_this.penultimateCX = _this.dx;
										_this.penultimateCY = _this.dy;
										_this.lastClockX = _this.exPrev;
										_this.lastClockY = _this.eyPrev;
										var this26 = _this.triArr;
										var tri4 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.ex,_this.ey,0);
										this26[this26.length] = tri4;
										var this27 = _this.triArr;
										var tri5 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.exPrev,_this.eyPrev,0);
										this27[this27.length] = tri5;
									}
									if(!clockWise && !_this.lastClock) {
										_this.penultimateCX = _this.dx;
										_this.penultimateCY = _this.dy;
										_this.lastClockX = _this.jx;
										_this.lastClockY = _this.jy;
										_this.penultimateAX = _this.dxPrev;
										_this.penultimateAY = _this.dyPrev;
										_this.lastAntiX = _this.ex;
										_this.lastAntiY = _this.ey;
										var this28 = _this.triArr;
										var tri6 = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.dx,_this.dy,_this.jx,_this.jy,0);
										this28[this28.length] = tri6;
										var this29 = _this.triArr;
										var tri7 = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.dx,_this.dy,_this.ex,_this.ey,0);
										this29[this29.length] = tri7;
									}
									if(!clockWise && _this.lastClock) {
										_this.penultimateAX = _this.dxPrev;
										_this.penultimateAY = _this.dyPrev;
										_this.lastAntiX = _this.ex;
										_this.lastAntiY = _this.ey;
										_this.penultimateCX = _this.jx;
										_this.penultimateCY = _this.jy;
										_this.lastClockX = _this.dx;
										_this.lastClockY = _this.dy;
										var this30 = _this.triArr;
										var tri8 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.ex,_this.ey,0);
										this30[this30.length] = tri8;
										var this31 = _this.triArr;
										var tri9 = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.jx,_this.jy,_this.ex,_this.ey,0);
										this31[this31.length] = tri9;
									}
								}
								if(clockWise) {
									var radius1 = width_ / 2;
									var edgePoly = _this.pointsClock;
									var t4 = [];
									var this32;
									if(t4 == null) {
										var t5 = [];
										var this33 = t5 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t5;
										this32 = this33;
									} else {
										this32 = t4;
									}
									var this34 = this32;
									var out1 = this34;
									var pi1 = Math.PI;
									var step2 = pi1 * 2 / 36;
									var positive1 = dif >= 0;
									var totalSteps1 = Math.ceil(Math.abs(dif) / step2);
									var step3 = dif / totalSteps1;
									var angle1 = theta0;
									var cx1;
									var cy1;
									var bx1 = 0;
									var by1 = 0;
									var p21 = edgePoly.length;
									var count = 0;
									var _g5 = 0;
									var _g14 = totalSteps1 + 1;
									while(_g5 < _g14) {
										var i4 = _g5++;
										cx1 = ax_ + radius1 * Math.sin(angle1);
										cy1 = ay_ + radius1 * Math.cos(angle1);
										if(i4 != 0) {
											var t6 = new trilateral_tri_Trilateral(ax_,ay_,bx1,by1,cx1,cy1);
											out1[out1.length] = t6;
											edgePoly[p21++] = cx1;
											edgePoly[p21++] = cy1;
										}
										angle1 += step3;
										bx1 = cx1;
										by1 = cy1;
									}
									var trilateralArray = out1;
									var this35 = _this.triArr;
									var _g6 = 0;
									while(_g6 < trilateralArray.length) {
										var t7 = trilateralArray[_g6];
										++_g6;
										this35[this35.length] = t7;
									}
								} else {
									var radius2 = width_ / 2;
									var edgePoly1 = _this.pointsAnti;
									var t8 = [];
									var this36;
									if(t8 == null) {
										var t9 = [];
										var this37 = t9 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t9;
										this36 = this37;
									} else {
										this36 = t8;
									}
									var this38 = this36;
									var out2 = this38;
									var pi2 = Math.PI;
									var step4 = pi2 * 2 / 36;
									var positive2 = dif >= 0;
									var totalSteps2 = Math.ceil(Math.abs(dif) / step4);
									var step5 = dif / totalSteps2;
									var angle2 = theta0;
									var cx2;
									var cy2;
									var bx2 = 0;
									var by2 = 0;
									var p22 = edgePoly1.length;
									var count1 = 0;
									var _g7 = 0;
									var _g15 = totalSteps2 + 1;
									while(_g7 < _g15) {
										var i5 = _g7++;
										cx2 = ax_ + radius2 * Math.sin(angle2);
										cy2 = ay_ + radius2 * Math.cos(angle2);
										if(i5 != 0) {
											var t10 = new trilateral_tri_Trilateral(ax_,ay_,bx2,by2,cx2,cy2);
											out2[out2.length] = t10;
											edgePoly1[p22++] = cx2;
											edgePoly1[p22++] = cy2;
										}
										angle2 += step5;
										bx2 = cx2;
										by2 = cy2;
									}
									var trilateralArray1 = out2;
									var this39 = _this.triArr;
									var _g8 = 0;
									while(_g8 < trilateralArray1.length) {
										var t11 = trilateralArray1[_g8];
										++_g8;
										this39[this39.length] = t11;
									}
								}
								_this.kax = _this.dxPrev;
								_this.kay = _this.dyPrev;
								_this.kbx = _this.dx;
								_this.kby = _this.dy;
								_this.ncx = _this.exPrev;
								_this.ncy = _this.eyPrev;
								_this.kcx = _this.ex;
								_this.kcy = _this.ey;
								if(_this.count != 0) {
									if(clockWise) {
										var this40 = _this.triArr;
										var tri10 = new trilateral_tri_Trilateral(_this.ax,_this.ay,_this.dxOld,_this.dyOld,_this.jx,_this.jy,0);
										this40[this40.length] = tri10;
										var this41 = _this.triArr;
										var tri11 = new trilateral_tri_Trilateral(_this.ax,_this.ay,_this.exPrev,_this.eyPrev,_this.jx,_this.jy,0);
										this41[this41.length] = tri11;
									} else {
										var this42 = _this.triArr;
										var tri12 = new trilateral_tri_Trilateral(_this.ax,_this.ay,_this.exOld,_this.eyOld,_this.jx,_this.jy,0);
										this42[this42.length] = tri12;
										var this43 = _this.triArr;
										var tri13 = new trilateral_tri_Trilateral(_this.ax,_this.ay,_this.dxPrev,_this.dyPrev,_this.jx,_this.jy,0);
										this43[this43.length] = tri13;
									}
								}
								_this.jxOld = _this.jx;
								_this.jyOld = _this.jy;
								_this.lastClock = clockWise;
								_this.count++;
								var l = pathModify.points.length;
								var p = pathModify.points[l - 1];
								var l2 = p.length;
								p[l2] = x_;
								p[l2 + 1] = y_;
								var d = pathModify.dim[pathModify.dim.length - 1];
								if(x_ < d.minX) {
									d.minX = x_;
								}
								if(x_ > d.maxX) {
									d.maxX = x_;
								}
								if(y_ < d.minY) {
									d.minY = y_;
								}
								if(y_ > d.maxY) {
									d.maxY = y_;
								}
								pathModify.x = x_;
								pathModify.y = y_;
							}
						} else {
							var x11 = scale * offCurvePoint.x + x;
							var y11 = scale * offCurvePoint.y + y;
							var x21 = scale * point.x + x;
							var y21 = scale * point.y + y;
							pathModify.tempArr = [];
							var p1 = pathModify.tempArr;
							var ax1 = pathModify.x;
							var ay1 = pathModify.y;
							var x3 = ax1 - x11;
							var y3 = ay1 - y11;
							var x4 = x11 - x21;
							var y4 = y11 - y21;
							var approxDistance = Math.sqrt(x3 * x3 + y3 * y3) + Math.sqrt(x4 * x4 + y4 * y4);
							if(approxDistance == 0) {
								approxDistance = 0.000001;
							}
							var step6 = Math.min(1 / (approxDistance * 0.707),trilateral_geom_Algebra.quadStep);
							var l1 = p1.length;
							p1[l1++] = ax1;
							p1[l1++] = ay1;
							var t12 = step6;
							while(t12 < 1.) {
								var u = 1 - t12;
								p1[l1++] = Math.pow(u,2) * ax1 + 2 * u * t12 * x11 + Math.pow(t12,2) * x21;
								var u1 = 1 - t12;
								p1[l1++] = Math.pow(u1,2) * ay1 + 2 * u1 * t12 * y11 + Math.pow(t12,2) * y21;
								t12 += step6;
							}
							p1[l1++] = x21;
							p1[l1++] = y21;
							var arr = pathModify.tempArr;
							var l3 = arr.length;
							var i6 = 2;
							var x_1 = arr[0];
							var y_1 = arr[1];
							var repeat1 = pathModify.x == x_1 && pathModify.y == y_1;
							if(!repeat1) {
								if(pathModify.widthFunction != null) {
									pathModify.width = pathModify.widthFunction(pathModify.width,pathModify.x,pathModify.x,x_1,y_1);
								}
								var _this1 = pathModify.contour;
								var ax_1 = pathModify.x;
								var ay_1 = pathModify.y;
								var width_1 = pathModify.width;
								var oldAngle1 = _this1.dx != null ? _this1.angle1 : null;
								_this1.halfA = Math.PI / 2;
								_this1.ax = x_1;
								_this1.ay = y_1;
								_this1.bx = ax_1;
								_this1.by = ay_1;
								_this1.beta = Math.PI / 2 - _this1.halfA;
								_this1.r = width_1 / 2 * Math.cos(_this1.beta);
								_this1.theta = Math.atan2(_this1.ay - _this1.by,_this1.ax - _this1.bx);
								if(_this1.theta > 0) {
									if(_this1.halfA < 0) {
										_this1.angle2 = _this1.theta + _this1.halfA + Math.PI / 2;
										_this1.angle1 = _this1.theta - _this1.halfA;
									} else {
										_this1.angle1 = _this1.theta + _this1.halfA - Math.PI;
										_this1.angle2 = _this1.theta + _this1.halfA;
									}
								} else if(_this1.halfA > 0) {
									_this1.angle1 = _this1.theta + _this1.halfA - Math.PI;
									_this1.angle2 = _this1.theta + _this1.halfA;
								} else {
									_this1.angle2 = _this1.theta + _this1.halfA + Math.PI / 2;
									_this1.angle1 = _this1.theta - _this1.halfA;
								}
								if(_this1.dxPrev != null) {
									_this1.dxOld = _this1.dxPrev;
								}
								if(_this1.dyPrev != null) {
									_this1.dyOld = _this1.dyPrev;
								}
								if(_this1.exPrev != null) {
									_this1.exOld = _this1.exPrev;
								}
								if(_this1.eyPrev != null) {
									_this1.eyOld = _this1.eyPrev;
								}
								if(_this1.dx != null) {
									_this1.dxPrev = _this1.dx;
								}
								if(_this1.dy != null) {
									_this1.dyPrev = _this1.dy;
								}
								if(_this1.ex != null) {
									_this1.exPrev = _this1.ex;
								}
								if(_this1.ey != null) {
									_this1.eyPrev = _this1.ey;
								}
								_this1.dx = _this1.bx + _this1.r * Math.cos(_this1.angle1);
								_this1.dy = _this1.by + _this1.r * Math.sin(_this1.angle1);
								_this1.ex = _this1.bx + _this1.r * Math.cos(_this1.angle2);
								_this1.ey = _this1.by + _this1.r * Math.sin(_this1.angle2);
								_this1.ax = ax_1;
								_this1.ay = ay_1;
								_this1.bx = x_1;
								_this1.by = y_1;
								_this1.theta = Math.atan2(_this1.ay - _this1.by,_this1.ax - _this1.bx);
								if(_this1.theta > 0) {
									if(_this1.halfA < 0) {
										_this1.angle2 = _this1.theta + _this1.halfA + Math.PI / 2;
										_this1.angle1 = _this1.theta - _this1.halfA;
									} else {
										_this1.angle1 = _this1.theta + _this1.halfA - Math.PI;
										_this1.angle2 = _this1.theta + _this1.halfA;
									}
								} else if(_this1.halfA > 0) {
									_this1.angle1 = _this1.theta + _this1.halfA - Math.PI;
									_this1.angle2 = _this1.theta + _this1.halfA;
								} else {
									_this1.angle2 = _this1.theta + _this1.halfA + Math.PI / 2;
									_this1.angle1 = _this1.theta - _this1.halfA;
								}
								if(_this1.dxPrev != null) {
									_this1.dxOld = _this1.dxPrev;
								}
								if(_this1.dyPrev != null) {
									_this1.dyOld = _this1.dyPrev;
								}
								if(_this1.exPrev != null) {
									_this1.exOld = _this1.exPrev;
								}
								if(_this1.eyPrev != null) {
									_this1.eyOld = _this1.eyPrev;
								}
								if(_this1.dx != null) {
									_this1.dxPrev = _this1.dx;
								}
								if(_this1.dy != null) {
									_this1.dyPrev = _this1.dy;
								}
								if(_this1.ex != null) {
									_this1.exPrev = _this1.ex;
								}
								if(_this1.ey != null) {
									_this1.eyPrev = _this1.ey;
								}
								_this1.dx = _this1.bx + _this1.r * Math.cos(_this1.angle1);
								_this1.dy = _this1.by + _this1.r * Math.sin(_this1.angle1);
								_this1.ex = _this1.bx + _this1.r * Math.cos(_this1.angle2);
								_this1.ey = _this1.by + _this1.r * Math.sin(_this1.angle2);
								var x5 = _this1.dxOld - x_1;
								var y5 = _this1.dyOld - y_1;
								var x6 = _this1.exOld - x_1;
								var y6 = _this1.eyOld - y_1;
								var clockWise1 = x5 * x5 + y5 * y5 > x6 * x6 + y6 * y6;
								var theta01;
								var theta11;
								if(clockWise1) {
									theta01 = -Math.atan2(_this1.ay - _this1.dyOld,_this1.ax - _this1.dxOld) - Math.PI / 2;
									theta11 = -Math.atan2(_this1.ay - _this1.eyPrev,_this1.ax - _this1.exPrev) - Math.PI / 2;
								} else {
									theta01 = -Math.atan2(_this1.ay - _this1.eyOld,_this1.ax - _this1.exOld) - Math.PI / 2;
									theta11 = -Math.atan2(_this1.ay - _this1.dyPrev,_this1.ax - _this1.dxPrev) - Math.PI / 2;
								}
								var dif10;
								switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
								case 0:
									var f17;
									if(theta01 >= 0 && theta01 > Math.PI) {
										f17 = theta01;
									} else {
										var a17 = theta01 % (2 * Math.PI);
										f17 = a17 >= 0 ? a17 : a17 + 2 * Math.PI;
									}
									var this44 = f17;
									var za8 = this44;
									var f18;
									if(theta11 >= 0 && theta11 > Math.PI) {
										f18 = theta11;
									} else {
										var a18 = theta11 % (2 * Math.PI);
										f18 = a18 >= 0 ? a18 : a18 + 2 * Math.PI;
									}
									var this45 = f18;
									var zb8 = this45;
									var fa8 = za8;
									var fb8 = zb8;
									var theta9 = Math.abs(theta01 - theta11);
									var clockwise8 = theta01 < theta11;
									var dif11 = clockwise8 ? theta9 : -theta9;
									dif10 = dif11 > 0 ? dif11 : 2 * Math.PI + dif11;
									break;
								case 1:
									var f19;
									if(theta01 >= 0 && theta01 > Math.PI) {
										f19 = theta01;
									} else {
										var a19 = theta01 % (2 * Math.PI);
										f19 = a19 >= 0 ? a19 : a19 + 2 * Math.PI;
									}
									var this46 = f19;
									var za9 = this46;
									var f20;
									if(theta11 >= 0 && theta11 > Math.PI) {
										f20 = theta11;
									} else {
										var a20 = theta11 % (2 * Math.PI);
										f20 = a20 >= 0 ? a20 : a20 + 2 * Math.PI;
									}
									var this47 = f20;
									var zb9 = this47;
									var fa9 = za9;
									var fb9 = zb9;
									var theta10 = Math.abs(theta01 - theta11);
									var clockwise9 = theta01 < theta11;
									var dif12 = clockwise9 ? theta10 : -theta10;
									dif10 = dif12 < 0 ? dif12 : -2 * Math.PI + dif12;
									break;
								case 2:
									var f21;
									if(theta01 >= 0 && theta01 > Math.PI) {
										f21 = theta01;
									} else {
										var a21 = theta01 % (2 * Math.PI);
										f21 = a21 >= 0 ? a21 : a21 + 2 * Math.PI;
									}
									var this48 = f21;
									var za10 = this48;
									var f22;
									if(theta11 >= 0 && theta11 > Math.PI) {
										f22 = theta11;
									} else {
										var a22 = theta11 % (2 * Math.PI);
										f22 = a22 >= 0 ? a22 : a22 + 2 * Math.PI;
									}
									var this49 = f22;
									var zb10 = this49;
									var fa10 = theta01;
									var fb10 = theta11;
									var theta12 = Math.abs(theta01 - theta11);
									var smallest2 = theta12 <= Math.PI;
									var clockwise10 = theta01 < theta11;
									var dif13 = clockwise10 ? theta12 : -theta12;
									dif10 = smallest2 ? dif13 : clockwise10 ? -(2 * Math.PI - theta12) : 2 * Math.PI - theta12;
									break;
								case 3:
									var f23;
									if(theta01 >= 0 && theta01 > Math.PI) {
										f23 = theta01;
									} else {
										var a23 = theta01 % (2 * Math.PI);
										f23 = a23 >= 0 ? a23 : a23 + 2 * Math.PI;
									}
									var this50 = f23;
									var za11 = this50;
									var f24;
									if(theta11 >= 0 && theta11 > Math.PI) {
										f24 = theta11;
									} else {
										var a24 = theta11 % (2 * Math.PI);
										f24 = a24 >= 0 ? a24 : a24 + 2 * Math.PI;
									}
									var this51 = f24;
									var zb11 = this51;
									var fa11 = theta01;
									var fb11 = theta11;
									var theta13 = Math.abs(theta01 - theta11);
									var largest2 = theta13 > Math.PI;
									var clockwise11 = theta01 < theta11;
									var dif14 = clockwise11 ? theta13 : -theta13;
									dif10 = largest2 ? dif14 : clockwise11 ? -(2 * Math.PI - theta13) : 2 * Math.PI - theta13;
									break;
								}
								if(_this1.count != 0) {
									var gamma2 = Math.abs(dif10) / 2;
									var h1 = width_1 / 2 / Math.cos(gamma2);
									var f25;
									if(theta01 <= Math.PI && theta01 > -Math.PI) {
										f25 = theta01;
									} else {
										var a25 = (theta01 + Math.PI) % (2 * Math.PI);
										f25 = a25 >= 0 ? a25 - Math.PI : a25 + Math.PI;
									}
									var this52 = f25;
									var start1 = this52;
									var start21 = start1;
									var delta1 = start21 + dif10 / 2 + Math.PI;
									_this1.jx = _this1.ax + h1 * Math.sin(delta1);
									_this1.jy = _this1.ay + h1 * Math.cos(delta1);
								}
								if(_this1.count == 0 && (_this1.endLine == 1 || _this1.endLine == 3)) {
									var ax2 = _this1.ax;
									var ay2 = _this1.ay;
									var radius3 = width_1 / 2;
									var beta1 = -_this1.angle1 - Math.PI / 2;
									var gamma3 = -_this1.angle1 - Math.PI / 2 + Math.PI;
									var temp1 = [];
									var this53 = _this1.triArr;
									var t13 = [];
									var this54;
									if(t13 == null) {
										var t14 = [];
										var this55 = t14 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t14;
										this54 = this55;
									} else {
										this54 = t13;
									}
									var this56 = this54;
									var out3 = this56;
									var pi3 = Math.PI;
									var step7 = pi3 * 2 / 36;
									var dif15;
									switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
									case 0:
										var f26;
										if(beta1 >= 0 && beta1 > Math.PI) {
											f26 = beta1;
										} else {
											var a26 = beta1 % (2 * Math.PI);
											f26 = a26 >= 0 ? a26 : a26 + 2 * Math.PI;
										}
										var this57 = f26;
										var za12 = this57;
										var f27;
										if(gamma3 >= 0 && gamma3 > Math.PI) {
											f27 = gamma3;
										} else {
											var a27 = gamma3 % (2 * Math.PI);
											f27 = a27 >= 0 ? a27 : a27 + 2 * Math.PI;
										}
										var this58 = f27;
										var zb12 = this58;
										var fa12 = za12;
										var fb12 = zb12;
										var theta14 = Math.abs(beta1 - gamma3);
										var clockwise12 = beta1 < gamma3;
										var dif16 = clockwise12 ? theta14 : -theta14;
										dif15 = dif16 > 0 ? dif16 : 2 * Math.PI + dif16;
										break;
									case 1:
										var f28;
										if(beta1 >= 0 && beta1 > Math.PI) {
											f28 = beta1;
										} else {
											var a28 = beta1 % (2 * Math.PI);
											f28 = a28 >= 0 ? a28 : a28 + 2 * Math.PI;
										}
										var this59 = f28;
										var za13 = this59;
										var f29;
										if(gamma3 >= 0 && gamma3 > Math.PI) {
											f29 = gamma3;
										} else {
											var a29 = gamma3 % (2 * Math.PI);
											f29 = a29 >= 0 ? a29 : a29 + 2 * Math.PI;
										}
										var this60 = f29;
										var zb13 = this60;
										var fa13 = za13;
										var fb13 = zb13;
										var theta15 = Math.abs(beta1 - gamma3);
										var clockwise13 = beta1 < gamma3;
										var dif17 = clockwise13 ? theta15 : -theta15;
										dif15 = dif17 < 0 ? dif17 : -2 * Math.PI + dif17;
										break;
									case 2:
										var f30;
										if(beta1 >= 0 && beta1 > Math.PI) {
											f30 = beta1;
										} else {
											var a30 = beta1 % (2 * Math.PI);
											f30 = a30 >= 0 ? a30 : a30 + 2 * Math.PI;
										}
										var this61 = f30;
										var za14 = this61;
										var f31;
										if(gamma3 >= 0 && gamma3 > Math.PI) {
											f31 = gamma3;
										} else {
											var a31 = gamma3 % (2 * Math.PI);
											f31 = a31 >= 0 ? a31 : a31 + 2 * Math.PI;
										}
										var this62 = f31;
										var zb14 = this62;
										var fa14 = beta1;
										var fb14 = gamma3;
										var theta16 = Math.abs(beta1 - gamma3);
										var smallest3 = theta16 <= Math.PI;
										var clockwise14 = beta1 < gamma3;
										var dif18 = clockwise14 ? theta16 : -theta16;
										dif15 = smallest3 ? dif18 : clockwise14 ? -(2 * Math.PI - theta16) : 2 * Math.PI - theta16;
										break;
									case 3:
										var f32;
										if(beta1 >= 0 && beta1 > Math.PI) {
											f32 = beta1;
										} else {
											var a32 = beta1 % (2 * Math.PI);
											f32 = a32 >= 0 ? a32 : a32 + 2 * Math.PI;
										}
										var this63 = f32;
										var za15 = this63;
										var f33;
										if(gamma3 >= 0 && gamma3 > Math.PI) {
											f33 = gamma3;
										} else {
											var a33 = gamma3 % (2 * Math.PI);
											f33 = a33 >= 0 ? a33 : a33 + 2 * Math.PI;
										}
										var this64 = f33;
										var zb15 = this64;
										var fa15 = beta1;
										var fb15 = gamma3;
										var theta17 = Math.abs(beta1 - gamma3);
										var largest3 = theta17 > Math.PI;
										var clockwise15 = beta1 < gamma3;
										var dif19 = clockwise15 ? theta17 : -theta17;
										dif15 = largest3 ? dif19 : clockwise15 ? -(2 * Math.PI - theta17) : 2 * Math.PI - theta17;
										break;
									}
									var positive3 = dif15 >= 0;
									var totalSteps3 = Math.ceil(Math.abs(dif15) / step7);
									var step8 = dif15 / totalSteps3;
									var angle3 = beta1;
									var cx3;
									var cy3;
									var bx3 = 0;
									var by3 = 0;
									var p23 = temp1.length;
									var _g9 = 0;
									var _g16 = totalSteps3 + 1;
									while(_g9 < _g16) {
										var i7 = _g9++;
										cx3 = ax2 + radius3 * Math.sin(angle3);
										cy3 = ay2 + radius3 * Math.cos(angle3);
										temp1[p23++] = cx3;
										temp1[p23++] = cy3;
										if(i7 != 0) {
											var t15 = new trilateral_tri_Trilateral(ax2,ay2,bx3,by3,cx3,cy3);
											out3[out3.length] = t15;
										}
										angle3 += step8;
										bx3 = cx3;
										by3 = cy3;
									}
									var triArr1 = out3;
									var _g10 = 0;
									while(_g10 < triArr1.length) {
										var t16 = triArr1[_g10];
										++_g10;
										this53[this53.length] = t16;
									}
									var pA1 = _this1.pointsAnti.length;
									var len1 = temp1.length / 2 | 0;
									var p41 = temp1.length / 4 | 0;
									var _g17 = 0;
									var _g18 = p41;
									while(_g17 < _g18) {
										var i8 = _g17++;
										_this1.pointsAnti[pA1++] = temp1[len1 - 2 * i8 + 1];
										_this1.pointsAnti[pA1++] = temp1[len1 - 2 * i8];
									}
									var pC1 = _this1.pointsClock.length;
									var _g22 = 0;
									var _g32 = p41;
									while(_g22 < _g32) {
										var i9 = _g22++;
										_this1.pointsClock[pC1++] = temp1[i9 * 2 + len1 + 1];
										_this1.pointsClock[pC1++] = temp1[i9 * 2 + len1];
									}
								}
								if(_this1.count != 0) {
									_this1.addQuads(clockWise1,width_1);
								}
								_this1.quadIndex = _this1.triArr.length;
								if(_this1.count == 0) {
									_this1.penultimateAX = _this1.dxPrev;
									_this1.penultimateAY = _this1.dyPrev;
									_this1.lastAntiX = _this1.ex;
									_this1.lastAntiY = _this1.ey;
									_this1.penultimateCX = _this1.dx;
									_this1.penultimateCY = _this1.dy;
									_this1.lastClockX = _this1.exPrev;
									_this1.lastClockY = _this1.eyPrev;
									var this65 = _this1.triArr;
									var tri14 = new trilateral_tri_Trilateral(_this1.dxPrev,_this1.dyPrev,_this1.dx,_this1.dy,_this1.ex,_this1.ey,0);
									this65[this65.length] = tri14;
									var this66 = _this1.triArr;
									var tri15 = new trilateral_tri_Trilateral(_this1.dxPrev,_this1.dyPrev,_this1.dx,_this1.dy,_this1.exPrev,_this1.eyPrev,0);
									this66[this66.length] = tri15;
								} else {
									if(clockWise1 && !_this1.lastClock) {
										_this1.penultimateAX = _this1.jx;
										_this1.penultimateAY = _this1.jy;
										_this1.lastAntiX = _this1.ex;
										_this1.lastAntiY = _this1.ey;
										_this1.penultimateCX = _this1.dx;
										_this1.penultimateCY = _this1.dy;
										_this1.lastClockX = _this1.exPrev;
										_this1.lastClockY = _this1.eyPrev;
										var this67 = _this1.triArr;
										var tri16 = new trilateral_tri_Trilateral(_this1.jx,_this1.jy,_this1.dx,_this1.dy,_this1.ex,_this1.ey,0);
										this67[this67.length] = tri16;
										var this68 = _this1.triArr;
										var tri17 = new trilateral_tri_Trilateral(_this1.jx,_this1.jy,_this1.dx,_this1.dy,_this1.exPrev,_this1.eyPrev,0);
										this68[this68.length] = tri17;
									}
									if(clockWise1 && _this1.lastClock) {
										_this1.penultimateAX = _this1.jx;
										_this1.penultimateAY = _this1.jy;
										_this1.lastAntiX = _this1.ex;
										_this1.lastAntiY = _this1.ey;
										_this1.penultimateCX = _this1.dx;
										_this1.penultimateCY = _this1.dy;
										_this1.lastClockX = _this1.exPrev;
										_this1.lastClockY = _this1.eyPrev;
										var this69 = _this1.triArr;
										var tri18 = new trilateral_tri_Trilateral(_this1.jx,_this1.jy,_this1.dx,_this1.dy,_this1.ex,_this1.ey,0);
										this69[this69.length] = tri18;
										var this70 = _this1.triArr;
										var tri19 = new trilateral_tri_Trilateral(_this1.jx,_this1.jy,_this1.dx,_this1.dy,_this1.exPrev,_this1.eyPrev,0);
										this70[this70.length] = tri19;
									}
									if(!clockWise1 && !_this1.lastClock) {
										_this1.penultimateCX = _this1.dx;
										_this1.penultimateCY = _this1.dy;
										_this1.lastClockX = _this1.jx;
										_this1.lastClockY = _this1.jy;
										_this1.penultimateAX = _this1.dxPrev;
										_this1.penultimateAY = _this1.dyPrev;
										_this1.lastAntiX = _this1.ex;
										_this1.lastAntiY = _this1.ey;
										var this71 = _this1.triArr;
										var tri20 = new trilateral_tri_Trilateral(_this1.dxPrev,_this1.dyPrev,_this1.dx,_this1.dy,_this1.jx,_this1.jy,0);
										this71[this71.length] = tri20;
										var this72 = _this1.triArr;
										var tri21 = new trilateral_tri_Trilateral(_this1.dxPrev,_this1.dyPrev,_this1.dx,_this1.dy,_this1.ex,_this1.ey,0);
										this72[this72.length] = tri21;
									}
									if(!clockWise1 && _this1.lastClock) {
										_this1.penultimateAX = _this1.dxPrev;
										_this1.penultimateAY = _this1.dyPrev;
										_this1.lastAntiX = _this1.ex;
										_this1.lastAntiY = _this1.ey;
										_this1.penultimateCX = _this1.jx;
										_this1.penultimateCY = _this1.jy;
										_this1.lastClockX = _this1.dx;
										_this1.lastClockY = _this1.dy;
										var this73 = _this1.triArr;
										var tri22 = new trilateral_tri_Trilateral(_this1.jx,_this1.jy,_this1.dx,_this1.dy,_this1.ex,_this1.ey,0);
										this73[this73.length] = tri22;
										var this74 = _this1.triArr;
										var tri23 = new trilateral_tri_Trilateral(_this1.dxPrev,_this1.dyPrev,_this1.jx,_this1.jy,_this1.ex,_this1.ey,0);
										this74[this74.length] = tri23;
									}
								}
								if(clockWise1) {
									var radius4 = width_1 / 2;
									var edgePoly2 = _this1.pointsClock;
									var t17 = [];
									var this75;
									if(t17 == null) {
										var t18 = [];
										var this76 = t18 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t18;
										this75 = this76;
									} else {
										this75 = t17;
									}
									var this77 = this75;
									var out4 = this77;
									var pi4 = Math.PI;
									var step9 = pi4 * 2 / 36;
									var positive4 = dif10 >= 0;
									var totalSteps4 = Math.ceil(Math.abs(dif10) / step9);
									var step10 = dif10 / totalSteps4;
									var angle4 = theta01;
									var cx4;
									var cy4;
									var bx4 = 0;
									var by4 = 0;
									var p24 = edgePoly2.length;
									var count2 = 0;
									var _g19 = 0;
									var _g110 = totalSteps4 + 1;
									while(_g19 < _g110) {
										var i10 = _g19++;
										cx4 = ax_1 + radius4 * Math.sin(angle4);
										cy4 = ay_1 + radius4 * Math.cos(angle4);
										if(i10 != 0) {
											var t19 = new trilateral_tri_Trilateral(ax_1,ay_1,bx4,by4,cx4,cy4);
											out4[out4.length] = t19;
											edgePoly2[p24++] = cx4;
											edgePoly2[p24++] = cy4;
										}
										angle4 += step10;
										bx4 = cx4;
										by4 = cy4;
									}
									var trilateralArray2 = out4;
									var this78 = _this1.triArr;
									var _g20 = 0;
									while(_g20 < trilateralArray2.length) {
										var t20 = trilateralArray2[_g20];
										++_g20;
										this78[this78.length] = t20;
									}
								} else {
									var radius5 = width_1 / 2;
									var edgePoly3 = _this1.pointsAnti;
									var t21 = [];
									var this79;
									if(t21 == null) {
										var t22 = [];
										var this80 = t22 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t22;
										this79 = this80;
									} else {
										this79 = t21;
									}
									var this81 = this79;
									var out5 = this81;
									var pi5 = Math.PI;
									var step11 = pi5 * 2 / 36;
									var positive5 = dif10 >= 0;
									var totalSteps5 = Math.ceil(Math.abs(dif10) / step11);
									var step12 = dif10 / totalSteps5;
									var angle5 = theta01;
									var cx5;
									var cy5;
									var bx5 = 0;
									var by5 = 0;
									var p25 = edgePoly3.length;
									var count3 = 0;
									var _g23 = 0;
									var _g111 = totalSteps5 + 1;
									while(_g23 < _g111) {
										var i11 = _g23++;
										cx5 = ax_1 + radius5 * Math.sin(angle5);
										cy5 = ay_1 + radius5 * Math.cos(angle5);
										if(i11 != 0) {
											var t23 = new trilateral_tri_Trilateral(ax_1,ay_1,bx5,by5,cx5,cy5);
											out5[out5.length] = t23;
											edgePoly3[p25++] = cx5;
											edgePoly3[p25++] = cy5;
										}
										angle5 += step12;
										bx5 = cx5;
										by5 = cy5;
									}
									var trilateralArray3 = out5;
									var this82 = _this1.triArr;
									var _g24 = 0;
									while(_g24 < trilateralArray3.length) {
										var t24 = trilateralArray3[_g24];
										++_g24;
										this82[this82.length] = t24;
									}
								}
								_this1.kax = _this1.dxPrev;
								_this1.kay = _this1.dyPrev;
								_this1.kbx = _this1.dx;
								_this1.kby = _this1.dy;
								_this1.ncx = _this1.exPrev;
								_this1.ncy = _this1.eyPrev;
								_this1.kcx = _this1.ex;
								_this1.kcy = _this1.ey;
								if(_this1.count != 0) {
									if(clockWise1) {
										var this83 = _this1.triArr;
										var tri24 = new trilateral_tri_Trilateral(_this1.ax,_this1.ay,_this1.dxOld,_this1.dyOld,_this1.jx,_this1.jy,0);
										this83[this83.length] = tri24;
										var this84 = _this1.triArr;
										var tri25 = new trilateral_tri_Trilateral(_this1.ax,_this1.ay,_this1.exPrev,_this1.eyPrev,_this1.jx,_this1.jy,0);
										this84[this84.length] = tri25;
									} else {
										var this85 = _this1.triArr;
										var tri26 = new trilateral_tri_Trilateral(_this1.ax,_this1.ay,_this1.exOld,_this1.eyOld,_this1.jx,_this1.jy,0);
										this85[this85.length] = tri26;
										var this86 = _this1.triArr;
										var tri27 = new trilateral_tri_Trilateral(_this1.ax,_this1.ay,_this1.dxPrev,_this1.dyPrev,_this1.jx,_this1.jy,0);
										this86[this86.length] = tri27;
									}
								}
								_this1.jxOld = _this1.jx;
								_this1.jyOld = _this1.jy;
								_this1.lastClock = clockWise1;
								_this1.count++;
								var l4 = pathModify.points.length;
								var p3 = pathModify.points[l4 - 1];
								var l21 = p3.length;
								p3[l21] = x_1;
								p3[l21 + 1] = y_1;
								var d1 = pathModify.dim[pathModify.dim.length - 1];
								if(x_1 < d1.minX) {
									d1.minX = x_1;
								}
								if(x_1 > d1.maxX) {
									d1.maxX = x_1;
								}
								if(y_1 < d1.minY) {
									d1.minY = y_1;
								}
								if(y_1 > d1.maxY) {
									d1.maxY = y_1;
								}
								pathModify.x = x_1;
								pathModify.y = y_1;
							}
							while(i6 < l3) {
								var x_2 = arr[i6];
								var y_2 = arr[i6 + 1];
								var repeat2 = pathModify.x == x_2 && pathModify.y == y_2;
								if(!repeat2) {
									if(pathModify.widthFunction != null) {
										pathModify.width = pathModify.widthFunction(pathModify.width,pathModify.x,pathModify.x,x_2,y_2);
									}
									var _this2 = pathModify.contour;
									var ax_2 = pathModify.x;
									var ay_2 = pathModify.y;
									var width_2 = pathModify.width;
									var oldAngle2 = _this2.dx != null ? _this2.angle1 : null;
									_this2.halfA = Math.PI / 2;
									_this2.ax = x_2;
									_this2.ay = y_2;
									_this2.bx = ax_2;
									_this2.by = ay_2;
									_this2.beta = Math.PI / 2 - _this2.halfA;
									_this2.r = width_2 / 2 * Math.cos(_this2.beta);
									_this2.theta = Math.atan2(_this2.ay - _this2.by,_this2.ax - _this2.bx);
									if(_this2.theta > 0) {
										if(_this2.halfA < 0) {
											_this2.angle2 = _this2.theta + _this2.halfA + Math.PI / 2;
											_this2.angle1 = _this2.theta - _this2.halfA;
										} else {
											_this2.angle1 = _this2.theta + _this2.halfA - Math.PI;
											_this2.angle2 = _this2.theta + _this2.halfA;
										}
									} else if(_this2.halfA > 0) {
										_this2.angle1 = _this2.theta + _this2.halfA - Math.PI;
										_this2.angle2 = _this2.theta + _this2.halfA;
									} else {
										_this2.angle2 = _this2.theta + _this2.halfA + Math.PI / 2;
										_this2.angle1 = _this2.theta - _this2.halfA;
									}
									if(_this2.dxPrev != null) {
										_this2.dxOld = _this2.dxPrev;
									}
									if(_this2.dyPrev != null) {
										_this2.dyOld = _this2.dyPrev;
									}
									if(_this2.exPrev != null) {
										_this2.exOld = _this2.exPrev;
									}
									if(_this2.eyPrev != null) {
										_this2.eyOld = _this2.eyPrev;
									}
									if(_this2.dx != null) {
										_this2.dxPrev = _this2.dx;
									}
									if(_this2.dy != null) {
										_this2.dyPrev = _this2.dy;
									}
									if(_this2.ex != null) {
										_this2.exPrev = _this2.ex;
									}
									if(_this2.ey != null) {
										_this2.eyPrev = _this2.ey;
									}
									_this2.dx = _this2.bx + _this2.r * Math.cos(_this2.angle1);
									_this2.dy = _this2.by + _this2.r * Math.sin(_this2.angle1);
									_this2.ex = _this2.bx + _this2.r * Math.cos(_this2.angle2);
									_this2.ey = _this2.by + _this2.r * Math.sin(_this2.angle2);
									_this2.ax = ax_2;
									_this2.ay = ay_2;
									_this2.bx = x_2;
									_this2.by = y_2;
									_this2.theta = Math.atan2(_this2.ay - _this2.by,_this2.ax - _this2.bx);
									if(_this2.theta > 0) {
										if(_this2.halfA < 0) {
											_this2.angle2 = _this2.theta + _this2.halfA + Math.PI / 2;
											_this2.angle1 = _this2.theta - _this2.halfA;
										} else {
											_this2.angle1 = _this2.theta + _this2.halfA - Math.PI;
											_this2.angle2 = _this2.theta + _this2.halfA;
										}
									} else if(_this2.halfA > 0) {
										_this2.angle1 = _this2.theta + _this2.halfA - Math.PI;
										_this2.angle2 = _this2.theta + _this2.halfA;
									} else {
										_this2.angle2 = _this2.theta + _this2.halfA + Math.PI / 2;
										_this2.angle1 = _this2.theta - _this2.halfA;
									}
									if(_this2.dxPrev != null) {
										_this2.dxOld = _this2.dxPrev;
									}
									if(_this2.dyPrev != null) {
										_this2.dyOld = _this2.dyPrev;
									}
									if(_this2.exPrev != null) {
										_this2.exOld = _this2.exPrev;
									}
									if(_this2.eyPrev != null) {
										_this2.eyOld = _this2.eyPrev;
									}
									if(_this2.dx != null) {
										_this2.dxPrev = _this2.dx;
									}
									if(_this2.dy != null) {
										_this2.dyPrev = _this2.dy;
									}
									if(_this2.ex != null) {
										_this2.exPrev = _this2.ex;
									}
									if(_this2.ey != null) {
										_this2.eyPrev = _this2.ey;
									}
									_this2.dx = _this2.bx + _this2.r * Math.cos(_this2.angle1);
									_this2.dy = _this2.by + _this2.r * Math.sin(_this2.angle1);
									_this2.ex = _this2.bx + _this2.r * Math.cos(_this2.angle2);
									_this2.ey = _this2.by + _this2.r * Math.sin(_this2.angle2);
									var x7 = _this2.dxOld - x_2;
									var y7 = _this2.dyOld - y_2;
									var x8 = _this2.exOld - x_2;
									var y8 = _this2.eyOld - y_2;
									var clockWise2 = x7 * x7 + y7 * y7 > x8 * x8 + y8 * y8;
									var theta02;
									var theta18;
									if(clockWise2) {
										theta02 = -Math.atan2(_this2.ay - _this2.dyOld,_this2.ax - _this2.dxOld) - Math.PI / 2;
										theta18 = -Math.atan2(_this2.ay - _this2.eyPrev,_this2.ax - _this2.exPrev) - Math.PI / 2;
									} else {
										theta02 = -Math.atan2(_this2.ay - _this2.eyOld,_this2.ax - _this2.exOld) - Math.PI / 2;
										theta18 = -Math.atan2(_this2.ay - _this2.dyPrev,_this2.ax - _this2.dxPrev) - Math.PI / 2;
									}
									var dif20;
									switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
									case 0:
										var f34;
										if(theta02 >= 0 && theta02 > Math.PI) {
											f34 = theta02;
										} else {
											var a34 = theta02 % (2 * Math.PI);
											f34 = a34 >= 0 ? a34 : a34 + 2 * Math.PI;
										}
										var this87 = f34;
										var za16 = this87;
										var f35;
										if(theta18 >= 0 && theta18 > Math.PI) {
											f35 = theta18;
										} else {
											var a35 = theta18 % (2 * Math.PI);
											f35 = a35 >= 0 ? a35 : a35 + 2 * Math.PI;
										}
										var this88 = f35;
										var zb16 = this88;
										var fa16 = za16;
										var fb16 = zb16;
										var theta19 = Math.abs(theta02 - theta18);
										var clockwise16 = theta02 < theta18;
										var dif21 = clockwise16 ? theta19 : -theta19;
										dif20 = dif21 > 0 ? dif21 : 2 * Math.PI + dif21;
										break;
									case 1:
										var f36;
										if(theta02 >= 0 && theta02 > Math.PI) {
											f36 = theta02;
										} else {
											var a36 = theta02 % (2 * Math.PI);
											f36 = a36 >= 0 ? a36 : a36 + 2 * Math.PI;
										}
										var this89 = f36;
										var za17 = this89;
										var f37;
										if(theta18 >= 0 && theta18 > Math.PI) {
											f37 = theta18;
										} else {
											var a37 = theta18 % (2 * Math.PI);
											f37 = a37 >= 0 ? a37 : a37 + 2 * Math.PI;
										}
										var this90 = f37;
										var zb17 = this90;
										var fa17 = za17;
										var fb17 = zb17;
										var theta20 = Math.abs(theta02 - theta18);
										var clockwise17 = theta02 < theta18;
										var dif22 = clockwise17 ? theta20 : -theta20;
										dif20 = dif22 < 0 ? dif22 : -2 * Math.PI + dif22;
										break;
									case 2:
										var f38;
										if(theta02 >= 0 && theta02 > Math.PI) {
											f38 = theta02;
										} else {
											var a38 = theta02 % (2 * Math.PI);
											f38 = a38 >= 0 ? a38 : a38 + 2 * Math.PI;
										}
										var this91 = f38;
										var za18 = this91;
										var f39;
										if(theta18 >= 0 && theta18 > Math.PI) {
											f39 = theta18;
										} else {
											var a39 = theta18 % (2 * Math.PI);
											f39 = a39 >= 0 ? a39 : a39 + 2 * Math.PI;
										}
										var this92 = f39;
										var zb18 = this92;
										var fa18 = theta02;
										var fb18 = theta18;
										var theta21 = Math.abs(theta02 - theta18);
										var smallest4 = theta21 <= Math.PI;
										var clockwise18 = theta02 < theta18;
										var dif23 = clockwise18 ? theta21 : -theta21;
										dif20 = smallest4 ? dif23 : clockwise18 ? -(2 * Math.PI - theta21) : 2 * Math.PI - theta21;
										break;
									case 3:
										var f40;
										if(theta02 >= 0 && theta02 > Math.PI) {
											f40 = theta02;
										} else {
											var a40 = theta02 % (2 * Math.PI);
											f40 = a40 >= 0 ? a40 : a40 + 2 * Math.PI;
										}
										var this93 = f40;
										var za19 = this93;
										var f41;
										if(theta18 >= 0 && theta18 > Math.PI) {
											f41 = theta18;
										} else {
											var a41 = theta18 % (2 * Math.PI);
											f41 = a41 >= 0 ? a41 : a41 + 2 * Math.PI;
										}
										var this94 = f41;
										var zb19 = this94;
										var fa19 = theta02;
										var fb19 = theta18;
										var theta22 = Math.abs(theta02 - theta18);
										var largest4 = theta22 > Math.PI;
										var clockwise19 = theta02 < theta18;
										var dif24 = clockwise19 ? theta22 : -theta22;
										dif20 = largest4 ? dif24 : clockwise19 ? -(2 * Math.PI - theta22) : 2 * Math.PI - theta22;
										break;
									}
									if(_this2.count != 0) {
										var gamma4 = Math.abs(dif20) / 2;
										var h2 = width_2 / 2 / Math.cos(gamma4);
										var f42;
										if(theta02 <= Math.PI && theta02 > -Math.PI) {
											f42 = theta02;
										} else {
											var a42 = (theta02 + Math.PI) % (2 * Math.PI);
											f42 = a42 >= 0 ? a42 - Math.PI : a42 + Math.PI;
										}
										var this95 = f42;
										var start3 = this95;
										var start22 = start3;
										var delta2 = start22 + dif20 / 2 + Math.PI;
										_this2.jx = _this2.ax + h2 * Math.sin(delta2);
										_this2.jy = _this2.ay + h2 * Math.cos(delta2);
									}
									if(_this2.count == 0 && (_this2.endLine == 1 || _this2.endLine == 3)) {
										var ax3 = _this2.ax;
										var ay3 = _this2.ay;
										var radius6 = width_2 / 2;
										var beta2 = -_this2.angle1 - Math.PI / 2;
										var gamma5 = -_this2.angle1 - Math.PI / 2 + Math.PI;
										var temp2 = [];
										var this96 = _this2.triArr;
										var t25 = [];
										var this97;
										if(t25 == null) {
											var t26 = [];
											var this98 = t26 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t26;
											this97 = this98;
										} else {
											this97 = t25;
										}
										var this99 = this97;
										var out6 = this99;
										var pi6 = Math.PI;
										var step13 = pi6 * 2 / 36;
										var dif25;
										switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
										case 0:
											var f43;
											if(beta2 >= 0 && beta2 > Math.PI) {
												f43 = beta2;
											} else {
												var a43 = beta2 % (2 * Math.PI);
												f43 = a43 >= 0 ? a43 : a43 + 2 * Math.PI;
											}
											var this100 = f43;
											var za20 = this100;
											var f44;
											if(gamma5 >= 0 && gamma5 > Math.PI) {
												f44 = gamma5;
											} else {
												var a44 = gamma5 % (2 * Math.PI);
												f44 = a44 >= 0 ? a44 : a44 + 2 * Math.PI;
											}
											var this101 = f44;
											var zb20 = this101;
											var fa20 = za20;
											var fb20 = zb20;
											var theta23 = Math.abs(beta2 - gamma5);
											var clockwise20 = beta2 < gamma5;
											var dif26 = clockwise20 ? theta23 : -theta23;
											dif25 = dif26 > 0 ? dif26 : 2 * Math.PI + dif26;
											break;
										case 1:
											var f45;
											if(beta2 >= 0 && beta2 > Math.PI) {
												f45 = beta2;
											} else {
												var a45 = beta2 % (2 * Math.PI);
												f45 = a45 >= 0 ? a45 : a45 + 2 * Math.PI;
											}
											var this102 = f45;
											var za21 = this102;
											var f46;
											if(gamma5 >= 0 && gamma5 > Math.PI) {
												f46 = gamma5;
											} else {
												var a46 = gamma5 % (2 * Math.PI);
												f46 = a46 >= 0 ? a46 : a46 + 2 * Math.PI;
											}
											var this103 = f46;
											var zb21 = this103;
											var fa21 = za21;
											var fb21 = zb21;
											var theta24 = Math.abs(beta2 - gamma5);
											var clockwise21 = beta2 < gamma5;
											var dif27 = clockwise21 ? theta24 : -theta24;
											dif25 = dif27 < 0 ? dif27 : -2 * Math.PI + dif27;
											break;
										case 2:
											var f47;
											if(beta2 >= 0 && beta2 > Math.PI) {
												f47 = beta2;
											} else {
												var a47 = beta2 % (2 * Math.PI);
												f47 = a47 >= 0 ? a47 : a47 + 2 * Math.PI;
											}
											var this104 = f47;
											var za22 = this104;
											var f48;
											if(gamma5 >= 0 && gamma5 > Math.PI) {
												f48 = gamma5;
											} else {
												var a48 = gamma5 % (2 * Math.PI);
												f48 = a48 >= 0 ? a48 : a48 + 2 * Math.PI;
											}
											var this105 = f48;
											var zb22 = this105;
											var fa22 = beta2;
											var fb22 = gamma5;
											var theta25 = Math.abs(beta2 - gamma5);
											var smallest5 = theta25 <= Math.PI;
											var clockwise22 = beta2 < gamma5;
											var dif28 = clockwise22 ? theta25 : -theta25;
											dif25 = smallest5 ? dif28 : clockwise22 ? -(2 * Math.PI - theta25) : 2 * Math.PI - theta25;
											break;
										case 3:
											var f49;
											if(beta2 >= 0 && beta2 > Math.PI) {
												f49 = beta2;
											} else {
												var a49 = beta2 % (2 * Math.PI);
												f49 = a49 >= 0 ? a49 : a49 + 2 * Math.PI;
											}
											var this106 = f49;
											var za23 = this106;
											var f50;
											if(gamma5 >= 0 && gamma5 > Math.PI) {
												f50 = gamma5;
											} else {
												var a50 = gamma5 % (2 * Math.PI);
												f50 = a50 >= 0 ? a50 : a50 + 2 * Math.PI;
											}
											var this107 = f50;
											var zb23 = this107;
											var fa23 = beta2;
											var fb23 = gamma5;
											var theta26 = Math.abs(beta2 - gamma5);
											var largest5 = theta26 > Math.PI;
											var clockwise23 = beta2 < gamma5;
											var dif29 = clockwise23 ? theta26 : -theta26;
											dif25 = largest5 ? dif29 : clockwise23 ? -(2 * Math.PI - theta26) : 2 * Math.PI - theta26;
											break;
										}
										var positive6 = dif25 >= 0;
										var totalSteps6 = Math.ceil(Math.abs(dif25) / step13);
										var step14 = dif25 / totalSteps6;
										var angle6 = beta2;
										var cx6;
										var cy6;
										var bx6 = 0;
										var by6 = 0;
										var p26 = temp2.length;
										var _g25 = 0;
										var _g112 = totalSteps6 + 1;
										while(_g25 < _g112) {
											var i12 = _g25++;
											cx6 = ax3 + radius6 * Math.sin(angle6);
											cy6 = ay3 + radius6 * Math.cos(angle6);
											temp2[p26++] = cx6;
											temp2[p26++] = cy6;
											if(i12 != 0) {
												var t27 = new trilateral_tri_Trilateral(ax3,ay3,bx6,by6,cx6,cy6);
												out6[out6.length] = t27;
											}
											angle6 += step14;
											bx6 = cx6;
											by6 = cy6;
										}
										var triArr2 = out6;
										var _g26 = 0;
										while(_g26 < triArr2.length) {
											var t28 = triArr2[_g26];
											++_g26;
											this96[this96.length] = t28;
										}
										var pA2 = _this2.pointsAnti.length;
										var len2 = temp2.length / 2 | 0;
										var p42 = temp2.length / 4 | 0;
										var _g27 = 0;
										var _g113 = p42;
										while(_g27 < _g113) {
											var i13 = _g27++;
											_this2.pointsAnti[pA2++] = temp2[len2 - 2 * i13 + 1];
											_this2.pointsAnti[pA2++] = temp2[len2 - 2 * i13];
										}
										var pC2 = _this2.pointsClock.length;
										var _g28 = 0;
										var _g33 = p42;
										while(_g28 < _g33) {
											var i14 = _g28++;
											_this2.pointsClock[pC2++] = temp2[i14 * 2 + len2 + 1];
											_this2.pointsClock[pC2++] = temp2[i14 * 2 + len2];
										}
									}
									if(_this2.count != 0) {
										_this2.addQuads(clockWise2,width_2);
									}
									_this2.quadIndex = _this2.triArr.length;
									if(_this2.count == 0) {
										_this2.penultimateAX = _this2.dxPrev;
										_this2.penultimateAY = _this2.dyPrev;
										_this2.lastAntiX = _this2.ex;
										_this2.lastAntiY = _this2.ey;
										_this2.penultimateCX = _this2.dx;
										_this2.penultimateCY = _this2.dy;
										_this2.lastClockX = _this2.exPrev;
										_this2.lastClockY = _this2.eyPrev;
										var this108 = _this2.triArr;
										var tri28 = new trilateral_tri_Trilateral(_this2.dxPrev,_this2.dyPrev,_this2.dx,_this2.dy,_this2.ex,_this2.ey,0);
										this108[this108.length] = tri28;
										var this109 = _this2.triArr;
										var tri29 = new trilateral_tri_Trilateral(_this2.dxPrev,_this2.dyPrev,_this2.dx,_this2.dy,_this2.exPrev,_this2.eyPrev,0);
										this109[this109.length] = tri29;
									} else {
										if(clockWise2 && !_this2.lastClock) {
											_this2.penultimateAX = _this2.jx;
											_this2.penultimateAY = _this2.jy;
											_this2.lastAntiX = _this2.ex;
											_this2.lastAntiY = _this2.ey;
											_this2.penultimateCX = _this2.dx;
											_this2.penultimateCY = _this2.dy;
											_this2.lastClockX = _this2.exPrev;
											_this2.lastClockY = _this2.eyPrev;
											var this110 = _this2.triArr;
											var tri30 = new trilateral_tri_Trilateral(_this2.jx,_this2.jy,_this2.dx,_this2.dy,_this2.ex,_this2.ey,0);
											this110[this110.length] = tri30;
											var this111 = _this2.triArr;
											var tri31 = new trilateral_tri_Trilateral(_this2.jx,_this2.jy,_this2.dx,_this2.dy,_this2.exPrev,_this2.eyPrev,0);
											this111[this111.length] = tri31;
										}
										if(clockWise2 && _this2.lastClock) {
											_this2.penultimateAX = _this2.jx;
											_this2.penultimateAY = _this2.jy;
											_this2.lastAntiX = _this2.ex;
											_this2.lastAntiY = _this2.ey;
											_this2.penultimateCX = _this2.dx;
											_this2.penultimateCY = _this2.dy;
											_this2.lastClockX = _this2.exPrev;
											_this2.lastClockY = _this2.eyPrev;
											var this112 = _this2.triArr;
											var tri32 = new trilateral_tri_Trilateral(_this2.jx,_this2.jy,_this2.dx,_this2.dy,_this2.ex,_this2.ey,0);
											this112[this112.length] = tri32;
											var this113 = _this2.triArr;
											var tri33 = new trilateral_tri_Trilateral(_this2.jx,_this2.jy,_this2.dx,_this2.dy,_this2.exPrev,_this2.eyPrev,0);
											this113[this113.length] = tri33;
										}
										if(!clockWise2 && !_this2.lastClock) {
											_this2.penultimateCX = _this2.dx;
											_this2.penultimateCY = _this2.dy;
											_this2.lastClockX = _this2.jx;
											_this2.lastClockY = _this2.jy;
											_this2.penultimateAX = _this2.dxPrev;
											_this2.penultimateAY = _this2.dyPrev;
											_this2.lastAntiX = _this2.ex;
											_this2.lastAntiY = _this2.ey;
											var this114 = _this2.triArr;
											var tri34 = new trilateral_tri_Trilateral(_this2.dxPrev,_this2.dyPrev,_this2.dx,_this2.dy,_this2.jx,_this2.jy,0);
											this114[this114.length] = tri34;
											var this115 = _this2.triArr;
											var tri35 = new trilateral_tri_Trilateral(_this2.dxPrev,_this2.dyPrev,_this2.dx,_this2.dy,_this2.ex,_this2.ey,0);
											this115[this115.length] = tri35;
										}
										if(!clockWise2 && _this2.lastClock) {
											_this2.penultimateAX = _this2.dxPrev;
											_this2.penultimateAY = _this2.dyPrev;
											_this2.lastAntiX = _this2.ex;
											_this2.lastAntiY = _this2.ey;
											_this2.penultimateCX = _this2.jx;
											_this2.penultimateCY = _this2.jy;
											_this2.lastClockX = _this2.dx;
											_this2.lastClockY = _this2.dy;
											var this116 = _this2.triArr;
											var tri36 = new trilateral_tri_Trilateral(_this2.jx,_this2.jy,_this2.dx,_this2.dy,_this2.ex,_this2.ey,0);
											this116[this116.length] = tri36;
											var this117 = _this2.triArr;
											var tri37 = new trilateral_tri_Trilateral(_this2.dxPrev,_this2.dyPrev,_this2.jx,_this2.jy,_this2.ex,_this2.ey,0);
											this117[this117.length] = tri37;
										}
									}
									if(clockWise2) {
										var radius7 = width_2 / 2;
										var edgePoly4 = _this2.pointsClock;
										var t29 = [];
										var this118;
										if(t29 == null) {
											var t30 = [];
											var this119 = t30 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t30;
											this118 = this119;
										} else {
											this118 = t29;
										}
										var this120 = this118;
										var out7 = this120;
										var pi7 = Math.PI;
										var step15 = pi7 * 2 / 36;
										var positive7 = dif20 >= 0;
										var totalSteps7 = Math.ceil(Math.abs(dif20) / step15);
										var step16 = dif20 / totalSteps7;
										var angle7 = theta02;
										var cx7;
										var cy7;
										var bx7 = 0;
										var by7 = 0;
										var p27 = edgePoly4.length;
										var count4 = 0;
										var _g29 = 0;
										var _g114 = totalSteps7 + 1;
										while(_g29 < _g114) {
											var i15 = _g29++;
											cx7 = ax_2 + radius7 * Math.sin(angle7);
											cy7 = ay_2 + radius7 * Math.cos(angle7);
											if(i15 != 0) {
												var t31 = new trilateral_tri_Trilateral(ax_2,ay_2,bx7,by7,cx7,cy7);
												out7[out7.length] = t31;
												edgePoly4[p27++] = cx7;
												edgePoly4[p27++] = cy7;
											}
											angle7 += step16;
											bx7 = cx7;
											by7 = cy7;
										}
										var trilateralArray4 = out7;
										var this121 = _this2.triArr;
										var _g30 = 0;
										while(_g30 < trilateralArray4.length) {
											var t32 = trilateralArray4[_g30];
											++_g30;
											this121[this121.length] = t32;
										}
									} else {
										var radius8 = width_2 / 2;
										var edgePoly5 = _this2.pointsAnti;
										var t33 = [];
										var this122;
										if(t33 == null) {
											var t34 = [];
											var this123 = t34 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t34;
											this122 = this123;
										} else {
											this122 = t33;
										}
										var this124 = this122;
										var out8 = this124;
										var pi8 = Math.PI;
										var step17 = pi8 * 2 / 36;
										var positive8 = dif20 >= 0;
										var totalSteps8 = Math.ceil(Math.abs(dif20) / step17);
										var step18 = dif20 / totalSteps8;
										var angle8 = theta02;
										var cx8;
										var cy8;
										var bx8 = 0;
										var by8 = 0;
										var p28 = edgePoly5.length;
										var count5 = 0;
										var _g34 = 0;
										var _g115 = totalSteps8 + 1;
										while(_g34 < _g115) {
											var i16 = _g34++;
											cx8 = ax_2 + radius8 * Math.sin(angle8);
											cy8 = ay_2 + radius8 * Math.cos(angle8);
											if(i16 != 0) {
												var t35 = new trilateral_tri_Trilateral(ax_2,ay_2,bx8,by8,cx8,cy8);
												out8[out8.length] = t35;
												edgePoly5[p28++] = cx8;
												edgePoly5[p28++] = cy8;
											}
											angle8 += step18;
											bx8 = cx8;
											by8 = cy8;
										}
										var trilateralArray5 = out8;
										var this125 = _this2.triArr;
										var _g35 = 0;
										while(_g35 < trilateralArray5.length) {
											var t36 = trilateralArray5[_g35];
											++_g35;
											this125[this125.length] = t36;
										}
									}
									_this2.kax = _this2.dxPrev;
									_this2.kay = _this2.dyPrev;
									_this2.kbx = _this2.dx;
									_this2.kby = _this2.dy;
									_this2.ncx = _this2.exPrev;
									_this2.ncy = _this2.eyPrev;
									_this2.kcx = _this2.ex;
									_this2.kcy = _this2.ey;
									if(_this2.count != 0) {
										if(clockWise2) {
											var this126 = _this2.triArr;
											var tri38 = new trilateral_tri_Trilateral(_this2.ax,_this2.ay,_this2.dxOld,_this2.dyOld,_this2.jx,_this2.jy,0);
											this126[this126.length] = tri38;
											var this127 = _this2.triArr;
											var tri39 = new trilateral_tri_Trilateral(_this2.ax,_this2.ay,_this2.exPrev,_this2.eyPrev,_this2.jx,_this2.jy,0);
											this127[this127.length] = tri39;
										} else {
											var this128 = _this2.triArr;
											var tri40 = new trilateral_tri_Trilateral(_this2.ax,_this2.ay,_this2.exOld,_this2.eyOld,_this2.jx,_this2.jy,0);
											this128[this128.length] = tri40;
											var this129 = _this2.triArr;
											var tri41 = new trilateral_tri_Trilateral(_this2.ax,_this2.ay,_this2.dxPrev,_this2.dyPrev,_this2.jx,_this2.jy,0);
											this129[this129.length] = tri41;
										}
									}
									_this2.jxOld = _this2.jx;
									_this2.jyOld = _this2.jy;
									_this2.lastClock = clockWise2;
									_this2.count++;
									var l5 = pathModify.points.length;
									var p5 = pathModify.points[l5 - 1];
									var l22 = p5.length;
									p5[l22] = x_2;
									p5[l22 + 1] = y_2;
									var d2 = pathModify.dim[pathModify.dim.length - 1];
									if(x_2 < d2.minX) {
										d2.minX = x_2;
									}
									if(x_2 > d2.maxX) {
										d2.maxX = x_2;
									}
									if(y_2 < d2.minY) {
										d2.minY = y_2;
									}
									if(y_2 > d2.maxY) {
										d2.maxY = y_2;
									}
									pathModify.x = x_2;
									pathModify.y = y_2;
								}
								i6 += 2;
							}
							pathModify.x = x21;
							pathModify.y = y21;
						}
					} else {
						offCurvePoint = contour[i];
					}
				}
			}
		}
		this.fillDraw.triangles = this.triangles;
		this.fillDraw.fill(path.points,this.appColors.indexOf(16744192));
		this.fillDrawIn.triangles = this.trianglesIn;
		this.fillDrawIn.fill(path.points,this.appColors.indexOf(16744192));
		var this130 = this.triangles;
		var triArr3 = path.trilateralArray;
		var colorID = this.appColors.indexOf(16776960);
		var tri42;
		var _g36 = 0;
		while(_g36 < triArr3.length) {
			var t37 = triArr3[_g36];
			++_g36;
			if(t37 != null) {
				var t38 = Object.create(trilateral_tri_Triangle.prototype);
				t38.id = 7;
				t38.ax = t37.ax;
				t38.ay = t37.ay;
				t38.bx = t37.bx;
				t38.by = t37.by;
				t38.cx = t37.cx;
				t38.cy = t37.cy;
				t38.mark = t37.mark;
				t38.depth = 0;
				t38.alpha = 1.;
				t38.colorID = colorID;
				t38.colorA = colorID;
				t38.colorB = colorID;
				t38.colorC = colorID;
				t38.windingAdjusted = t37.windingAdjusted;
				tri42 = t38;
				this130[this130.length] = tri42;
			}
		}
		var this131 = this.trianglesIn;
		var triArr4 = path.trilateralArray;
		var colorID1 = this.appColors.indexOf(16776960);
		var tri43;
		var _g37 = 0;
		while(_g37 < triArr4.length) {
			var t39 = triArr4[_g37];
			++_g37;
			if(t39 != null) {
				var t40 = Object.create(trilateral_tri_Triangle.prototype);
				t40.id = 7;
				t40.ax = t39.ax;
				t40.ay = t39.ay;
				t40.bx = t39.bx;
				t40.by = t39.by;
				t40.cx = t39.cx;
				t40.cy = t39.cy;
				t40.mark = t39.mark;
				t40.depth = 0;
				t40.alpha = 1.;
				t40.colorID = colorID1;
				t40.colorA = colorID1;
				t40.colorB = colorID1;
				t40.colorC = colorID1;
				t40.windingAdjusted = t39.windingAdjusted;
				tri43 = t40;
				this131[this131.length] = tri43;
			}
		}
		this.triangles = this.trianglesIn.concat(this.triangles);
		this.setTriangles(this.triangles,this.appColors);
		var _gthis = this;
		htmlHelper_tools_AnimateTimer.onFrame = function(i17) {
			_gthis.render();
			return;
		};
		if(htmlHelper_tools_AnimateTimer.s == null) {
			htmlHelper_tools_AnimateTimer.s = window.document.createElement("style");
			htmlHelper_tools_AnimateTimer.s.innerHTML = "@keyframes spin { from { transform:rotate( 0deg ); } to { transform:rotate( 360deg ); } }";
			window.document.getElementsByTagName("head")[0].appendChild(htmlHelper_tools_AnimateTimer.s);
			htmlHelper_tools_AnimateTimer.s.animation = "spin 1s linear infinite";
			htmlHelper_tools_AnimateTimer.loop(60.0);
		}
	}
	,setTriangles: function(triangles,triangleColors) {
		var rgb;
		var colorAlpha = 1.;
		var tri;
		var count = 0;
		var i = 0;
		var c = 0;
		var j = 0;
		var ox = -1.0;
		var oy = -1.0;
		var no = 0;
		var _g = 0;
		while(_g < triangles.length) {
			var tri1 = triangles[_g];
			++_g;
			this.vertices[i++] = tri1.ax * this.scale + ox;
			this.vertices[i++] = -tri1.ay * this.scale + oy;
			this.vertices[i++] = tri1.depth * this.theta;
			this.vertices[i++] = tri1.cx * this.scale + ox;
			this.vertices[i++] = -tri1.cy * this.scale + oy;
			this.vertices[i++] = tri1.depth * this.theta;
			this.vertices[i++] = tri1.bx * this.scale + ox;
			this.vertices[i++] = -tri1.by * this.scale + oy;
			this.vertices[i++] = tri1.depth * this.theta;
			this.vertices[i++] = tri1.ax * this.scale + ox;
			this.vertices[i++] = -tri1.ay * this.scale + oy;
			this.vertices[i++] = tri1.depth * this.theta;
			this.vertices[i++] = tri1.bx * this.scale + ox;
			this.vertices[i++] = -tri1.by * this.scale + oy;
			this.vertices[i++] = tri1.depth * this.theta;
			this.vertices[i++] = tri1.cx * this.scale + ox;
			this.vertices[i++] = -tri1.cy * this.scale + oy;
			this.vertices[i++] = tri1.depth * this.theta;
			if(tri1.mark != 0) {
				var int = triangleColors[tri1.mark];
				rgb = { r : (int >> 16 & 255) / 255, g : (int >> 8 & 255) / 255, b : (int & 255) / 255};
			} else {
				var int1 = triangleColors[tri1.colorID];
				rgb = { r : (int1 >> 16 & 255) / 255, g : (int1 >> 8 & 255) / 255, b : (int1 & 255) / 255};
			}
			this.colors[c++] = rgb.r;
			this.colors[c++] = rgb.g;
			this.colors[c++] = rgb.b;
			this.colors[c++] = colorAlpha;
			this.indices[j++] = count++;
			this.colors[c++] = rgb.r;
			this.colors[c++] = rgb.g;
			this.colors[c++] = rgb.b;
			this.colors[c++] = colorAlpha;
			this.indices[j++] = count++;
			this.colors[c++] = rgb.r;
			this.colors[c++] = rgb.g;
			this.colors[c++] = rgb.b;
			this.colors[c++] = colorAlpha;
			this.indices[j++] = count++;
			this.colors[c++] = rgb.r;
			this.colors[c++] = rgb.g;
			this.colors[c++] = rgb.b;
			this.colors[c++] = colorAlpha;
			this.indices[j++] = count++;
			this.colors[c++] = rgb.r;
			this.colors[c++] = rgb.g;
			this.colors[c++] = rgb.b;
			this.colors[c++] = colorAlpha;
			this.indices[j++] = count++;
			this.colors[c++] = rgb.r;
			this.colors[c++] = rgb.g;
			this.colors[c++] = rgb.b;
			this.colors[c++] = colorAlpha;
			this.indices[j++] = count++;
		}
		var gl = this.gl;
		var program = this.program;
		var vertices = this.vertices;
		var colors = this.colors;
		var indices = this.indices;
		var vertexBuffer = gl.createBuffer();
		gl.bindBuffer(34962,vertexBuffer);
		gl.bufferData(34962,new Float32Array(vertices),35044);
		var position = gl.getAttribLocation(program,"pos");
		gl.vertexAttribPointer(position,3,5126,false,0,0);
		gl.enableVertexAttribArray(position);
		gl.bindBuffer(34962,null);
		var colorBuffer = gl.createBuffer();
		gl.bindBuffer(34962,colorBuffer);
		gl.bufferData(34962,new Float32Array(colors),35044);
		var col = gl.getAttribLocation(program,"color");
		gl.vertexAttribPointer(col,4,5126,false,0,0);
		gl.enableVertexAttribArray(col);
		gl.bindBuffer(34962,null);
	}
	,darkBackground: function() {
		var dark = 0.09375;
		this.bgRed = dark;
		this.bgGreen = dark;
		this.bgBlue = dark;
	}
	,findColorID: function(col) {
		return this.appColors.indexOf(col);
	}
	,setAnimate: function() {
		var _gthis = this;
		htmlHelper_tools_AnimateTimer.onFrame = function(i) {
			_gthis.render();
			return;
		};
		if(htmlHelper_tools_AnimateTimer.s == null) {
			htmlHelper_tools_AnimateTimer.s = window.document.createElement("style");
			htmlHelper_tools_AnimateTimer.s.innerHTML = "@keyframes spin { from { transform:rotate( 0deg ); } to { transform:rotate( 360deg ); } }";
			window.document.getElementsByTagName("head")[0].appendChild(htmlHelper_tools_AnimateTimer.s);
			htmlHelper_tools_AnimateTimer.s.animation = "spin 1s linear infinite";
			htmlHelper_tools_AnimateTimer.loop(60.0);
		}
	}
	,render: function() {
		if(this.theta > Math.PI) {
			this.theta = -Math.PI;
		}
		var alpha = this;
		var alpha1 = alpha.theta += Math.PI / 100;
		var ca = Math.cos(alpha1);
		var sa = Math.sin(alpha1);
		var _this__00 = ca;
		var _this__10 = -sa;
		var _this__20 = 0;
		var _this__30 = 0;
		var _this__01 = sa;
		var _this__11 = ca;
		var _this__21 = 0;
		var _this__31 = 0;
		var _this__02 = 0;
		var _this__12 = 0;
		var _this__22 = 1;
		var _this__32 = 0;
		var _this__03 = 0;
		var _this__13 = 0;
		var _this__23 = 0;
		var _this__33 = 1;
		var alpha2 = this.theta;
		var ca1 = Math.cos(alpha2);
		var sa1 = Math.sin(alpha2);
		var m__00 = ca1;
		var m__10 = 0;
		var m__20 = sa1;
		var m__30 = 0;
		var m__01 = 0;
		var m__11 = 1;
		var m__21 = 0;
		var m__31 = 0;
		var m__02 = -sa1;
		var m__12 = 0;
		var m__22 = ca1;
		var m__32 = 0;
		var m__03 = 0;
		var m__13 = 0;
		var m__23 = 0;
		var m__33 = 1;
		this.modelViewProjection = new khaMath_Matrix4(_this__00 * m__00 + _this__10 * m__01 + _this__20 * m__02 + _this__30 * m__03,_this__00 * m__10 + _this__10 * m__11 + _this__20 * m__12 + _this__30 * m__13,_this__00 * m__20 + _this__10 * m__21 + _this__20 * m__22 + _this__30 * m__23,_this__00 * m__30 + _this__10 * m__31 + _this__20 * m__32 + _this__30 * m__33,_this__01 * m__00 + _this__11 * m__01 + _this__21 * m__02 + _this__31 * m__03,_this__01 * m__10 + _this__11 * m__11 + _this__21 * m__12 + _this__31 * m__13,_this__01 * m__20 + _this__11 * m__21 + _this__21 * m__22 + _this__31 * m__23,_this__01 * m__30 + _this__11 * m__31 + _this__21 * m__32 + _this__31 * m__33,_this__02 * m__00 + _this__12 * m__01 + _this__22 * m__02 + _this__32 * m__03,_this__02 * m__10 + _this__12 * m__11 + _this__22 * m__12 + _this__32 * m__13,_this__02 * m__20 + _this__12 * m__21 + _this__22 * m__22 + _this__32 * m__23,_this__02 * m__30 + _this__12 * m__31 + _this__22 * m__32 + _this__32 * m__33,_this__03 * m__00 + _this__13 * m__01 + _this__23 * m__02 + _this__33 * m__03,_this__03 * m__10 + _this__13 * m__11 + _this__23 * m__12 + _this__33 * m__13,_this__03 * m__20 + _this__13 * m__21 + _this__23 * m__22 + _this__33 * m__23,_this__03 * m__30 + _this__13 * m__31 + _this__23 * m__32 + _this__33 * m__33);
		htmlHelper_webgl_WebGLSetup.prototype.render.call(this);
	}
	,spin: function() {
		if(this.theta > Math.PI) {
			this.theta = -Math.PI;
		}
		var alpha = this;
		var alpha1 = alpha.theta += Math.PI / 100;
		var ca = Math.cos(alpha1);
		var sa = Math.sin(alpha1);
		var _this__00 = ca;
		var _this__10 = -sa;
		var _this__20 = 0;
		var _this__30 = 0;
		var _this__01 = sa;
		var _this__11 = ca;
		var _this__21 = 0;
		var _this__31 = 0;
		var _this__02 = 0;
		var _this__12 = 0;
		var _this__22 = 1;
		var _this__32 = 0;
		var _this__03 = 0;
		var _this__13 = 0;
		var _this__23 = 0;
		var _this__33 = 1;
		var alpha2 = this.theta;
		var ca1 = Math.cos(alpha2);
		var sa1 = Math.sin(alpha2);
		var m__00 = ca1;
		var m__10 = 0;
		var m__20 = sa1;
		var m__30 = 0;
		var m__01 = 0;
		var m__11 = 1;
		var m__21 = 0;
		var m__31 = 0;
		var m__02 = -sa1;
		var m__12 = 0;
		var m__22 = ca1;
		var m__32 = 0;
		var m__03 = 0;
		var m__13 = 0;
		var m__23 = 0;
		var m__33 = 1;
		return new khaMath_Matrix4(_this__00 * m__00 + _this__10 * m__01 + _this__20 * m__02 + _this__30 * m__03,_this__00 * m__10 + _this__10 * m__11 + _this__20 * m__12 + _this__30 * m__13,_this__00 * m__20 + _this__10 * m__21 + _this__20 * m__22 + _this__30 * m__23,_this__00 * m__30 + _this__10 * m__31 + _this__20 * m__32 + _this__30 * m__33,_this__01 * m__00 + _this__11 * m__01 + _this__21 * m__02 + _this__31 * m__03,_this__01 * m__10 + _this__11 * m__11 + _this__21 * m__12 + _this__31 * m__13,_this__01 * m__20 + _this__11 * m__21 + _this__21 * m__22 + _this__31 * m__23,_this__01 * m__30 + _this__11 * m__31 + _this__21 * m__32 + _this__31 * m__33,_this__02 * m__00 + _this__12 * m__01 + _this__22 * m__02 + _this__32 * m__03,_this__02 * m__10 + _this__12 * m__11 + _this__22 * m__12 + _this__32 * m__13,_this__02 * m__20 + _this__12 * m__21 + _this__22 * m__22 + _this__32 * m__23,_this__02 * m__30 + _this__12 * m__31 + _this__22 * m__32 + _this__32 * m__33,_this__03 * m__00 + _this__13 * m__01 + _this__23 * m__02 + _this__33 * m__03,_this__03 * m__10 + _this__13 * m__11 + _this__23 * m__12 + _this__33 * m__13,_this__03 * m__20 + _this__13 * m__21 + _this__23 * m__22 + _this__33 * m__23,_this__03 * m__30 + _this__13 * m__31 + _this__23 * m__32 + _this__33 * m__33);
	}
});
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x, x && x[0]=="0" && (x[1]=="x" || x[1]=="X") ? 16 : 10);
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var format_ttf_TableId = function() { };
format_ttf_TableId.__name__ = true;
var format_ttf_CFlag = function() { };
format_ttf_CFlag.__name__ = true;
var format_ttf_MacGlyphNames = function() { };
format_ttf_MacGlyphNames.__name__ = true;
var format_ttf__$Data_Header_$_$Impl_$ = {};
format_ttf__$Data_Header_$_$Impl_$.__name__ = true;
format_ttf__$Data_Header_$_$Impl_$._new = function(header) {
	var this1 = header;
	return this1;
};
format_ttf__$Data_Header_$_$Impl_$.fromInput = function(input) {
	var this1 = { majorVersion : input.readUInt16(), minorVersion : input.readUInt16(), numTables : input.readUInt16(), searchRange : input.readUInt16(), entrySelector : input.readUInt16(), rangeShift : input.readUInt16()};
	return this1;
};
var format_ttf_Table = $hxEnums["format.ttf.Table"] = { __ename__ : "format.ttf.Table", __constructs__ : ["TGlyf","THmtx","TCmap","TKern","TName","THead","THhea","TLoca","TMaxp","TPost","TOS2","TUnkn"]
	,TGlyf: ($_=function(descriptions) { return {_hx_index:0,descriptions:descriptions,__enum__:"format.ttf.Table",toString:$estr}; },$_.__params__ = ["descriptions"],$_)
	,THmtx: ($_=function(metrics) { return {_hx_index:1,metrics:metrics,__enum__:"format.ttf.Table",toString:$estr}; },$_.__params__ = ["metrics"],$_)
	,TCmap: ($_=function(subtables) { return {_hx_index:2,subtables:subtables,__enum__:"format.ttf.Table",toString:$estr}; },$_.__params__ = ["subtables"],$_)
	,TKern: ($_=function(kerning) { return {_hx_index:3,kerning:kerning,__enum__:"format.ttf.Table",toString:$estr}; },$_.__params__ = ["kerning"],$_)
	,TName: ($_=function(records) { return {_hx_index:4,records:records,__enum__:"format.ttf.Table",toString:$estr}; },$_.__params__ = ["records"],$_)
	,THead: ($_=function(data) { return {_hx_index:5,data:data,__enum__:"format.ttf.Table",toString:$estr}; },$_.__params__ = ["data"],$_)
	,THhea: ($_=function(data) { return {_hx_index:6,data:data,__enum__:"format.ttf.Table",toString:$estr}; },$_.__params__ = ["data"],$_)
	,TLoca: ($_=function(data) { return {_hx_index:7,data:data,__enum__:"format.ttf.Table",toString:$estr}; },$_.__params__ = ["data"],$_)
	,TMaxp: ($_=function(data) { return {_hx_index:8,data:data,__enum__:"format.ttf.Table",toString:$estr}; },$_.__params__ = ["data"],$_)
	,TPost: ($_=function(data) { return {_hx_index:9,data:data,__enum__:"format.ttf.Table",toString:$estr}; },$_.__params__ = ["data"],$_)
	,TOS2: ($_=function(data) { return {_hx_index:10,data:data,__enum__:"format.ttf.Table",toString:$estr}; },$_.__params__ = ["data"],$_)
	,TUnkn: ($_=function(bytes) { return {_hx_index:11,bytes:bytes,__enum__:"format.ttf.Table",toString:$estr}; },$_.__params__ = ["bytes"],$_)
};
var format_ttf_GlyfDescription = $hxEnums["format.ttf.GlyfDescription"] = { __ename__ : "format.ttf.GlyfDescription", __constructs__ : ["TGlyphSimple","TGlyphComposite","TGlyphNull"]
	,TGlyphSimple: ($_=function(header,data) { return {_hx_index:0,header:header,data:data,__enum__:"format.ttf.GlyfDescription",toString:$estr}; },$_.__params__ = ["header","data"],$_)
	,TGlyphComposite: ($_=function(header,components) { return {_hx_index:1,header:header,components:components,__enum__:"format.ttf.GlyfDescription",toString:$estr}; },$_.__params__ = ["header","components"],$_)
	,TGlyphNull: {_hx_index:2,__enum__:"format.ttf.GlyfDescription",toString:$estr}
};
var format_ttf_Transform = $hxEnums["format.ttf.Transform"] = { __ename__ : "format.ttf.Transform", __constructs__ : ["Transform1","Transform2","Transform3"]
	,Transform1: ($_=function(scale) { return {_hx_index:0,scale:scale,__enum__:"format.ttf.Transform",toString:$estr}; },$_.__params__ = ["scale"],$_)
	,Transform2: ($_=function(xscale,yscale) { return {_hx_index:1,xscale:xscale,yscale:yscale,__enum__:"format.ttf.Transform",toString:$estr}; },$_.__params__ = ["xscale","yscale"],$_)
	,Transform3: ($_=function(xscale,yscale,scale01,scale10) { return {_hx_index:2,xscale:xscale,yscale:yscale,scale01:scale01,scale10:scale10,__enum__:"format.ttf.Transform",toString:$estr}; },$_.__params__ = ["xscale","yscale","scale01","scale10"],$_)
};
var format_ttf_CmapSubTable = $hxEnums["format.ttf.CmapSubTable"] = { __ename__ : "format.ttf.CmapSubTable", __constructs__ : ["Cmap0","Cmap2","Cmap4","Cmap6","Cmap8","Cmap10","Cmap12","CmapUnk"]
	,Cmap0: ($_=function(header,glyphIndexArray) { return {_hx_index:0,header:header,glyphIndexArray:glyphIndexArray,__enum__:"format.ttf.CmapSubTable",toString:$estr}; },$_.__params__ = ["header","glyphIndexArray"],$_)
	,Cmap2: ($_=function(header,glyphIndexArray,subHeaderKeys,subHeaders) { return {_hx_index:1,header:header,glyphIndexArray:glyphIndexArray,subHeaderKeys:subHeaderKeys,subHeaders:subHeaders,__enum__:"format.ttf.CmapSubTable",toString:$estr}; },$_.__params__ = ["header","glyphIndexArray","subHeaderKeys","subHeaders"],$_)
	,Cmap4: ($_=function(header,glyphIndexArray) { return {_hx_index:2,header:header,glyphIndexArray:glyphIndexArray,__enum__:"format.ttf.CmapSubTable",toString:$estr}; },$_.__params__ = ["header","glyphIndexArray"],$_)
	,Cmap6: ($_=function(header,glyphIndexArray,firstCode) { return {_hx_index:3,header:header,glyphIndexArray:glyphIndexArray,firstCode:firstCode,__enum__:"format.ttf.CmapSubTable",toString:$estr}; },$_.__params__ = ["header","glyphIndexArray","firstCode"],$_)
	,Cmap8: ($_=function(header,groups,is32) { return {_hx_index:4,header:header,groups:groups,is32:is32,__enum__:"format.ttf.CmapSubTable",toString:$estr}; },$_.__params__ = ["header","groups","is32"],$_)
	,Cmap10: ($_=function(header,glyphIndexArray,startCharCode,numChars) { return {_hx_index:5,header:header,glyphIndexArray:glyphIndexArray,startCharCode:startCharCode,numChars:numChars,__enum__:"format.ttf.CmapSubTable",toString:$estr}; },$_.__params__ = ["header","glyphIndexArray","startCharCode","numChars"],$_)
	,Cmap12: ($_=function(header,groups) { return {_hx_index:6,header:header,groups:groups,__enum__:"format.ttf.CmapSubTable",toString:$estr}; },$_.__params__ = ["header","groups"],$_)
	,CmapUnk: ($_=function(header,bytes) { return {_hx_index:7,header:header,bytes:bytes,__enum__:"format.ttf.CmapSubTable",toString:$estr}; },$_.__params__ = ["header","bytes"],$_)
};
var format_ttf_KernSubTable = $hxEnums["format.ttf.KernSubTable"] = { __ename__ : "format.ttf.KernSubTable", __constructs__ : ["KernSub0","KernSub1"]
	,KernSub0: ($_=function(kerningPairs) { return {_hx_index:0,kerningPairs:kerningPairs,__enum__:"format.ttf.KernSubTable",toString:$estr}; },$_.__params__ = ["kerningPairs"],$_)
	,KernSub1: ($_=function(array) { return {_hx_index:1,array:array,__enum__:"format.ttf.KernSubTable",toString:$estr}; },$_.__params__ = ["array"],$_)
};
var format_ttf__$Data_HeadData_$_$Impl_$ = {};
format_ttf__$Data_HeadData_$_$Impl_$.__name__ = true;
format_ttf__$Data_HeadData_$_$Impl_$._new = function(headData) {
	var this1 = headData;
	return this1;
};
format_ttf__$Data_HeadData_$_$Impl_$.fromBytes = function(bytes) {
	if(bytes == null) {
		throw new js__$Boot_HaxeError("no head table found");
	}
	var i = new haxe_io_BytesInput(bytes);
	i.set_bigEndian(true);
	var this1 = { version : i.readInt32(), fontRevision : i.readInt32(), checkSumAdjustment : i.readInt32(), magicNumber : i.readInt32(), flags : i.readUInt16(), unitsPerEm : i.readUInt16(), created : i.readDouble(), modified : i.readDouble(), xMin : i.readInt16(), yMin : i.readInt16(), xMax : i.readInt16(), yMax : i.readInt16(), macStyle : i.readUInt16(), lowestRecPPEM : i.readUInt16(), fontDirectionHint : i.readInt16(), indexToLocFormat : i.readInt16(), glyphDataFormat : i.readInt16()};
	return this1;
};
var format_ttf__$Data_HheaData_$_$Impl_$ = {};
format_ttf__$Data_HheaData_$_$Impl_$.__name__ = true;
format_ttf__$Data_HheaData_$_$Impl_$._new = function(hheaData) {
	var this1 = hheaData;
	return this1;
};
format_ttf__$Data_HheaData_$_$Impl_$.fromBytes = function(bytes) {
	if(bytes == null) {
		throw new js__$Boot_HaxeError("no hhea table found");
	}
	var i = new haxe_io_BytesInput(bytes);
	i.set_bigEndian(true);
	var this1 = { version : i.readInt32(), ascender : i.readInt16(), descender : i.readInt16(), lineGap : i.readInt16(), advanceWidthMax : i.readUInt16(), minLeftSideBearing : i.readInt16(), minRightSideBearing : i.readInt16(), xMaxExtent : i.readInt16(), caretSlopeRise : i.readInt16(), caretSlopeRun : i.readInt16(), caretOffset : i.readInt16(), reserved : i.read(8), metricDataFormat : i.readInt16(), numberOfHMetrics : i.readUInt16()};
	return this1;
};
var format_ttf__$Data_MaxpData_$_$Impl_$ = {};
format_ttf__$Data_MaxpData_$_$Impl_$.__name__ = true;
format_ttf__$Data_MaxpData_$_$Impl_$._new = function(maxpData) {
	var this1 = maxpData;
	return this1;
};
format_ttf__$Data_MaxpData_$_$Impl_$.fromBytes = function(bytes) {
	if(bytes == null) {
		throw new js__$Boot_HaxeError("no maxp table found");
	}
	var i = new haxe_io_BytesInput(bytes);
	i.set_bigEndian(true);
	var this1 = { versionNumber : i.readInt32(), numGlyphs : i.readUInt16(), maxPoints : i.readUInt16(), maxContours : i.readUInt16(), maxComponentPoints : i.readUInt16(), maxComponentContours : i.readUInt16(), maxZones : i.readUInt16(), maxTwilightPoints : i.readUInt16(), maxStorage : i.readUInt16(), maxFunctionDefs : i.readUInt16(), maxInstructionDefs : i.readUInt16(), maxStackElements : i.readUInt16(), maxSizeOfInstructions : i.readUInt16(), maxComponentElements : i.readUInt16(), maxComponentDepth : i.readUInt16()};
	return this1;
};
var format_ttf__$Data_OS2Data_$_$Impl_$ = {};
format_ttf__$Data_OS2Data_$_$Impl_$.__name__ = true;
format_ttf__$Data_OS2Data_$_$Impl_$._new = function(oS2Data) {
	var this1 = oS2Data;
	return this1;
};
format_ttf__$Data_OS2Data_$_$Impl_$.fromBytes = function(bytes) {
	if(bytes == null) {
		throw new js__$Boot_HaxeError("no maxp table found");
	}
	var i = new haxe_io_BytesInput(bytes);
	i.set_bigEndian(true);
	var this1 = { version : i.readUInt16(), xAvgCharWidth : i.readInt16(), usWeightClass : i.readUInt16(), usWidthClass : i.readUInt16(), fsType : i.readInt16(), ySubscriptXSize : i.readInt16(), ySubscriptYSize : i.readInt16(), ySubscriptXOffset : i.readInt16(), ySubscriptYOffset : i.readInt16(), ySuperscriptXSize : i.readInt16(), ySuperscriptYSize : i.readInt16(), ySuperscriptXOffset : i.readInt16(), ySuperscriptYOffset : i.readInt16(), yStrikeoutSize : i.readInt16(), yStrikeoutPosition : i.readInt16(), sFamilyClass : i.readInt16(), bFamilyType : i.readByte(), bSerifStyle : i.readByte(), bWeight : i.readByte(), bProportion : i.readByte(), bContrast : i.readByte(), bStrokeVariation : i.readByte(), bArmStyle : i.readByte(), bLetterform : i.readByte(), bMidline : i.readByte(), bXHeight : i.readByte(), ulUnicodeRange1 : i.readInt32(), ulUnicodeRange2 : i.readInt32(), ulUnicodeRange3 : i.readInt32(), ulUnicodeRange4 : i.readInt32(), achVendorID : i.readInt32(), fsSelection : i.readInt16(), usFirstCharIndex : i.readUInt16(), usLastCharIndex : i.readUInt16(), sTypoAscender : i.readInt16(), sTypoDescender : i.readInt16(), sTypoLineGap : i.readInt16(), usWinAscent : i.readUInt16(), usWinDescent : i.readUInt16()};
	return this1;
};
var format_ttf_Reader = function(i) {
	this.input = i;
	this.input.set_bigEndian(true);
};
format_ttf_Reader.__name__ = true;
format_ttf_Reader.prototype = {
	read: function() {
		var input = this.input;
		var this1 = { majorVersion : input.readUInt16(), minorVersion : input.readUInt16(), numTables : input.readUInt16(), searchRange : input.readUInt16(), entrySelector : input.readUInt16(), rangeShift : input.readUInt16()};
		var header = this1;
		var directory = this.readDirectory(header);
		var _this = this.tablesHash;
		var bytes = __map_reserved["hhea"] != null ? _this.getReserved("hhea") : _this.h["hhea"];
		if(bytes == null) {
			throw new js__$Boot_HaxeError("no hhea table found");
		}
		var i = new haxe_io_BytesInput(bytes);
		i.set_bigEndian(true);
		var this2 = { version : i.readInt32(), ascender : i.readInt16(), descender : i.readInt16(), lineGap : i.readInt16(), advanceWidthMax : i.readUInt16(), minLeftSideBearing : i.readInt16(), minRightSideBearing : i.readInt16(), xMaxExtent : i.readInt16(), caretSlopeRise : i.readInt16(), caretSlopeRun : i.readInt16(), caretOffset : i.readInt16(), reserved : i.read(8), metricDataFormat : i.readInt16(), numberOfHMetrics : i.readUInt16()};
		var hheaData = this2;
		var _this1 = this.tablesHash;
		var bytes1 = __map_reserved["head"] != null ? _this1.getReserved("head") : _this1.h["head"];
		if(bytes1 == null) {
			throw new js__$Boot_HaxeError("no head table found");
		}
		var i1 = new haxe_io_BytesInput(bytes1);
		i1.set_bigEndian(true);
		var this3 = { version : i1.readInt32(), fontRevision : i1.readInt32(), checkSumAdjustment : i1.readInt32(), magicNumber : i1.readInt32(), flags : i1.readUInt16(), unitsPerEm : i1.readUInt16(), created : i1.readDouble(), modified : i1.readDouble(), xMin : i1.readInt16(), yMin : i1.readInt16(), xMax : i1.readInt16(), yMax : i1.readInt16(), macStyle : i1.readUInt16(), lowestRecPPEM : i1.readUInt16(), fontDirectionHint : i1.readInt16(), indexToLocFormat : i1.readInt16(), glyphDataFormat : i1.readInt16()};
		var headData = this3;
		var _this2 = this.tablesHash;
		var bytes2 = __map_reserved["maxp"] != null ? _this2.getReserved("maxp") : _this2.h["maxp"];
		if(bytes2 == null) {
			throw new js__$Boot_HaxeError("no maxp table found");
		}
		var i2 = new haxe_io_BytesInput(bytes2);
		i2.set_bigEndian(true);
		var this4 = { versionNumber : i2.readInt32(), numGlyphs : i2.readUInt16(), maxPoints : i2.readUInt16(), maxContours : i2.readUInt16(), maxComponentPoints : i2.readUInt16(), maxComponentContours : i2.readUInt16(), maxZones : i2.readUInt16(), maxTwilightPoints : i2.readUInt16(), maxStorage : i2.readUInt16(), maxFunctionDefs : i2.readUInt16(), maxInstructionDefs : i2.readUInt16(), maxStackElements : i2.readUInt16(), maxSizeOfInstructions : i2.readUInt16(), maxComponentElements : i2.readUInt16(), maxComponentDepth : i2.readUInt16()};
		var maxpData = this4;
		var _this3 = this.tablesHash;
		var locaData = this.readLocaTable(__map_reserved["loca"] != null ? _this3.getReserved("loca") : _this3.h["loca"],headData,maxpData);
		var _this4 = this.tablesHash;
		var hmtxData = this.readHmtxTable(__map_reserved["hmtx"] != null ? _this4.getReserved("hmtx") : _this4.h["hmtx"],maxpData,hheaData);
		var _this5 = this.tablesHash;
		var cmapData = this.readCmapTable(__map_reserved["cmap"] != null ? _this5.getReserved("cmap") : _this5.h["cmap"]);
		var _this6 = this.tablesHash;
		var glyfData = this.readGlyfTable(__map_reserved["glyf"] != null ? _this6.getReserved("glyf") : _this6.h["glyf"],maxpData,locaData,cmapData,hmtxData);
		var _this7 = this.tablesHash;
		var kernData = this.readKernTable(__map_reserved["kern"] != null ? _this7.getReserved("kern") : _this7.h["kern"]);
		var _this8 = this.tablesHash;
		var bytes3 = __map_reserved["OS_2"] != null ? _this8.getReserved("OS_2") : _this8.h["OS_2"];
		if(bytes3 == null) {
			throw new js__$Boot_HaxeError("no maxp table found");
		}
		var i3 = new haxe_io_BytesInput(bytes3);
		i3.set_bigEndian(true);
		var this5 = { version : i3.readUInt16(), xAvgCharWidth : i3.readInt16(), usWeightClass : i3.readUInt16(), usWidthClass : i3.readUInt16(), fsType : i3.readInt16(), ySubscriptXSize : i3.readInt16(), ySubscriptYSize : i3.readInt16(), ySubscriptXOffset : i3.readInt16(), ySubscriptYOffset : i3.readInt16(), ySuperscriptXSize : i3.readInt16(), ySuperscriptYSize : i3.readInt16(), ySuperscriptXOffset : i3.readInt16(), ySuperscriptYOffset : i3.readInt16(), yStrikeoutSize : i3.readInt16(), yStrikeoutPosition : i3.readInt16(), sFamilyClass : i3.readInt16(), bFamilyType : i3.readByte(), bSerifStyle : i3.readByte(), bWeight : i3.readByte(), bProportion : i3.readByte(), bContrast : i3.readByte(), bStrokeVariation : i3.readByte(), bArmStyle : i3.readByte(), bLetterform : i3.readByte(), bMidline : i3.readByte(), bXHeight : i3.readByte(), ulUnicodeRange1 : i3.readInt32(), ulUnicodeRange2 : i3.readInt32(), ulUnicodeRange3 : i3.readInt32(), ulUnicodeRange4 : i3.readInt32(), achVendorID : i3.readInt32(), fsSelection : i3.readInt16(), usFirstCharIndex : i3.readUInt16(), usLastCharIndex : i3.readUInt16(), sTypoAscender : i3.readInt16(), sTypoDescender : i3.readInt16(), sTypoLineGap : i3.readInt16(), usWinAscent : i3.readUInt16(), usWinDescent : i3.readUInt16()};
		var os2Data = this5;
		var _this9 = this.tablesHash;
		var nameData = this.readNameTable(__map_reserved["_name"] != null ? _this9.getReserved("_name") : _this9.h["_name"]);
		var tables = [format_ttf_Table.THhea(hheaData),format_ttf_Table.THead(headData),format_ttf_Table.TMaxp(maxpData),format_ttf_Table.TLoca(locaData),format_ttf_Table.THmtx(hmtxData),format_ttf_Table.TCmap(cmapData),format_ttf_Table.TGlyf(glyfData),format_ttf_Table.TKern(kernData),format_ttf_Table.TOS2(os2Data),format_ttf_Table.TName(nameData)];
		return { header : header, directory : directory, tables : tables};
	}
	,readDirectory: function(header) {
		this.tablesHash = new haxe_ds_StringMap();
		var directory = [];
		var _g = 0;
		var _g1 = header.numTables;
		while(_g < _g1) {
			var i = _g++;
			var tableId = this.input.readInt32();
			var bytesOutput = new haxe_io_BytesOutput();
			bytesOutput.set_bigEndian(true);
			bytesOutput.writeInt32(tableId);
			var bytesName = bytesOutput.getBytes();
			var tableName = new haxe_io_BytesInput(bytesName).readString(4);
			if(tableName == "name") {
				tableName = "_name";
			}
			directory[i] = { tableId : tableId, tableName : tableName, checksum : this.input.readInt32(), offset : this.input.readInt32(), length : this.input.readInt32()};
		}
		directory.sort($bind(this,this.sortOnOffset32));
		var _g2 = 0;
		var _g3 = directory.length;
		while(_g2 < _g3) {
			var i1 = _g2++;
			var entry = directory[i1];
			var start = entry.offset;
			var end;
			if(i1 == directory.length - 1) {
				end = start + entry.length | 0;
			} else {
				end = directory[i1 + 1].offset;
			}
			var bytes = this.input.read(end - start | 0);
			var _this = this.tablesHash;
			var key = entry.tableName.split("/").join("_");
			if(__map_reserved[key] != null) {
				_this.setReserved(key,bytes);
			} else {
				_this.h[key] = bytes;
			}
		}
		return directory;
	}
	,sortOnOffset32: function(e1,e2) {
		var x = e1.offset;
		var y = e2.offset;
		var result = 0;
		if(x < y) {
			result = -1;
		}
		if(x == y) {
			result = 0;
		}
		if(x > y) {
			result = 1;
		}
		return result;
	}
	,sortOnOffset16: function(e1,e2) {
		var x = e1.offset;
		var y = e2.offset;
		var result = 0;
		if(x < y) {
			result = -1;
		}
		if(x == y) {
			result = 0;
		}
		if(x > y) {
			result = 1;
		}
		return result;
	}
	,readLocaTable: function(bytes,head,maxp) {
		if(bytes == null) {
			throw new js__$Boot_HaxeError("no loca table found");
		}
		var input = new haxe_io_BytesInput(bytes);
		input.set_bigEndian(true);
		var offsets = [];
		if(head.indexToLocFormat == 0) {
			var _g = 0;
			var _g1 = maxp.numGlyphs + 1;
			while(_g < _g1) {
				var i = _g++;
				offsets[i] = input.readUInt16() * 2;
			}
		} else {
			var _g2 = 0;
			var _g11 = maxp.numGlyphs + 1;
			while(_g2 < _g11) {
				var i1 = _g2++;
				offsets[i1] = input.readInt32();
			}
		}
		return { factor : head.indexToLocFormat == 0 ? 2 : 1, offsets : offsets};
	}
	,readHmtxTable: function(bytes,maxp,hhea) {
		if(bytes == null) {
			throw new js__$Boot_HaxeError("no hmtx table found");
		}
		var input = new haxe_io_BytesInput(bytes);
		input.set_bigEndian(true);
		var metrics = [];
		var _g = 0;
		var _g1 = hhea.numberOfHMetrics;
		while(_g < _g1) {
			var i = _g++;
			metrics.push({ advanceWidth : input.readUInt16(), leftSideBearing : input.readInt16()});
		}
		var len = maxp.numGlyphs - hhea.numberOfHMetrics;
		var lastAdvanceWidth = metrics[metrics.length - 1].advanceWidth;
		var _g2 = 0;
		var _g3 = len;
		while(_g2 < _g3) {
			var i1 = _g2++;
			metrics.push({ advanceWidth : lastAdvanceWidth, leftSideBearing : input.readInt16()});
		}
		return metrics;
	}
	,readGlyfTable: function(bytes,maxp,loca,cmap,hmtx) {
		if(bytes == null) {
			throw new js__$Boot_HaxeError("no glyf table found");
		}
		var input = new haxe_io_BytesInput(bytes);
		input.set_bigEndian(true);
		var descriptions = [];
		var _g = 0;
		var _g1 = maxp.numGlyphs;
		while(_g < _g1) {
			var i = _g++;
			descriptions.push(this.readGlyf(i,input,loca.offsets[i + 1] - loca.offsets[i]));
		}
		return descriptions;
	}
	,readGlyf: function(glyphIndex,input,len) {
		if(len > 0) {
			var numberOfContours = input.readInt16();
			var glyphHeader = { numberOfContours : numberOfContours, xMin : input.readInt16(), yMin : input.readInt16(), xMax : input.readInt16(), yMax : input.readInt16()};
			len -= 10;
			if(numberOfContours >= 0) {
				return format_ttf_GlyfDescription.TGlyphSimple(glyphHeader,this.readGlyfSimple(numberOfContours,input,len));
			} else if(numberOfContours == -1) {
				return format_ttf_GlyfDescription.TGlyphComposite(glyphHeader,this.readGlyfComposite(input,len,glyphIndex));
			} else {
				throw new js__$Boot_HaxeError("unknown GlyfDescription");
			}
		} else {
			return format_ttf_GlyfDescription.TGlyphNull;
		}
	}
	,readGlyfSimple: function(numberOfContours,input,len) {
		var endPtsOfContours = [];
		var _g = 0;
		var _g1 = numberOfContours;
		while(_g < _g1) {
			var i = _g++;
			endPtsOfContours[i] = input.readUInt16();
			len -= 2;
		}
		var count = endPtsOfContours[numberOfContours - 1] + 1;
		var instructionLength = input.readUInt16();
		len -= 2;
		var instructions = [];
		var _g2 = 0;
		var _g3 = instructionLength;
		while(_g2 < _g3) {
			var i1 = _g2++;
			instructions[i1] = input.readByte();
			--len;
		}
		var flags = [];
		var iindex = 0;
		var jindex = 1;
		while(true) if(iindex < count) {
			flags[iindex] = input.readByte();
			--len;
			if((flags[iindex] & 8) != 0) {
				var repeats = input.readByte();
				--len;
				jindex = 1;
				while(true) if(jindex < repeats + 1) {
					flags[iindex + jindex] = flags[iindex];
					++jindex;
				} else {
					break;
				}
				iindex += repeats;
			}
			++iindex;
		} else {
			break;
		}
		var xCoordinates = [];
		var yCoordinates = [];
		var x = 0;
		var y = 0;
		var _g4 = 0;
		var _g5 = count;
		while(_g4 < _g5) {
			var i2 = _g4++;
			if((flags[i2] & 16) != 0) {
				if((flags[i2] & 2) != 0) {
					x += input.readByte();
					--len;
				}
			} else if((flags[i2] & 2) != 0) {
				x += -input.readByte();
				--len;
			} else {
				x += input.readInt16();
				len -= 2;
			}
			xCoordinates[i2] = x;
		}
		var _g6 = 0;
		var _g7 = count;
		while(_g6 < _g7) {
			var i3 = _g6++;
			if((flags[i3] & 32) != 0) {
				if((flags[i3] & 4) != 0) {
					y += input.readByte();
					--len;
				}
			} else if((flags[i3] & 4) != 0) {
				y += -input.readByte();
				--len;
			} else {
				y += input.readInt16();
				len -= 2;
			}
			yCoordinates[i3] = y;
		}
		var glyphSimple = { endPtsOfContours : endPtsOfContours, flags : flags, instructions : instructions, xCoordinates : xCoordinates, yCoordinates : yCoordinates};
		input.read(len);
		return glyphSimple;
	}
	,readGlyfComposite: function(input,len,glyphIndex) {
		var components = [];
		input.read(len);
		return components;
	}
	,readCmapTable: function(bytes) {
		if(bytes == null) {
			throw new js__$Boot_HaxeError("no cmap table found");
		}
		var input = new haxe_io_BytesInput(bytes);
		input.set_bigEndian(true);
		var version = input.readUInt16();
		var numberSubtables = input.readUInt16();
		var directory = [];
		var _g = 0;
		var _g1 = numberSubtables;
		while(_g < _g1) {
			var i = _g++;
			directory.push({ platformId : input.readUInt16(), platformSpecificId : input.readUInt16(), offset : input.readInt32()});
		}
		var subTables = [];
		var _g2 = 0;
		var _g3 = numberSubtables;
		while(_g2 < _g3) {
			var i1 = _g2++;
			subTables.push(this.readSubTable(bytes,directory[i1]));
		}
		return subTables;
	}
	,readSubTable: function(bytes,entry) {
		var input = new haxe_io_BytesInput(bytes);
		input.set_bigEndian(true);
		input.read(entry.offset);
		var cmapFormat = input.readUInt16();
		var length = input.readUInt16();
		var language = input.readUInt16();
		var cmapHeader = { platformId : entry.platformId, platformSpecificId : entry.platformSpecificId, offset : entry.offset, format : cmapFormat, language : language};
		this.glyphIndexArray = [];
		this.allGlyphs = [];
		if(cmapFormat == 0) {
			var _g = 0;
			while(_g < 256) {
				var j = _g++;
				this.glyphIndexArray[j] = { charCode : j, index : input.readByte(), char : format_ttf_MacGlyphNames.names[j]};
			}
			return format_ttf_CmapSubTable.Cmap0(cmapHeader,this.glyphIndexArray);
		} else if(cmapFormat == 4) {
			var segCount = input.readUInt16() / 2;
			var searchRange = input.readUInt16();
			var entrySelector = input.readUInt16();
			var rangeShift = input.readUInt16();
			var endCodes = [];
			var startCodes = [];
			var idDeltas = [];
			var idRangeOffsets = [];
			var glyphIndices = [];
			var _g1 = 0;
			var _g11 = segCount;
			while(_g1 < _g11) {
				var i = _g1++;
				endCodes.push(input.readUInt16());
			}
			input.readUInt16();
			var _g2 = 0;
			var _g3 = segCount;
			while(_g2 < _g3) {
				var i1 = _g2++;
				startCodes.push(input.readUInt16());
			}
			var _g4 = 0;
			var _g5 = segCount;
			while(_g4 < _g5) {
				var i2 = _g4++;
				idDeltas.push(input.readUInt16());
			}
			var _g6 = 0;
			var _g7 = segCount;
			while(_g6 < _g7) {
				var i3 = _g6++;
				idRangeOffsets.push(input.readUInt16());
			}
			var count = (length - (8 * segCount + 16)) / 2 | 0;
			var _g8 = 0;
			var _g9 = count;
			while(_g8 < _g9) {
				var i4 = _g8++;
				glyphIndices[i4] = input.readUInt16();
			}
			this.glyphIndexArray[0] = { charCode : 0, index : 0, char : String.fromCodePoint(0)};
			this.glyphIndexArray[1] = { charCode : 1, index : 1, char : "\x01"};
			this.glyphIndexArray[2] = { charCode : 2, index : 2, char : "\x02"};
			this.allGlyphs.concat(this.glyphIndexArray);
			var _g10 = 0;
			var _g111 = segCount;
			while(_g10 < _g111) {
				var i5 = _g10++;
				var _g101 = startCodes[i5];
				var _g112 = endCodes[i5] + 1;
				while(_g101 < _g112) {
					var j1 = _g101++;
					var index = this.mapCharCode(j1,glyphIndices,segCount,startCodes,endCodes,idRangeOffsets,idDeltas);
					var glyphIndex = { charCode : j1, index : index, char : String.fromCodePoint(j1)};
					this.glyphIndexArray[j1] = glyphIndex;
					this.allGlyphs.push(glyphIndex);
				}
			}
			return format_ttf_CmapSubTable.Cmap4(cmapHeader,this.glyphIndexArray);
		} else if(cmapFormat == 6) {
			var firstCode = input.readUInt16();
			var entryCount = input.readUInt16();
			var _g12 = 0;
			var _g13 = entryCount;
			while(_g12 < _g13) {
				var j2 = _g12++;
				var glyphIndex1 = { charCode : j2, index : input.readUInt16(), char : format_ttf_MacGlyphNames.names[j2]};
				this.glyphIndexArray[j2] = glyphIndex1;
			}
			return format_ttf_CmapSubTable.Cmap6(cmapHeader,this.glyphIndexArray,firstCode);
		} else {
			return format_ttf_CmapSubTable.CmapUnk(cmapHeader,bytes);
		}
	}
	,mapCharCode: function(charCode,glyphIndices,segCount,startCodes,endCodes,idRangeOffsets,idDeltas) {
		try {
			var _g = 0;
			var _g1 = segCount;
			while(_g < _g1) {
				var i = _g++;
				if(endCodes[i] >= charCode) {
					if(startCodes[i] <= charCode) {
						if(idRangeOffsets[i] > 0) {
							var index = idRangeOffsets[i] / 2 + (charCode - startCodes[i]) - (segCount - i) | 0;
							return glyphIndices[index];
						} else {
							var index1 = (idDeltas[i] + charCode) % 65536 | 0;
							return index1;
						}
					} else {
						break;
					}
				}
			}
			return 0;
		} catch( e ) {
			var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
			return 0;
		}
	}
	,getCharCodeFromIndex: function(index) {
		var _g = 0;
		var _g1 = this.glyphIndexArray.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.glyphIndexArray[i] != null && this.glyphIndexArray[i].index == index) {
				return this.glyphIndexArray[i].charCode;
			}
		}
		throw new js__$Boot_HaxeError("charcode not found for index " + index);
	}
	,readKernTable: function(bytes) {
		if(bytes == null) {
			return [];
		}
		var input = new haxe_io_BytesInput(bytes);
		input.set_bigEndian(true);
		var version = input.readUInt16();
		var nTables = input.readUInt16();
		var tables = [];
		var _g = 0;
		var _g1 = nTables;
		while(_g < _g1) {
			var i = _g++;
			var version1 = input.readUInt16();
			var length = input.readUInt16();
			var coverage = input.readUInt16();
			var _format = coverage >> 8;
			switch(_format) {
			case 0:
				var nPairs = input.readUInt16();
				var searchRange = input.readUInt16();
				var entrySelector = input.readUInt16();
				var rangeShift = input.readUInt16();
				this.kerningPairs = [];
				var _g2 = 0;
				var _g11 = nPairs;
				while(_g2 < _g11) {
					var i1 = _g2++;
					this.kerningPairs.push({ left : this.getCharCodeFromIndex(input.readUInt16()), right : this.getCharCodeFromIndex(input.readUInt16()), value : input.readInt16()});
				}
				tables.push(format_ttf_KernSubTable.KernSub0(this.kerningPairs));
				break;
			case 2:
				var rowWidth = input.readUInt16();
				var leftOffsetTable = input.readUInt16();
				var rightOffsetTable = input.readUInt16();
				var array = input.readUInt16();
				var firstGlyph = input.readUInt16();
				var nGlyphs = input.readUInt16();
				var offsets = [];
				var _g3 = 0;
				var _g12 = nGlyphs;
				while(_g3 < _g12) {
					var i2 = _g3++;
					offsets.push(input.readUInt16());
				}
				tables.push(format_ttf_KernSubTable.KernSub1(offsets));
				break;
			}
		}
		return tables;
	}
	,readPostTable: function(bytes) {
		var input = new haxe_io_BytesInput(bytes);
		input.set_bigEndian(true);
		var postData = { version : input.readInt32(), italicAngle : input.readInt32(), underlinePosition : input.readInt16(), underlineThickness : input.readInt16(), isFixedPitch : input.readInt32(), minMemType42 : input.readInt32(), maxMemType42 : input.readInt32(), minMemType1 : input.readInt32(), maxMemType1 : input.readInt32(), numGlyphs : 0, glyphNameIndex : [], psGlyphName : []};
		if(postData.version == 131072) {
			postData.numGlyphs = input.readUInt16();
			var _g = 0;
			var _g1 = postData.numGlyphs;
			while(_g < _g1) {
				var i = _g++;
				postData.glyphNameIndex[i] = input.readUInt16();
			}
			var high = 0;
			var _g2 = 0;
			var _g3 = postData.numGlyphs;
			while(_g2 < _g3) {
				var i1 = _g2++;
				if(high < postData.glyphNameIndex[i1]) {
					high = postData.glyphNameIndex[i1];
				}
			}
			if(high > 257) {
				high -= 257;
				var _g4 = 0;
				var _g5 = high;
				while(_g4 < _g5) {
					var i2 = _g4++;
					postData.psGlyphName[i2] = input.readString(input.readByte());
				}
			}
		}
		return postData;
	}
	,readNameTable: function(bytes) {
		var input = new haxe_io_BytesInput(bytes);
		input.set_bigEndian(true);
		var _format = input.readUInt16();
		var count = input.readUInt16();
		var stringOffset = input.readUInt16();
		var nameRecords = [];
		var _g = 0;
		var _g1 = count;
		while(_g < _g1) {
			var i = _g++;
			nameRecords.push({ platformId : input.readUInt16(), platformSpecificId : input.readUInt16(), languageID : input.readUInt16(), nameID : input.readUInt16(), length : input.readUInt16(), offset : input.readUInt16(), record : ""});
		}
		nameRecords.sort($bind(this,this.sortOnOffset16));
		var fontNameRecord = null;
		var _g2 = 0;
		var _g3 = count;
		while(_g2 < _g3) {
			var i1 = _g2++;
			if(nameRecords[i1].nameID == 4 && (nameRecords[i1].platformId == 3 || nameRecords[i1].platformId == 0)) {
				fontNameRecord = nameRecords[i1];
				break;
			}
		}
		if(fontNameRecord == null) {
			throw new js__$Boot_HaxeError("fontNameRecord not found");
		} else {
			input.read(fontNameRecord.offset);
			var _g4 = 0;
			var _g5 = fontNameRecord.length / 2 | 0;
			while(_g4 < _g5) {
				var i2 = _g4++;
				var fontNameRecord1 = fontNameRecord;
				var fontNameRecord2 = fontNameRecord1.record;
				var code = input.readUInt16();
				fontNameRecord1.record = fontNameRecord2 + String.fromCodePoint(code);
			}
		}
		this.fontName = fontNameRecord.record;
		return nameRecords;
	}
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
var haxe_Resource = function() { };
haxe_Resource.__name__ = true;
haxe_Resource.getBytes = function(name) {
	var _g = 0;
	var _g1 = haxe_Resource.content;
	while(_g < _g1.length) {
		var x = _g1[_g];
		++_g;
		if(x.name == name) {
			if(x.str != null) {
				return haxe_io_Bytes.ofString(x.str);
			}
			return haxe_crypto_Base64.decode(x.data);
		}
	}
	return null;
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i1 = 0;
	while(i1 < s.length) {
		var c1 = s.charCodeAt(i1++);
		if(55296 <= c1 && c1 <= 56319) {
			c1 = c1 - 55232 << 10 | s.charCodeAt(i1++) & 1023;
		}
		if(c1 <= 127) {
			a.push(c1);
		} else if(c1 <= 2047) {
			a.push(192 | c1 >> 6);
			a.push(128 | c1 & 63);
		} else if(c1 <= 65535) {
			a.push(224 | c1 >> 12);
			a.push(128 | c1 >> 6 & 63);
			a.push(128 | c1 & 63);
		} else {
			a.push(240 | c1 >> 18);
			a.push(128 | c1 >> 12 & 63);
			a.push(128 | c1 >> 6 & 63);
			a.push(128 | c1 & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.prototype = {
	getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		var s = "";
		var b = this.b;
		var i = pos;
		var max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			var debug = pos > 0;
			while(i < max) {
				var c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					var code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					var c2 = b[i++];
					var code1 = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code1);
				} else {
					var c21 = b[i++];
					var c3 = b[i++];
					var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				var c1 = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c1);
			}
			break;
		}
		return s;
	}
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__ : "haxe.io.Encoding", __constructs__ : ["UTF8","RawNative"]
	,UTF8: {_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
var haxe_crypto_Base64 = function() { };
haxe_crypto_Base64.__name__ = true;
haxe_crypto_Base64.decode = function(str,complement) {
	if(complement == null) {
		complement = true;
	}
	if(complement) {
		while(HxOverrides.cca(str,str.length - 1) == 61) str = HxOverrides.substr(str,0,-1);
	}
	return new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).decodeBytes(haxe_io_Bytes.ofString(str));
};
var haxe_crypto_BaseCode = function(base) {
	var len = base.length;
	var nbits = 1;
	while(len > 1 << nbits) ++nbits;
	if(nbits > 8 || len != 1 << nbits) {
		throw new js__$Boot_HaxeError("BaseCode : base length must be a power of two.");
	}
	this.base = base;
	this.nbits = nbits;
};
haxe_crypto_BaseCode.__name__ = true;
haxe_crypto_BaseCode.prototype = {
	initTable: function() {
		var tbl = [];
		var _g = 0;
		while(_g < 256) {
			var i = _g++;
			tbl[i] = -1;
		}
		var _g1 = 0;
		var _g2 = this.base.length;
		while(_g1 < _g2) {
			var i1 = _g1++;
			tbl[this.base.b[i1]] = i1;
		}
		this.tbl = tbl;
	}
	,decodeBytes: function(b) {
		var nbits = this.nbits;
		var base = this.base;
		if(this.tbl == null) {
			this.initTable();
		}
		var tbl = this.tbl;
		var size = b.length * nbits >> 3;
		var out = new haxe_io_Bytes(new ArrayBuffer(size));
		var buf = 0;
		var curbits = 0;
		var pin = 0;
		var pout = 0;
		while(pout < size) {
			while(curbits < 8) {
				curbits += nbits;
				buf <<= nbits;
				var i = tbl[b.b[pin++]];
				if(i == -1) {
					throw new js__$Boot_HaxeError("BaseCode : invalid encoded char");
				}
				buf |= i;
			}
			curbits -= 8;
			out.b[pout++] = buf >> curbits & 255;
		}
		return out;
	}
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
};
var haxe_io_BytesBuffer = function() {
	this.pos = 0;
	this.size = 0;
};
haxe_io_BytesBuffer.__name__ = true;
haxe_io_BytesBuffer.prototype = {
	addByte: function(byte) {
		if(this.pos == this.size) {
			this.grow(1);
		}
		this.view.setUint8(this.pos++,byte);
	}
	,grow: function(delta) {
		var req = this.pos + delta;
		var nsize = this.size == 0 ? 16 : this.size;
		while(nsize < req) nsize = nsize * 3 >> 1;
		var nbuf = new ArrayBuffer(nsize);
		var nu8 = new Uint8Array(nbuf);
		if(this.size > 0) {
			nu8.set(this.u8);
		}
		this.size = nsize;
		this.buffer = nbuf;
		this.u8 = nu8;
		this.view = new DataView(this.buffer);
	}
	,getBytes: function() {
		if(this.size == 0) {
			return new haxe_io_Bytes(new ArrayBuffer(0));
		}
		var b = new haxe_io_Bytes(this.buffer);
		b.length = this.pos;
		return b;
	}
};
var haxe_io_Input = function() { };
haxe_io_Input.__name__ = true;
haxe_io_Input.prototype = {
	readByte: function() {
		throw new js__$Boot_HaxeError("Not implemented");
	}
	,readBytes: function(s,pos,len) {
		var k = len;
		var b = s.b;
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		try {
			while(k > 0) {
				b[pos] = this.readByte();
				++pos;
				--k;
			}
		} catch( eof ) {
			var eof1 = ((eof) instanceof js__$Boot_HaxeError) ? eof.val : eof;
			if(((eof1) instanceof haxe_io_Eof)) {
				var eof2 = eof1;
			} else {
				throw eof;
			}
		}
		return len - k;
	}
	,set_bigEndian: function(b) {
		this.bigEndian = b;
		return b;
	}
	,readFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.readBytes(s,pos,len);
			if(k == 0) {
				throw new js__$Boot_HaxeError(haxe_io_Error.Blocked);
			}
			pos += k;
			len -= k;
		}
	}
	,read: function(nbytes) {
		var s = new haxe_io_Bytes(new ArrayBuffer(nbytes));
		var p = 0;
		while(nbytes > 0) {
			var k = this.readBytes(s,p,nbytes);
			if(k == 0) {
				throw new js__$Boot_HaxeError(haxe_io_Error.Blocked);
			}
			p += k;
			nbytes -= k;
		}
		return s;
	}
	,readDouble: function() {
		var i1 = this.readInt32();
		var i2 = this.readInt32();
		if(this.bigEndian) {
			return haxe_io_FPHelper.i64ToDouble(i2,i1);
		} else {
			return haxe_io_FPHelper.i64ToDouble(i1,i2);
		}
	}
	,readInt16: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var n = this.bigEndian ? ch2 | ch1 << 8 : ch1 | ch2 << 8;
		if((n & 32768) != 0) {
			return n - 65536;
		}
		return n;
	}
	,readUInt16: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		if(this.bigEndian) {
			return ch2 | ch1 << 8;
		} else {
			return ch1 | ch2 << 8;
		}
	}
	,readInt32: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var ch3 = this.readByte();
		var ch4 = this.readByte();
		if(this.bigEndian) {
			return ch4 | ch3 << 8 | ch2 << 16 | ch1 << 24;
		} else {
			return ch1 | ch2 << 8 | ch3 << 16 | ch4 << 24;
		}
	}
	,readString: function(len,encoding) {
		var b = new haxe_io_Bytes(new ArrayBuffer(len));
		this.readFullBytes(b,0,len);
		return b.getString(0,len,encoding);
	}
};
var haxe_io_BytesInput = function(b,pos,len) {
	if(pos == null) {
		pos = 0;
	}
	if(len == null) {
		len = b.length - pos;
	}
	if(pos < 0 || len < 0 || pos + len > b.length) {
		throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
	}
	this.b = b.b;
	this.pos = pos;
	this.len = len;
	this.totlen = len;
};
haxe_io_BytesInput.__name__ = true;
haxe_io_BytesInput.__super__ = haxe_io_Input;
haxe_io_BytesInput.prototype = $extend(haxe_io_Input.prototype,{
	readByte: function() {
		if(this.len == 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		this.len--;
		return this.b[this.pos++];
	}
	,readBytes: function(buf,pos,len) {
		if(pos < 0 || len < 0 || pos + len > buf.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(this.len == 0 && len > 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		if(this.len < len) {
			len = this.len;
		}
		var b1 = this.b;
		var b2 = buf.b;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			b2[pos + i] = b1[this.pos + i];
		}
		this.pos += len;
		this.len -= len;
		return len;
	}
});
var haxe_io_Output = function() { };
haxe_io_Output.__name__ = true;
haxe_io_Output.prototype = {
	writeByte: function(c) {
		throw new js__$Boot_HaxeError("Not implemented");
	}
	,set_bigEndian: function(b) {
		this.bigEndian = b;
		return b;
	}
	,writeInt32: function(x) {
		if(this.bigEndian) {
			this.writeByte(x >>> 24);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >>> 24);
		}
	}
};
var haxe_io_BytesOutput = function() {
	this.b = new haxe_io_BytesBuffer();
};
haxe_io_BytesOutput.__name__ = true;
haxe_io_BytesOutput.__super__ = haxe_io_Output;
haxe_io_BytesOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		this.b.addByte(c);
	}
	,getBytes: function() {
		return this.b.getBytes();
	}
});
var haxe_io_Eof = function() {
};
haxe_io_Eof.__name__ = true;
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : "haxe.io.Error", __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
var haxe_io_FPHelper = function() { };
haxe_io_FPHelper.__name__ = true;
haxe_io_FPHelper.i64ToDouble = function(low,high) {
	haxe_io_FPHelper.helper.setInt32(0,low,true);
	haxe_io_FPHelper.helper.setInt32(4,high,true);
	return haxe_io_FPHelper.helper.getFloat64(0,true);
};
var htmlHelper_canvas__$CanvasWrapper_CanvasWrapper_$Impl_$ = {};
htmlHelper_canvas__$CanvasWrapper_CanvasWrapper_$Impl_$.__name__ = true;
htmlHelper_canvas__$CanvasWrapper_CanvasWrapper_$Impl_$._new = function(e) {
	var this1;
	if(e == null) {
		var canvas = window.document.createElement("canvas");
		var dom = canvas;
		var style = dom.style;
		style.paddingLeft = "0px";
		style.paddingTop = "0px";
		style.left = "0px";
		style.top = "0px";
		style.position = "absolute";
		this1 = canvas;
	} else {
		this1 = e;
	}
	return this1;
};
htmlHelper_canvas__$CanvasWrapper_CanvasWrapper_$Impl_$.create = function() {
	var canvas = window.document.createElement("canvas");
	var dom = canvas;
	var style = dom.style;
	style.paddingLeft = "0px";
	style.paddingTop = "0px";
	style.left = "0px";
	style.top = "0px";
	style.position = "absolute";
	return canvas;
};
htmlHelper_canvas__$CanvasWrapper_CanvasWrapper_$Impl_$.set_x = function(this1,x_) {
	this1.style.left = (x_ == null ? "null" : "" + x_) + "px";
	return x_;
};
htmlHelper_canvas__$CanvasWrapper_CanvasWrapper_$Impl_$.get_x = function(this1) {
	var style = this1.style;
	var len = style.left.length;
	return Std.parseInt(style.left.substr(0,len - 2));
};
htmlHelper_canvas__$CanvasWrapper_CanvasWrapper_$Impl_$.set_y = function(this1,y_) {
	this1.style.left = (y_ == null ? "null" : "" + y_) + "px";
	return y_;
};
htmlHelper_canvas__$CanvasWrapper_CanvasWrapper_$Impl_$.get_y = function(this1) {
	var style = this1.style;
	var len = style.top.length;
	return Std.parseInt(style.top.substr(0,len - 2));
};
var htmlHelper_tools_AnimateTimer = function() { };
htmlHelper_tools_AnimateTimer.__name__ = true;
htmlHelper_tools_AnimateTimer.create = function() {
	if(htmlHelper_tools_AnimateTimer.s != null) {
		return;
	}
	htmlHelper_tools_AnimateTimer.s = window.document.createElement("style");
	htmlHelper_tools_AnimateTimer.s.innerHTML = "@keyframes spin { from { transform:rotate( 0deg ); } to { transform:rotate( 360deg ); } }";
	window.document.getElementsByTagName("head")[0].appendChild(htmlHelper_tools_AnimateTimer.s);
	htmlHelper_tools_AnimateTimer.s.animation = "spin 1s linear infinite";
	htmlHelper_tools_AnimateTimer.loop(60.0);
};
htmlHelper_tools_AnimateTimer.loop = function(tim) {
	window.requestAnimationFrame(htmlHelper_tools_AnimateTimer.loop);
	if(htmlHelper_tools_AnimateTimer.onFrame != null) {
		htmlHelper_tools_AnimateTimer.onFrame(htmlHelper_tools_AnimateTimer.counter);
	}
	htmlHelper_tools_AnimateTimer.counter++;
	return true;
};
htmlHelper_tools_AnimateTimer.kill = function() {
	if(htmlHelper_tools_AnimateTimer.s == null) {
		return;
	}
	window.document.getElementsByTagName("head")[0].removeChild(htmlHelper_tools_AnimateTimer.s);
	htmlHelper_tools_AnimateTimer.onFrame = null;
	htmlHelper_tools_AnimateTimer.s = null;
};
htmlHelper_tools_AnimateTimer.tween = function(t,b,e,d,f) {
	if(t > d) {
		return null;
	}
	return f(t,b,e - b,d);
};
var hxGeomAlgo_Debug = function() { };
hxGeomAlgo_Debug.__name__ = true;
hxGeomAlgo_Debug.assert = function(cond,message,pos) {
	if(!cond) {
		throw new js__$Boot_HaxeError(pos.fileName + ":" + pos.lineNumber + ": ASSERT FAILED! " + (message != null ? message : ""));
	}
};
var hxGeomAlgo_HomogCoord = function(x,y,w) {
	if(w == null) {
		w = 1;
	}
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
	this.w = w;
};
hxGeomAlgo_HomogCoord.__name__ = true;
hxGeomAlgo_HomogCoord.det = function(p,q,r) {
	return p.w * q.perpdot(r) - q.w * p.perpdot(r) + r.w * p.perpdot(q);
};
hxGeomAlgo_HomogCoord.ccw = function(p,q,r) {
	return hxGeomAlgo_HomogCoord.det(p,q,r) > 0;
};
hxGeomAlgo_HomogCoord.cw = function(p,q,r) {
	return hxGeomAlgo_HomogCoord.det(p,q,r) < 0;
};
hxGeomAlgo_HomogCoord.prototype = {
	add: function(p) {
		this.x += p.x;
		this.y += p.y;
		return this;
	}
	,sub: function(p) {
		this.x -= p.x;
		this.y -= p.y;
		return this;
	}
	,neg: function() {
		this.w = -this.w;
		this.x = -this.x;
		this.y = -this.y;
		return this;
	}
	,mul: function(m) {
		this.w *= m;
		this.x *= m;
		this.y *= m;
		return this;
	}
	,div: function(m) {
		this.w /= m;
		this.x /= m;
		this.y /= m;
		return this;
	}
	,normalize: function() {
		return this.div(this.length());
	}
	,lengthSquared: function() {
		return this.x * this.x + this.y * this.y;
	}
	,length: function() {
		return Math.sqrt(this.lengthSquared());
	}
	,perp: function() {
		var tmp = -this.y;
		this.y = this.x;
		this.x = tmp;
		return this;
	}
	,dotPoint: function(p) {
		return this.w + this.x * p.x + this.y * p.y;
	}
	,dot: function(p) {
		return this.w * p.w + this.x * p.x + this.y * p.y;
	}
	,perpdot: function(p) {
		return this.x * p.y - this.y * p.x;
	}
	,dotperp: function(p) {
		return -this.x * p.y + this.y * p.x;
	}
	,equals: function(p) {
		if(p.w * this.x == this.w * p.x) {
			return p.w * this.y == this.w * p.y;
		} else {
			return false;
		}
	}
	,left: function(p) {
		return this.dotPoint(p) > 0;
	}
	,right: function(p) {
		return this.dotPoint(p) < 0;
	}
	,toScreen: function() {
		return hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(this.x / this.w,-this.y / this.w);
	}
	,toPoint: function() {
		return hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(this.x / this.w,this.y / this.w);
	}
	,meet: function(p) {
		return new hxGeomAlgo_HomogCoord(p.w * this.y - this.w * p.y,this.w * p.x - p.w * this.x,this.x * p.y - this.y * p.x);
	}
	,meetPoint: function(p) {
		return new hxGeomAlgo_HomogCoord(this.y - this.w * p.y,this.w * p.x - this.x,this.x * p.y - this.y * p.x);
	}
	,toString: function() {
		return " (w:" + this.w + "; x:" + this.x + ", y:" + this.y + ")  ";
	}
};
var hxGeomAlgo_HxPointData = function(x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
};
hxGeomAlgo_HxPointData.__name__ = true;
hxGeomAlgo_HxPointData.prototype = {
	toString: function() {
		return "(" + this.x + ", " + this.y + ")";
	}
};
var hxGeomAlgo__$HxPoint_HxPoint_$Impl_$ = $hx_exports["hxGeomAlgo"]["_HxPoint"]["HxPoint_Impl_"] = {};
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.__name__ = true;
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.get_x = function(this1) {
	return this1.x;
};
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.set_x = function(this1,value) {
	return this1.x = value;
};
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.get_y = function(this1) {
	return this1.y;
};
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.set_y = function(this1,value) {
	return this1.y = value;
};
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new = function(x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	var this1 = new hxGeomAlgo_HxPointData(x,y);
	return this1;
};
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.setTo = function(this1,newX,newY) {
	this1.x = newX;
	this1.y = newY;
};
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.equals = function(this1,p) {
	if(p != null && this1.x == p.x) {
		return this1.y == p.y;
	} else {
		return false;
	}
};
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.clone = function(this1) {
	return hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(this1.x,this1.y);
};
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.toString = function(this1) {
	return "(" + this1.x + ", " + this1.y + ")";
};
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.fromPointStruct = function(p) {
	return hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(p.x,p.y);
};
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.toPointStruct = function(this1) {
	return { x : this1.x, y : this1.y};
};
var hxGeomAlgo_PolyTools = $hx_exports["hxGeomAlgo"]["PolyTools"] = function() { };
hxGeomAlgo_PolyTools.__name__ = true;
hxGeomAlgo_PolyTools.isCCW = function(poly) {
	if(poly.length <= 2) {
		return true;
	}
	var signedArea = 0.;
	var _g = 0;
	var _g1 = poly.length;
	while(_g < _g1) {
		var i = _g++;
		var idx = i - 1;
		var idx1 = idx;
		var len = poly.length;
		if(idx1 < 0) {
			idx1 += len;
		}
		idx = idx1 % len;
		var idx2 = i - 1;
		var idx3 = idx2;
		var len1 = poly.length;
		if(idx3 < 0) {
			idx3 += len1;
		}
		idx2 = idx3 % len1;
		signedArea += poly[idx].x * poly[i].y - poly[i].x * poly[idx2].y;
	}
	return signedArea < 0;
};
hxGeomAlgo_PolyTools.isCW = function(poly) {
	if(poly.length <= 2) {
		return true;
	}
	var signedArea = 0.;
	var _g = 0;
	var _g1 = poly.length;
	while(_g < _g1) {
		var i = _g++;
		var idx = i - 1;
		var idx1 = idx;
		var len = poly.length;
		if(idx1 < 0) {
			idx1 += len;
		}
		idx = idx1 % len;
		var idx2 = i - 1;
		var idx3 = idx2;
		var len1 = poly.length;
		if(idx3 < 0) {
			idx3 += len1;
		}
		idx2 = idx3 % len1;
		signedArea += poly[idx].x * poly[i].y - poly[i].x * poly[idx2].y;
	}
	return signedArea > 0;
};
hxGeomAlgo_PolyTools.makeCCW = function(poly) {
	var reversed = false;
	if(!hxGeomAlgo_PolyTools.isCCW(poly)) {
		poly.reverse();
		reversed = true;
	}
	return reversed;
};
hxGeomAlgo_PolyTools.makeCW = function(poly) {
	var reversed = false;
	if(hxGeomAlgo_PolyTools.isCCW(poly)) {
		poly.reverse();
		reversed = true;
	}
	return reversed;
};
hxGeomAlgo_PolyTools.isConvex = function(poly) {
	var isPositive = null;
	var _g = 0;
	var _g1 = poly.length;
	while(_g < _g1) {
		var i = _g++;
		var lower = i == 0 ? poly.length - 1 : i - 1;
		var middle = i;
		var upper = i == poly.length - 1 ? 0 : i + 1;
		var dx0 = poly[middle].x - poly[lower].x;
		var dy0 = poly[middle].y - poly[lower].y;
		var dx1 = poly[upper].x - poly[middle].x;
		var dy1 = poly[upper].y - poly[middle].y;
		var cross = dx0 * dy1 - dx1 * dy0;
		var newIsPositive = cross > 0;
		if(cross == 0) {
			continue;
		}
		if(isPositive == null) {
			isPositive = newIsPositive;
		} else if(isPositive != newIsPositive) {
			return false;
		}
	}
	return true;
};
hxGeomAlgo_PolyTools.isSimple = function(poly) {
	var len = poly.length;
	if(len <= 3) {
		return true;
	}
	var _g = 0;
	var _g1 = len;
	while(_g < _g1) {
		var i = _g++;
		var p0 = i;
		var p1 = i == len - 1 ? 0 : i + 1;
		var _g2 = i + 1;
		var _g11 = len;
		while(_g2 < _g11) {
			var j = _g2++;
			var q0 = j;
			var q1 = j == len - 1 ? 0 : j + 1;
			var intersection = hxGeomAlgo_PolyTools.segmentIntersect(poly[p0],poly[p1],poly[q0],poly[q1]);
			var tmp;
			var tmp1;
			if(intersection != null) {
				var tmp2;
				var w = poly[p0];
				var x = intersection.x - w.x;
				var x1 = intersection.y - w.y;
				if(!(Math.sqrt(x * x + x1 * x1) < hxGeomAlgo_PolyTools.EPSILON)) {
					var w1 = poly[p1];
					var x2 = intersection.x - w1.x;
					var x3 = intersection.y - w1.y;
					tmp2 = Math.sqrt(x2 * x2 + x3 * x3) < hxGeomAlgo_PolyTools.EPSILON;
				} else {
					tmp2 = true;
				}
				tmp1 = !tmp2;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				var tmp3;
				var w2 = poly[q0];
				var x4 = intersection.x - w2.x;
				var x5 = intersection.y - w2.y;
				if(!(Math.sqrt(x4 * x4 + x5 * x5) < hxGeomAlgo_PolyTools.EPSILON)) {
					var w3 = poly[q1];
					var x6 = intersection.x - w3.x;
					var x7 = intersection.y - w3.y;
					tmp3 = Math.sqrt(x6 * x6 + x7 * x7) < hxGeomAlgo_PolyTools.EPSILON;
				} else {
					tmp3 = true;
				}
				tmp = !tmp3;
			} else {
				tmp = false;
			}
			if(tmp) {
				return false;
			}
		}
	}
	return true;
};
hxGeomAlgo_PolyTools.segmentIntersect = function(p0,p1,q0,q1) {
	var a1 = p1.y - p0.y;
	var b1 = p0.x - p1.x;
	var c1 = p1.x * p0.y - p0.x * p1.y;
	var a2 = q1.y - q0.y;
	var b2 = q0.x - q1.x;
	var c2 = q1.x * q0.y - q0.x * q1.y;
	var denom = a1 * b2 - a2 * b1;
	if(denom == 0) {
		return null;
	}
	var intersectionPoint = hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new();
	intersectionPoint.x = (b1 * c2 - b2 * c1) / denom;
	intersectionPoint.y = (a2 * c1 - a1 * c2) / denom;
	var x = p0.x - p1.x;
	var x1 = p0.y - p1.y;
	var p0p1 = x * x + x1 * x1;
	var x2 = q0.x - q1.x;
	var x3 = q0.y - q1.y;
	var q0q1 = x2 * x2 + x3 * x3;
	var x4 = intersectionPoint.x - p1.x;
	var x5 = intersectionPoint.y - p1.y;
	if(x4 * x4 + x5 * x5 > p0p1) {
		return null;
	}
	var x6 = intersectionPoint.x - p0.x;
	var x7 = intersectionPoint.y - p0.y;
	if(x6 * x6 + x7 * x7 > p0p1) {
		return null;
	}
	var x8 = intersectionPoint.x - q1.x;
	var x9 = intersectionPoint.y - q1.y;
	if(x8 * x8 + x9 * x9 > q0q1) {
		return null;
	}
	var x10 = intersectionPoint.x - q0.x;
	var x11 = intersectionPoint.y - q0.y;
	if(x10 * x10 + x11 * x11 > q0q1) {
		return null;
	}
	return intersectionPoint;
};
hxGeomAlgo_PolyTools.findDuplicatePoints = function(poly,consecutiveOnly,wrapAround) {
	if(wrapAround == null) {
		wrapAround = true;
	}
	if(consecutiveOnly == null) {
		consecutiveOnly = true;
	}
	var len = poly.length;
	if(len <= 1) {
		return [];
	}
	var dupIndices = [];
	var _g = 0;
	var _g1 = len - 1;
	while(_g < _g1) {
		var i = _g++;
		var j = i + 1;
		while(j < len) {
			var this1 = poly[i];
			var p = poly[j];
			var foundDup = p != null && this1.x == p.x && this1.y == p.y;
			if(foundDup) {
				dupIndices.push(i);
			}
			if(consecutiveOnly || foundDup && !consecutiveOnly) {
				break;
			}
			++j;
		}
	}
	var tmp;
	if(wrapAround && consecutiveOnly) {
		var this2 = poly[0];
		var p1 = poly[len - 1];
		tmp = p1 != null && this2.x == p1.x && this2.y == p1.y;
	} else {
		tmp = false;
	}
	if(tmp) {
		dupIndices.push(len - 1);
	}
	return dupIndices;
};
hxGeomAlgo_PolyTools.intersection = function(p1,p2,q1,q2) {
	var res = null;
	var a1 = p2.y - p1.y;
	var b1 = p1.x - p2.x;
	var c1 = a1 * p1.x + b1 * p1.y;
	var a2 = q2.y - q1.y;
	var b2 = q1.x - q2.x;
	var c2 = a2 * q1.x + b2 * q1.y;
	var det = a1 * b2 - a2 * b1;
	if(!(Math.abs(det) <= hxGeomAlgo_PolyTools.EPSILON)) {
		res = hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new();
		res.x = (b2 * c1 - b1 * c2) / det;
		res.y = (a1 * c2 - a2 * c1) / det;
	}
	return res;
};
hxGeomAlgo_PolyTools.isReflex = function(poly,idx) {
	var idx1 = idx - 1;
	var idx2 = idx1;
	var len = poly.length;
	if(idx2 < 0) {
		idx2 += len;
	}
	idx1 = idx2 % len;
	var p = poly[idx1];
	var idx3 = idx;
	var idx4 = idx3;
	var len1 = poly.length;
	if(idx4 < 0) {
		idx4 += len1;
	}
	idx3 = idx4 % len1;
	var a = poly[idx3];
	var idx5 = idx + 1;
	var idx6 = idx5;
	var len2 = poly.length;
	if(idx6 < 0) {
		idx6 += len2;
	}
	idx5 = idx6 % len2;
	var b = poly[idx5];
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) < 0;
};
hxGeomAlgo_PolyTools.at = function(poly,idx) {
	var idx1 = idx;
	var len = poly.length;
	if(idx1 < 0) {
		idx1 += len;
	}
	idx = idx1 % len;
	return poly[idx];
};
hxGeomAlgo_PolyTools.wrappedIdx = function(poly,idx) {
	var len = poly.length;
	if(idx < 0) {
		idx += len;
	}
	return idx % len;
};
hxGeomAlgo_PolyTools.side = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y);
};
hxGeomAlgo_PolyTools.isLeft = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) > 0;
};
hxGeomAlgo_PolyTools.isLeftOrOn = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) >= 0;
};
hxGeomAlgo_PolyTools.isRight = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) < 0;
};
hxGeomAlgo_PolyTools.isRightOrOn = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) <= 0;
};
hxGeomAlgo_PolyTools.isCollinear = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) == 0;
};
hxGeomAlgo_PolyTools.distance = function(v,w) {
	var x = v.x - w.x;
	var x1 = v.y - w.y;
	return Math.sqrt(x * x + x1 * x1);
};
hxGeomAlgo_PolyTools.distanceToSegment = function(p,v,w) {
	return Math.sqrt(hxGeomAlgo_PolyTools.distanceToSegmentSquared(p,v,w));
};
hxGeomAlgo_PolyTools.distanceSquared = function(v,w) {
	var x = v.x - w.x;
	var x1 = v.y - w.y;
	return x * x + x1 * x1;
};
hxGeomAlgo_PolyTools.distanceToSegmentSquared = function(p,v,w) {
	var x = v.x - w.x;
	var x1 = v.y - w.y;
	var l2 = x * x + x1 * x1;
	if(l2 == 0) {
		var x2 = p.x - v.x;
		var x3 = p.y - v.y;
		return x2 * x2 + x3 * x3;
	}
	var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
	if(t < 0) {
		var x4 = p.x - v.x;
		var x5 = p.y - v.y;
		return x4 * x4 + x5 * x5;
	}
	if(t > 1) {
		var x6 = p.x - w.x;
		var x7 = p.y - w.y;
		return x6 * x6 + x7 * x7;
	}
	hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.setTo(hxGeomAlgo_PolyTools.point,v.x + t * (w.x - v.x),v.y + t * (w.y - v.y));
	var w1 = hxGeomAlgo_PolyTools.point;
	var x8 = p.x - w1.x;
	var x9 = p.y - w1.y;
	return x8 * x8 + x9 * x9;
};
hxGeomAlgo_PolyTools.getCentroid = function(poly) {
	var c = hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new();
	var area = hxGeomAlgo_PolyTools.getArea(poly);
	if(area != 0) {
		var len = poly.length;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			var p0 = poly[i];
			var p1 = poly[(i + 1) % len];
			var m = p0.x * p1.y - p1.x * p0.y;
			c.x += (p0.x + p1.x) * m;
			c.y += (p0.y + p1.y) * m;
		}
		c.x /= 6 * area;
		c.y /= 6 * area;
	} else {
		c = hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.EMPTY;
	}
	return c;
};
hxGeomAlgo_PolyTools.getArea = function(poly) {
	var area = 0.0;
	var len = poly.length;
	var _g = 0;
	var _g1 = len;
	while(_g < _g1) {
		var i = _g++;
		var p0 = poly[i];
		var p1 = poly[(i + 1) % len];
		area += p0.x * p1.y - p1.x * p0.y;
	}
	area = .5 * area;
	return area;
};
hxGeomAlgo_PolyTools.meet = function(p,q) {
	return new hxGeomAlgo_HomogCoord(p.y - q.y,q.x - p.x,p.x * q.y - p.y * q.x);
};
hxGeomAlgo_PolyTools.dot = function(p,q) {
	return p.x * q.x + p.y * q.y;
};
hxGeomAlgo_PolyTools.sqr = function(x) {
	return x * x;
};
hxGeomAlgo_PolyTools.eq = function(a,b) {
	return Math.abs(a - b) <= hxGeomAlgo_PolyTools.EPSILON;
};
hxGeomAlgo_PolyTools.clear = function(array) {
	array.length = 0;
};
hxGeomAlgo_PolyTools.toFloatArray = function(poly,out) {
	out = out != null ? out : [];
	var _g = 0;
	while(_g < poly.length) {
		var p = poly[_g];
		++_g;
		out.push(p.x);
		out.push(p.y);
	}
	return out;
};
hxGeomAlgo_PolyTools.reverseFloatArray = function(poly,inPlace) {
	if(inPlace == null) {
		inPlace = false;
	}
	var res = inPlace ? poly : [];
	var nPoints = poly.length >> 1;
	var _g = 0;
	var _g1 = nPoints;
	while(_g < _g1) {
		var i = _g++;
		var xPos = (nPoints - i - 1) * 2;
		res[i * 2] = poly[xPos];
		res[i * 2 + 1] = poly[xPos + 1];
	}
	return res;
};
hxGeomAlgo_PolyTools.flatten = function(array,out) {
	var res = out != null ? out : [];
	var _g = 0;
	while(_g < array.length) {
		var arr = array[_g];
		++_g;
		var _g1 = 0;
		while(_g1 < arr.length) {
			var item = arr[_g1];
			++_g1;
			res.push(item);
		}
	}
	return res;
};
hxGeomAlgo_PolyTools.toPointArray = function(poly,out) {
	out = out != null ? out : [];
	var size = poly.length;
	if(poly.length % 2 == 1) {
		--size;
	}
	var _g = 0;
	var _g1 = size >> 1;
	while(_g < _g1) {
		var i = _g++;
		out.push(hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(poly[i * 2],poly[i * 2 + 1]));
	}
	return out;
};
hxGeomAlgo_PolyTools.inflateLine = function(start,end,thickness) {
	var halfWidth = thickness / 2;
	var dx = end.x - start.x;
	var dy = end.y - start.y;
	var len = Math.sqrt(dx * dx + dy * dy);
	var nx = dx / len * halfWidth;
	var ny = dy / len * halfWidth;
	return [hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(start.x - ny,start.y + nx),hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(end.x - ny,end.y + nx),hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(end.x + ny,end.y - nx),hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(start.x + ny,start.y - nx)];
};
hxGeomAlgo_PolyTools.clip = function(subjPoly,clipPoly) {
	hxGeomAlgo_Debug.assert(clipPoly.length >= 3 && hxGeomAlgo_PolyTools.isConvex(clipPoly),"`clipPoly` must be a valid convex poly",{ fileName : "hxGeomAlgo/PolyTools.hx", lineNumber : 458, className : "hxGeomAlgo.PolyTools", methodName : "clip"});
	var res = [];
	var output = subjPoly;
	var isInside = hxGeomAlgo_PolyTools.isCCW(clipPoly) ? hxGeomAlgo_PolyTools.isRight : hxGeomAlgo_PolyTools.isLeft;
	var clipEdgeStart;
	var clipEdgeEnd;
	var inputEdgeStart;
	var inputEdgeEnd;
	var clipLen = clipPoly.length;
	var i = 0;
	var _g = 0;
	var _g1 = clipLen;
	while(_g < _g1) {
		var i1 = _g++;
		clipEdgeStart = clipPoly[i1];
		var idx = i1 + 1;
		var len = clipPoly.length;
		if(idx < 0) {
			idx += len;
		}
		clipEdgeEnd = clipPoly[idx % len];
		var input = output;
		output = [];
		inputEdgeStart = input[input.length - 1];
		var _g2 = 0;
		var _g11 = input.length;
		while(_g2 < _g11) {
			var j = _g2++;
			inputEdgeEnd = input[j];
			if(isInside(inputEdgeEnd,clipEdgeStart,clipEdgeEnd)) {
				if(!isInside(inputEdgeStart,clipEdgeStart,clipEdgeEnd)) {
					var intersectionPoint = hxGeomAlgo_PolyTools.intersection(inputEdgeStart,inputEdgeEnd,clipEdgeStart,clipEdgeEnd);
					if(intersectionPoint != null) {
						output.push(intersectionPoint);
					}
				}
				output.push(inputEdgeEnd);
			} else if(isInside(inputEdgeStart,clipEdgeStart,clipEdgeEnd)) {
				var intersectionPoint1 = hxGeomAlgo_PolyTools.intersection(inputEdgeStart,inputEdgeEnd,clipEdgeStart,clipEdgeEnd);
				if(intersectionPoint1 != null) {
					output.push(intersectionPoint1);
				}
			}
			inputEdgeStart = inputEdgeEnd;
		}
		res.push(output);
	}
	return res;
};
hxGeomAlgo_PolyTools.exposeEnum = function(enumClass,as) {
	var dotPath = (as != null ? as : enumClass.__ename__).split(".");
	var exports = $hx_exports;
	var i = 0;
	while(i < dotPath.length - 1) {
		var currPath = dotPath[i];
		exports[currPath] = exports[currPath] || { };
		exports = exports[currPath];
		++i;
	}
	exports[dotPath[i]] = enumClass;
};
var hxGeomAlgo_WindingRule = $hxEnums["hxGeomAlgo.WindingRule"] = { __ename__ : "hxGeomAlgo.WindingRule", __constructs__ : ["ODD","NON_ZERO","POSITIVE","NEGATIVE","ABS_GEQ_TWO"]
	,ODD: {_hx_index:0,__enum__:"hxGeomAlgo.WindingRule",toString:$estr}
	,NON_ZERO: {_hx_index:1,__enum__:"hxGeomAlgo.WindingRule",toString:$estr}
	,POSITIVE: {_hx_index:2,__enum__:"hxGeomAlgo.WindingRule",toString:$estr}
	,NEGATIVE: {_hx_index:3,__enum__:"hxGeomAlgo.WindingRule",toString:$estr}
	,ABS_GEQ_TWO: {_hx_index:4,__enum__:"hxGeomAlgo.WindingRule",toString:$estr}
};
var hxGeomAlgo_ResultType = $hxEnums["hxGeomAlgo.ResultType"] = { __ename__ : "hxGeomAlgo.ResultType", __constructs__ : ["POLYGONS","CONNECTED_POLYGONS","BOUNDARY_CONTOURS","EXPERIMENTAL_DELAUNAY"]
	,POLYGONS: {_hx_index:0,__enum__:"hxGeomAlgo.ResultType",toString:$estr}
	,CONNECTED_POLYGONS: {_hx_index:1,__enum__:"hxGeomAlgo.ResultType",toString:$estr}
	,BOUNDARY_CONTOURS: {_hx_index:2,__enum__:"hxGeomAlgo.ResultType",toString:$estr}
	,EXPERIMENTAL_DELAUNAY: {_hx_index:3,__enum__:"hxGeomAlgo.ResultType",toString:$estr}
};
var hxGeomAlgo_Tess2 = $hx_exports["hxGeomAlgo"]["Tess2"] = function() { };
hxGeomAlgo_Tess2.__name__ = true;
hxGeomAlgo_Tess2.tesselate = function(contours,windingRule,resultType,polySize,vertexDim,normal) {
	if(vertexDim == null) {
		vertexDim = 2;
	}
	if(polySize == null) {
		polySize = 3;
	}
	var tess = new hxGeomAlgo_Tesselator();
	var _g = 0;
	var _g1 = contours.length;
	while(_g < _g1) {
		var i = _g++;
		tess.addContour(vertexDim,contours[i]);
	}
	tess.tesselate(windingRule == null ? hxGeomAlgo_WindingRule.ODD : windingRule,resultType == null ? hxGeomAlgo_ResultType.POLYGONS : resultType,polySize,vertexDim,normal == null ? [0,0,1] : normal);
	return { vertices : tess.vertices, vertexIndices : tess.vertexIndices, vertexCount : tess.vertexCount, elements : tess.elements, elementCount : tess.elementCount};
};
hxGeomAlgo_Tess2.union = function(contoursA,contoursB,resultType,polySize,vertexDim) {
	if(vertexDim == null) {
		vertexDim = 2;
	}
	if(polySize == null) {
		polySize = 3;
	}
	var contours = contoursA.concat(contoursB);
	return hxGeomAlgo_Tess2.tesselate(contours,hxGeomAlgo_WindingRule.NON_ZERO,resultType,polySize,vertexDim);
};
hxGeomAlgo_Tess2.intersection = function(contoursA,contoursB,resultType,polySize,vertexDim) {
	if(vertexDim == null) {
		vertexDim = 2;
	}
	if(polySize == null) {
		polySize = 3;
	}
	var contours = contoursA.concat(contoursB);
	return hxGeomAlgo_Tess2.tesselate(contours,hxGeomAlgo_WindingRule.ABS_GEQ_TWO,resultType,polySize,vertexDim);
};
hxGeomAlgo_Tess2.difference = function(contoursA,contoursB,resultType,polySize,vertexDim) {
	if(vertexDim == null) {
		vertexDim = 2;
	}
	if(polySize == null) {
		polySize = 3;
	}
	var _g = [];
	var _g1 = 0;
	while(_g1 < contoursB.length) {
		var poly = contoursB[_g1];
		++_g1;
		_g.push(hxGeomAlgo_PolyTools.reverseFloatArray(poly));
	}
	var diffB = _g;
	var contours = contoursA.concat(diffB);
	return hxGeomAlgo_Tess2.tesselate(contours,hxGeomAlgo_WindingRule.POSITIVE,resultType,polySize,vertexDim);
};
hxGeomAlgo_Tess2.convertResult = function(vertices,elements,resultType,polySize,out) {
	out = out != null ? out : [];
	if(resultType._hx_index != 2) {
		hxGeomAlgo_Debug.assert(polySize >= 3 && elements.length % polySize == 0,"Invalid size",{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 194, className : "hxGeomAlgo.Tess2", methodName : "convertResult"});
	}
	var i = 0;
	switch(resultType._hx_index) {
	case 0:case 3:
		while(i < elements.length) {
			var poly = [];
			var _g = 0;
			var _g1 = polySize;
			while(_g < _g1) {
				var j = _g++;
				var idx = elements[i + j];
				if(idx == -1) {
					continue;
				}
				poly.push(hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(vertices[idx * 2],vertices[idx * 2 + 1]));
			}
			out.push(poly);
			i += polySize;
		}
		break;
	case 1:
		while(i < elements.length) {
			var poly1 = [];
			var _g2 = 0;
			var _g11 = polySize;
			while(_g2 < _g11) {
				var j1 = _g2++;
				var idx1 = elements[i + j1];
				if(idx1 == -1) {
					continue;
				}
				poly1.push(hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(vertices[idx1 * 2],vertices[idx1 * 2 + 1]));
			}
			out.push(poly1);
			i += polySize * 2;
		}
		break;
	case 2:
		while(i < elements.length) {
			var poly2 = [];
			var start = elements[i];
			var count = elements[i + 1];
			var _g3 = 0;
			var _g12 = count;
			while(_g3 < _g12) {
				var j2 = _g3++;
				var idx2 = start + j2;
				poly2.push(hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(vertices[idx2 * 2],vertices[idx2 * 2 + 1]));
			}
			out.push(poly2);
			i += 2;
		}
		break;
	}
	return out;
};
var hxGeomAlgo__$Tess2_TessVertex = function() {
	this.idx = 0;
	this.n = 0;
	this.pqHandle = 0;
	this.t = 0.0;
	this.s = 0.0;
	this.coords = [0,0,0];
	this.anEdge = null;
	this.prev = null;
	this.next = null;
};
hxGeomAlgo__$Tess2_TessVertex.__name__ = true;
var hxGeomAlgo__$Tess2_TessFace = function() {
	this.inside = false;
	this.marked = false;
	this.n = 0;
	this.trail = null;
	this.anEdge = null;
	this.prev = null;
	this.next = null;
};
hxGeomAlgo__$Tess2_TessFace.__name__ = true;
var hxGeomAlgo__$Tess2_TessHalfEdge = function(side) {
	this.winding = 0;
	this.activeRegion = null;
	this.Lface = null;
	this.Org = null;
	this.Lnext = null;
	this.Onext = null;
	this.Sym = null;
	this.next = null;
	this.side = side;
};
hxGeomAlgo__$Tess2_TessHalfEdge.__name__ = true;
hxGeomAlgo__$Tess2_TessHalfEdge.prototype = {
	get_Rface: function() {
		return this.Sym.Lface;
	}
	,set_Rface: function(v) {
		return this.Sym.Lface = v;
	}
	,get_Dst: function() {
		return this.Sym.Org;
	}
	,set_Dst: function(v) {
		return this.Sym.Org = v;
	}
	,get_Oprev: function() {
		return this.Sym.Lnext;
	}
	,set_Oprev: function(v) {
		return this.Sym.Lnext = v;
	}
	,get_Lprev: function() {
		return this.Onext.Sym;
	}
	,set_Lprev: function(v) {
		return this.Onext.Sym = v;
	}
	,get_Dprev: function() {
		return this.Lnext.Sym;
	}
	,set_Dprev: function(v) {
		return this.Lnext.Sym = v;
	}
	,get_Rprev: function() {
		return this.Sym.Onext;
	}
	,set_Rprev: function(v) {
		return this.Sym.Onext = v;
	}
	,get_Dnext: function() {
		return this.Sym.Onext.Sym;
	}
	,set_Dnext: function(v) {
		return this.Sym.Onext.Sym = v;
	}
	,get_Rnext: function() {
		return this.Sym.Lnext.Sym;
	}
	,set_Rnext: function(v) {
		return this.Sym.Lnext.Sym = v;
	}
};
var hxGeomAlgo__$Tess2_TessMesh = function() {
	this.eSym = new hxGeomAlgo__$Tess2_TessHalfEdge(1);
	this.e = new hxGeomAlgo__$Tess2_TessHalfEdge(0);
	this.f = new hxGeomAlgo__$Tess2_TessFace();
	this.v = new hxGeomAlgo__$Tess2_TessVertex();
	this.v.next = this.v.prev = this.v;
	this.v.anEdge = null;
	this.f.next = this.f.prev = this.f;
	this.f.anEdge = null;
	this.f.trail = null;
	this.f.marked = false;
	this.f.inside = false;
	this.e.next = this.e;
	this.e.Sym = this.eSym;
	this.e.Onext = null;
	this.e.Lnext = null;
	this.e.Org = null;
	this.e.Lface = null;
	this.e.winding = 0;
	this.e.activeRegion = null;
	this.e.mark = false;
	this.eSym.next = this.eSym;
	this.eSym.Sym = this.e;
	this.eSym.Onext = null;
	this.eSym.Lnext = null;
	this.eSym.Org = null;
	this.eSym.Lface = null;
	this.eSym.winding = 0;
	this.eSym.activeRegion = null;
	this.e.Sym.mark = false;
	this.vHead = this.v;
	this.fHead = this.f;
	this.eHead = this.e;
	this.eHeadSym = this.eSym;
};
hxGeomAlgo__$Tess2_TessMesh.__name__ = true;
hxGeomAlgo__$Tess2_TessMesh.flipEdge = function(mesh,edge) {
	var a0 = edge;
	var a1 = a0.Lnext;
	var a2 = a1.Lnext;
	var b0 = edge.Sym;
	var b1 = b0.Lnext;
	var b2 = b1.Lnext;
	var aOrg = a0.Org;
	var aOpp = a2.Org;
	var bOrg = b0.Org;
	var bOpp = b2.Org;
	var fa = a0.Lface;
	var fb = b0.Lface;
	hxGeomAlgo_Debug.assert(hxGeomAlgo__$Tess2_Geom.edgeIsInternal(edge),null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 796, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
	hxGeomAlgo_Debug.assert(a2.Lnext == a0,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 797, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
	hxGeomAlgo_Debug.assert(b2.Lnext == b0,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 798, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
	a0.Org = bOpp;
	a0.Onext = b1.Sym;
	b0.Org = aOpp;
	b0.Onext = a1.Sym;
	a2.Onext = b0;
	b2.Onext = a0;
	b1.Onext = a2.Sym;
	a1.Onext = b2.Sym;
	a0.Lnext = a2;
	a2.Lnext = b1;
	b1.Lnext = a0;
	b0.Lnext = b2;
	b2.Lnext = a1;
	a1.Lnext = b0;
	a1.Lface = fb;
	b1.Lface = fa;
	fa.anEdge = a0;
	fb.anEdge = b0;
	if(aOrg.anEdge == a0) {
		aOrg.anEdge = b1;
	}
	if(bOrg.anEdge == b0) {
		bOrg.anEdge = a1;
	}
	hxGeomAlgo_Debug.assert(a0.Lnext.Onext.Sym == a0,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 826, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
	hxGeomAlgo_Debug.assert(a0.Onext.Sym.Lnext == a0,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 827, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
	hxGeomAlgo_Debug.assert(a0.Org.anEdge.Org == a0.Org,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 828, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
	hxGeomAlgo_Debug.assert(a1.Lnext.Onext.Sym == a1,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 831, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
	hxGeomAlgo_Debug.assert(a1.Onext.Sym.Lnext == a1,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 832, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
	hxGeomAlgo_Debug.assert(a1.Org.anEdge.Org == a1.Org,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 833, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
	hxGeomAlgo_Debug.assert(a2.Lnext.Onext.Sym == a2,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 835, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
	hxGeomAlgo_Debug.assert(a2.Onext.Sym.Lnext == a2,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 836, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
	hxGeomAlgo_Debug.assert(a2.Org.anEdge.Org == a2.Org,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 837, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
	hxGeomAlgo_Debug.assert(b0.Lnext.Onext.Sym == b0,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 839, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
	hxGeomAlgo_Debug.assert(b0.Onext.Sym.Lnext == b0,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 840, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
	hxGeomAlgo_Debug.assert(b0.Org.anEdge.Org == b0.Org,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 841, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
	hxGeomAlgo_Debug.assert(b1.Lnext.Onext.Sym == b1,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 843, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
	hxGeomAlgo_Debug.assert(b1.Onext.Sym.Lnext == b1,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 844, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
	hxGeomAlgo_Debug.assert(b1.Org.anEdge.Org == b1.Org,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 845, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
	hxGeomAlgo_Debug.assert(b2.Lnext.Onext.Sym == b2,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 847, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
	hxGeomAlgo_Debug.assert(b2.Onext.Sym.Lnext == b2,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 848, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
	hxGeomAlgo_Debug.assert(b2.Org.anEdge.Org == b2.Org,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 849, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
	hxGeomAlgo_Debug.assert(aOrg.anEdge.Org == aOrg,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 851, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
	hxGeomAlgo_Debug.assert(bOrg.anEdge.Org == bOrg,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 852, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
	hxGeomAlgo_Debug.assert(a0.get_Oprev().Onext.Org == a0.Org,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 854, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "flipEdge"});
};
hxGeomAlgo__$Tess2_TessMesh.prototype = {
	makeEdge_: function(eNext) {
		var e = new hxGeomAlgo__$Tess2_TessHalfEdge(0);
		var eSym = new hxGeomAlgo__$Tess2_TessHalfEdge(1);
		if(eNext.Sym.side < eNext.side) {
			eNext = eNext.Sym;
		}
		var ePrev = eNext.Sym.next;
		eSym.next = ePrev;
		ePrev.Sym.next = e;
		e.next = eNext;
		eNext.Sym.next = eSym;
		e.Sym = eSym;
		e.Onext = e;
		e.Lnext = eSym;
		e.Org = null;
		e.Lface = null;
		e.winding = 0;
		e.activeRegion = null;
		eSym.Sym = e;
		eSym.Onext = eSym;
		eSym.Lnext = e;
		eSym.Org = null;
		eSym.Lface = null;
		eSym.winding = 0;
		eSym.activeRegion = null;
		return e;
	}
	,splice_: function(a,b) {
		var aOnext = a.Onext;
		var bOnext = b.Onext;
		aOnext.Sym.Lnext = b;
		bOnext.Sym.Lnext = a;
		a.Onext = bOnext;
		b.Onext = aOnext;
	}
	,makeVertex_: function(newVertex,eOrig,vNext) {
		var vNew = newVertex;
		hxGeomAlgo_Debug.assert(vNew != null,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 586, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "makeVertex_"});
		var vPrev = vNext.prev;
		vNew.prev = vPrev;
		vPrev.next = vNew;
		vNew.next = vNext;
		vNext.prev = vNew;
		vNew.anEdge = eOrig;
		var e = eOrig;
		while(true) {
			e.Org = vNew;
			e = e.Onext;
			if(!(e != eOrig)) {
				break;
			}
		}
	}
	,makeFace_: function(newFace,eOrig,fNext) {
		var fNew = newFace;
		hxGeomAlgo_Debug.assert(fNew != null,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 615, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "makeFace_"});
		var fPrev = fNext.prev;
		fNew.prev = fPrev;
		fPrev.next = fNew;
		fNew.next = fNext;
		fNext.prev = fNew;
		fNew.anEdge = eOrig;
		fNew.trail = null;
		fNew.marked = false;
		fNew.inside = fNext.inside;
		var e = eOrig;
		while(true) {
			e.Lface = fNew;
			e = e.Lnext;
			if(!(e != eOrig)) {
				break;
			}
		}
	}
	,killEdge_: function(eDel) {
		if(eDel.Sym.side < eDel.side) {
			eDel = eDel.Sym;
		}
		var eNext = eDel.next;
		var ePrev = eDel.Sym.next;
		eNext.Sym.next = ePrev;
		ePrev.Sym.next = eNext;
	}
	,killVertex_: function(vDel,newOrg) {
		var eStart = vDel.anEdge;
		var e = eStart;
		while(true) {
			e.Org = newOrg;
			e = e.Onext;
			if(!(e != eStart)) {
				break;
			}
		}
		var vPrev = vDel.prev;
		var vNext = vDel.next;
		vNext.prev = vPrev;
		vPrev.next = vNext;
	}
	,killFace_: function(fDel,newLface) {
		var eStart = fDel.anEdge;
		var e = eStart;
		while(true) {
			e.Lface = newLface;
			e = e.Lnext;
			if(!(e != eStart)) {
				break;
			}
		}
		var fPrev = fDel.prev;
		var fNext = fDel.next;
		fNext.prev = fPrev;
		fPrev.next = fNext;
	}
	,makeEdge: function() {
		var newVertex1 = new hxGeomAlgo__$Tess2_TessVertex();
		var newVertex2 = new hxGeomAlgo__$Tess2_TessVertex();
		var newFace = new hxGeomAlgo__$Tess2_TessFace();
		var e = this.makeEdge_(this.eHead);
		this.makeVertex_(newVertex1,e,this.vHead);
		this.makeVertex_(newVertex2,e.Sym,this.vHead);
		this.makeFace_(newFace,e,this.fHead);
		return e;
	}
	,splice: function(eOrg,eDst) {
		var joiningLoops = false;
		var joiningVertices = false;
		if(eOrg == eDst) {
			return;
		}
		if(eDst.Org != eOrg.Org) {
			joiningVertices = true;
			this.killVertex_(eDst.Org,eOrg.Org);
		}
		if(eDst.Lface != eOrg.Lface) {
			joiningLoops = true;
			this.killFace_(eDst.Lface,eOrg.Lface);
		}
		this.splice_(eDst,eOrg);
		if(!joiningVertices) {
			var newVertex = new hxGeomAlgo__$Tess2_TessVertex();
			this.makeVertex_(newVertex,eDst,eOrg.Org);
			eOrg.Org.anEdge = eOrg;
		}
		if(!joiningLoops) {
			var newFace = new hxGeomAlgo__$Tess2_TessFace();
			this.makeFace_(newFace,eDst,eOrg.Lface);
			eOrg.Lface.anEdge = eOrg;
		}
	}
	,'delete': function(eDel) {
		var eDelSym = eDel.Sym;
		var joiningLoops = false;
		if(eDel.Lface != eDel.get_Rface()) {
			joiningLoops = true;
			this.killFace_(eDel.Lface,eDel.get_Rface());
		}
		if(eDel.Onext == eDel) {
			this.killVertex_(eDel.Org,null);
		} else {
			eDel.get_Rface().anEdge = eDel.get_Oprev();
			eDel.Org.anEdge = eDel.Onext;
			this.splice_(eDel,eDel.get_Oprev());
			if(!joiningLoops) {
				var newFace = new hxGeomAlgo__$Tess2_TessFace();
				this.makeFace_(newFace,eDel,eDel.Lface);
			}
		}
		if(eDelSym.Onext == eDelSym) {
			this.killVertex_(eDelSym.Org,null);
			this.killFace_(eDelSym.Lface,null);
		} else {
			eDel.Lface.anEdge = eDelSym.get_Oprev();
			eDelSym.Org.anEdge = eDelSym.Onext;
			this.splice_(eDelSym,eDelSym.get_Oprev());
		}
		this.killEdge_(eDel);
	}
	,addEdgeVertex: function(eOrg) {
		var eNew = this.makeEdge_(eOrg);
		var eNewSym = eNew.Sym;
		this.splice_(eNew,eOrg.Lnext);
		eNew.Org = eOrg.get_Dst();
		var newVertex = new hxGeomAlgo__$Tess2_TessVertex();
		this.makeVertex_(newVertex,eNewSym,eNew.Org);
		eNew.Lface = eNewSym.Lface = eOrg.Lface;
		return eNew;
	}
	,splitEdge: function(eOrg) {
		var tempHalfEdge = this.addEdgeVertex(eOrg);
		var eNew = tempHalfEdge.Sym;
		this.splice_(eOrg.Sym,eOrg.Sym.get_Oprev());
		this.splice_(eOrg.Sym,eNew);
		eOrg.set_Dst(eNew.Org);
		eNew.get_Dst().anEdge = eNew.Sym;
		eNew.set_Rface(eOrg.get_Rface());
		eNew.winding = eOrg.winding;
		eNew.Sym.winding = eOrg.Sym.winding;
		return eNew;
	}
	,connect: function(eOrg,eDst) {
		var joiningLoops = false;
		var eNew = this.makeEdge_(eOrg);
		var eNewSym = eNew.Sym;
		if(eDst.Lface != eOrg.Lface) {
			joiningLoops = true;
			this.killFace_(eDst.Lface,eOrg.Lface);
		}
		this.splice_(eNew,eOrg.Lnext);
		this.splice_(eNewSym,eDst);
		eNew.Org = eOrg.get_Dst();
		eNewSym.Org = eDst.Org;
		eNew.Lface = eNewSym.Lface = eOrg.Lface;
		eOrg.Lface.anEdge = eNewSym;
		if(!joiningLoops) {
			var newFace = new hxGeomAlgo__$Tess2_TessFace();
			this.makeFace_(newFace,eNew,eOrg.Lface);
		}
		return eNew;
	}
	,zapFace: function(fZap) {
		var eStart = fZap.anEdge;
		var e;
		var eSym;
		var eNext = eStart.Lnext;
		while(true) {
			e = eNext;
			eNext = e.Lnext;
			e.Lface = null;
			if(e.get_Rface() == null) {
				if(e.Onext == e) {
					this.killVertex_(e.Org,null);
				} else {
					e.Org.anEdge = e.Onext;
					this.splice_(e,e.get_Oprev());
				}
				eSym = e.Sym;
				if(eSym.Onext == eSym) {
					this.killVertex_(eSym.Org,null);
				} else {
					eSym.Org.anEdge = eSym.Onext;
					this.splice_(eSym,eSym.get_Oprev());
				}
				this.killEdge_(e);
			}
			if(!(e != eStart)) {
				break;
			}
		}
		var fPrev = fZap.prev;
		var fNext = fZap.next;
		fNext.prev = fPrev;
		fPrev.next = fNext;
	}
	,countFaceVerts_: function(f) {
		var eCur = f.anEdge;
		var n = 0;
		while(true) {
			++n;
			eCur = eCur.Lnext;
			if(!(eCur != f.anEdge)) {
				break;
			}
		}
		return n;
	}
	,mergeConvexFaces: function(maxVertsPerFace) {
		var eCur;
		var eNext;
		var eSym;
		var vStart;
		var curNv;
		var symNv;
		var f = this.fHead.next;
		while(f != this.fHead) {
			if(!f.inside) {
				f = f.next;
				continue;
			}
			eCur = f.anEdge;
			vStart = eCur.Org;
			while(true) {
				eNext = eCur.Lnext;
				eSym = eCur.Sym;
				if(eSym != null && eSym.Lface != null && eSym.Lface.inside) {
					curNv = this.countFaceVerts_(f);
					symNv = this.countFaceVerts_(eSym.Lface);
					if(curNv + symNv - 2 <= maxVertsPerFace) {
						if(hxGeomAlgo__$Tess2_Geom.vertCCW(eCur.get_Lprev().Org,eCur.Org,eSym.Lnext.Lnext.Org) && hxGeomAlgo__$Tess2_Geom.vertCCW(eSym.get_Lprev().Org,eSym.Org,eCur.Lnext.Lnext.Org)) {
							eNext = eSym.Lnext;
							this["delete"](eSym);
							eCur = null;
							eSym = null;
						}
					}
				}
				if(eCur != null && eCur.Lnext.Org == vStart) {
					break;
				}
				eCur = eNext;
			}
			f = f.next;
		}
		return true;
	}
	,check: function() {
		var fHead = this.fHead;
		var vHead = this.vHead;
		var eHead = this.eHead;
		var f;
		var v;
		var e;
		var fPrev = fHead;
		while(true) {
			f = fPrev.next;
			if(!(f != fHead)) {
				break;
			}
			hxGeomAlgo_Debug.assert(f.prev == fPrev,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1138, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "check"});
			e = f.anEdge;
			while(true) {
				hxGeomAlgo_Debug.assert(e.Sym != e,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1141, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "check"});
				hxGeomAlgo_Debug.assert(e.Sym.Sym == e,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1142, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "check"});
				hxGeomAlgo_Debug.assert(e.Lnext.Onext.Sym == e,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1143, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "check"});
				hxGeomAlgo_Debug.assert(e.Onext.Sym.Lnext == e,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1144, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "check"});
				hxGeomAlgo_Debug.assert(e.Lface == f,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1145, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "check"});
				e = e.Lnext;
				if(!(e != f.anEdge)) {
					break;
				}
			}
			fPrev = f;
		}
		hxGeomAlgo_Debug.assert(f.prev == fPrev && f.anEdge == null,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1150, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "check"});
		var vPrev = vHead;
		while(true) {
			v = vPrev.next;
			if(!(v != vHead)) {
				break;
			}
			hxGeomAlgo_Debug.assert(v.prev == vPrev,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1154, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "check"});
			e = v.anEdge;
			while(true) {
				hxGeomAlgo_Debug.assert(e.Sym != e,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1157, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "check"});
				hxGeomAlgo_Debug.assert(e.Sym.Sym == e,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1158, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "check"});
				hxGeomAlgo_Debug.assert(e.Lnext.Onext.Sym == e,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1159, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "check"});
				hxGeomAlgo_Debug.assert(e.Onext.Sym.Lnext == e,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1160, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "check"});
				hxGeomAlgo_Debug.assert(e.Org == v,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1161, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "check"});
				e = e.Onext;
				if(!(e != v.anEdge)) {
					break;
				}
			}
			vPrev = v;
		}
		hxGeomAlgo_Debug.assert(v.prev == vPrev && v.anEdge == null,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1166, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "check"});
		var ePrev = eHead;
		while(true) {
			e = ePrev.next;
			if(!(e != eHead)) {
				break;
			}
			hxGeomAlgo_Debug.assert(e.Sym.next == ePrev.Sym,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1170, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "check"});
			hxGeomAlgo_Debug.assert(e.Sym != e,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1171, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "check"});
			hxGeomAlgo_Debug.assert(e.Sym.Sym == e,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1172, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "check"});
			hxGeomAlgo_Debug.assert(e.Org != null,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1173, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "check"});
			hxGeomAlgo_Debug.assert(e.get_Dst() != null,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1174, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "check"});
			hxGeomAlgo_Debug.assert(e.Lnext.Onext.Sym == e,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1175, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "check"});
			hxGeomAlgo_Debug.assert(e.Onext.Sym.Lnext == e,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1176, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "check"});
			ePrev = e;
		}
		hxGeomAlgo_Debug.assert(e.Sym.next == ePrev.Sym && e.Sym == this.eHeadSym && e.Sym.Sym == e && e.Org == null && e.get_Dst() == null && e.Lface == null && e.get_Rface() == null,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1179, className : "hxGeomAlgo._Tess2.TessMesh", methodName : "check"});
	}
};
var hxGeomAlgo__$Tess2_Geom = function() { };
hxGeomAlgo__$Tess2_Geom.__name__ = true;
hxGeomAlgo__$Tess2_Geom.vertEq = function(u,v) {
	if(u.s == v.s) {
		return u.t == v.t;
	} else {
		return false;
	}
};
hxGeomAlgo__$Tess2_Geom.vertLeq = function(u,v) {
	if(!(u.s < v.s)) {
		if(u.s == v.s) {
			return u.t <= v.t;
		} else {
			return false;
		}
	} else {
		return true;
	}
};
hxGeomAlgo__$Tess2_Geom.transLeq = function(u,v) {
	if(!(u.t < v.t)) {
		if(u.t == v.t) {
			return u.s <= v.s;
		} else {
			return false;
		}
	} else {
		return true;
	}
};
hxGeomAlgo__$Tess2_Geom.edgeGoesLeft = function(e) {
	return hxGeomAlgo__$Tess2_Geom.vertLeq(e.get_Dst(),e.Org);
};
hxGeomAlgo__$Tess2_Geom.edgeGoesRight = function(e) {
	return hxGeomAlgo__$Tess2_Geom.vertLeq(e.Org,e.get_Dst());
};
hxGeomAlgo__$Tess2_Geom.edgeIsInternal = function(e) {
	if(e.get_Rface() != null) {
		return e.get_Rface().inside;
	} else {
		return false;
	}
};
hxGeomAlgo__$Tess2_Geom.vertL1dist = function(u,v) {
	return Math.abs(u.s - v.s) + Math.abs(u.t - v.t);
};
hxGeomAlgo__$Tess2_Geom.edgeEval = function(u,v,w) {
	hxGeomAlgo_Debug.assert(hxGeomAlgo__$Tess2_Geom.vertLeq(u,v) && hxGeomAlgo__$Tess2_Geom.vertLeq(v,w),null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1231, className : "hxGeomAlgo._Tess2.Geom", methodName : "edgeEval"});
	var gapL = v.s - u.s;
	var gapR = w.s - v.s;
	if(gapL + gapR > 0.0) {
		if(gapL < gapR) {
			return v.t - u.t + (u.t - w.t) * (gapL / (gapL + gapR));
		} else {
			return v.t - w.t + (w.t - u.t) * (gapR / (gapL + gapR));
		}
	}
	return 0.0;
};
hxGeomAlgo__$Tess2_Geom.edgeSign = function(u,v,w) {
	hxGeomAlgo_Debug.assert(hxGeomAlgo__$Tess2_Geom.vertLeq(u,v) && hxGeomAlgo__$Tess2_Geom.vertLeq(v,w),null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1253, className : "hxGeomAlgo._Tess2.Geom", methodName : "edgeSign"});
	var gapL = v.s - u.s;
	var gapR = w.s - v.s;
	if(gapL + gapR > 0.0) {
		return (v.t - w.t) * gapL + (v.t - u.t) * gapR;
	}
	return 0.0;
};
hxGeomAlgo__$Tess2_Geom.transEval = function(u,v,w) {
	hxGeomAlgo_Debug.assert(hxGeomAlgo__$Tess2_Geom.transLeq(u,v) && hxGeomAlgo__$Tess2_Geom.transLeq(v,w),null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1282, className : "hxGeomAlgo._Tess2.Geom", methodName : "transEval"});
	var gapL = v.t - u.t;
	var gapR = w.t - v.t;
	if(gapL + gapR > 0.0) {
		if(gapL < gapR) {
			return v.s - u.s + (u.s - w.s) * (gapL / (gapL + gapR));
		} else {
			return v.s - w.s + (w.s - u.s) * (gapR / (gapL + gapR));
		}
	}
	return 0.0;
};
hxGeomAlgo__$Tess2_Geom.transSign = function(u,v,w) {
	hxGeomAlgo_Debug.assert(hxGeomAlgo__$Tess2_Geom.transLeq(u,v) && hxGeomAlgo__$Tess2_Geom.transLeq(v,w),null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1304, className : "hxGeomAlgo._Tess2.Geom", methodName : "transSign"});
	var gapL = v.t - u.t;
	var gapR = w.t - v.t;
	if(gapL + gapR > 0.0) {
		return (v.s - w.s) * gapL + (v.s - u.s) * gapR;
	}
	return 0.0;
};
hxGeomAlgo__$Tess2_Geom.vertCCW = function(u,v,w) {
	return u.s * (v.t - w.t) + v.s * (w.t - u.t) + w.s * (u.t - v.t) >= 0.0;
};
hxGeomAlgo__$Tess2_Geom.interpolate = function(a,x,b,y) {
	if(a < 0) {
		a = 0;
	}
	if(b < 0) {
		b = 0;
	}
	if(a <= b) {
		if(b == 0) {
			return (x + y) / 2;
		} else {
			return x + (y - x) * (a / (a + b));
		}
	} else {
		return y + (x - y) * (b / (a + b));
	}
};
hxGeomAlgo__$Tess2_Geom.intersect = function(o1,d1,o2,d2,v) {
	var z1;
	var z2;
	var t;
	if(!hxGeomAlgo__$Tess2_Geom.vertLeq(o1,d1)) {
		t = o1;
		o1 = d1;
		d1 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.vertLeq(o2,d2)) {
		t = o2;
		o2 = d2;
		d2 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.vertLeq(o1,o2)) {
		t = o1;
		o1 = o2;
		o2 = t;
		t = d1;
		d1 = d2;
		d2 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.vertLeq(o2,d1)) {
		v.s = (o2.s + d1.s) / 2;
	} else if(hxGeomAlgo__$Tess2_Geom.vertLeq(d1,d2)) {
		z1 = hxGeomAlgo__$Tess2_Geom.edgeEval(o1,o2,d1);
		z2 = hxGeomAlgo__$Tess2_Geom.edgeEval(o2,d1,d2);
		if(z1 + z2 < 0) {
			z1 = -z1;
			z2 = -z2;
		}
		v.s = hxGeomAlgo__$Tess2_Geom.interpolate(z1,o2.s,z2,d1.s);
	} else {
		z1 = hxGeomAlgo__$Tess2_Geom.edgeSign(o1,o2,d1);
		z2 = -hxGeomAlgo__$Tess2_Geom.edgeSign(o1,d2,d1);
		if(z1 + z2 < 0) {
			z1 = -z1;
			z2 = -z2;
		}
		v.s = hxGeomAlgo__$Tess2_Geom.interpolate(z1,o2.s,z2,d2.s);
	}
	if(!hxGeomAlgo__$Tess2_Geom.transLeq(o1,d1)) {
		t = o1;
		o1 = d1;
		d1 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.transLeq(o2,d2)) {
		t = o2;
		o2 = d2;
		d2 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.transLeq(o1,o2)) {
		t = o1;
		o1 = o2;
		o2 = t;
		t = d1;
		d1 = d2;
		d2 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.transLeq(o2,d1)) {
		v.t = (o2.t + d1.t) / 2;
	} else if(hxGeomAlgo__$Tess2_Geom.transLeq(d1,d2)) {
		z1 = hxGeomAlgo__$Tess2_Geom.transEval(o1,o2,d1);
		z2 = hxGeomAlgo__$Tess2_Geom.transEval(o2,d1,d2);
		if(z1 + z2 < 0) {
			z1 = -z1;
			z2 = -z2;
		}
		v.t = hxGeomAlgo__$Tess2_Geom.interpolate(z1,o2.t,z2,d1.t);
	} else {
		z1 = hxGeomAlgo__$Tess2_Geom.transSign(o1,o2,d1);
		z2 = -hxGeomAlgo__$Tess2_Geom.transSign(o1,d2,d1);
		if(z1 + z2 < 0) {
			z1 = -z1;
			z2 = -z2;
		}
		v.t = hxGeomAlgo__$Tess2_Geom.interpolate(z1,o2.t,z2,d2.t);
	}
};
hxGeomAlgo__$Tess2_Geom.calcAngle = function(v0,v1,v2) {
	var a_0 = v2.s - v1.s;
	var a_1 = v2.t - v1.t;
	var b_0 = v0.s - v1.s;
	var b_1 = v0.t - v1.t;
	var num = a_0 * b_0 + a_1 * b_1;
	var den = Math.sqrt(a_0 * a_0 + a_1 * a_1) * Math.sqrt(b_0 * b_0 + b_1 * b_1);
	if(den > 0.0) {
		num /= den;
	}
	if(num < -1.0) {
		num = -1.0;
	}
	if(num > 1.0) {
		num = 1.0;
	}
	return Math.acos(num);
};
hxGeomAlgo__$Tess2_Geom.edgeIsLocallyDelaunay = function(e) {
	return hxGeomAlgo__$Tess2_Geom.calcAngle(e.Lnext.Org,e.Lnext.Lnext.Org,e.Org) + hxGeomAlgo__$Tess2_Geom.calcAngle(e.Sym.Lnext.Org,e.Sym.Lnext.Lnext.Org,e.Sym.Org) < Math.PI + 0.01;
};
var hxGeomAlgo__$Tess2_DictNode = function() {
	this.prev = null;
	this.next = null;
	this.key = null;
};
hxGeomAlgo__$Tess2_DictNode.__name__ = true;
var hxGeomAlgo__$Tess2_Dict = function(frame,leq) {
	this.head = new hxGeomAlgo__$Tess2_DictNode();
	this.head.next = this.head;
	this.head.prev = this.head;
	this.frame = frame;
	this.leq = leq;
};
hxGeomAlgo__$Tess2_Dict.__name__ = true;
hxGeomAlgo__$Tess2_Dict.prototype = {
	min: function() {
		return this.head.next;
	}
	,max: function() {
		return this.head.prev;
	}
	,insert: function(k) {
		return this.insertBefore(this.head,k);
	}
	,search: function(key) {
		var node = this.head;
		while(true) {
			node = node.next;
			if(!(node.key != null && !this.leq(this.frame,key,node.key))) {
				break;
			}
		}
		return node;
	}
	,insertBefore: function(node,key) {
		while(true) {
			node = node.prev;
			if(!(node.key != null && !this.leq(this.frame,node.key,key))) {
				break;
			}
		}
		var newNode = new hxGeomAlgo__$Tess2_DictNode();
		newNode.key = key;
		newNode.next = node.next;
		node.next.prev = newNode;
		newNode.prev = node;
		node.next = newNode;
		return newNode;
	}
	,'delete': function(node) {
		node.next.prev = node.prev;
		node.prev.next = node.next;
	}
};
var hxGeomAlgo__$Tess2_PQNode = function() {
	this.handle = -1;
};
hxGeomAlgo__$Tess2_PQNode.__name__ = true;
var hxGeomAlgo__$Tess2_PQHandleElem = function() {
	this.node = -1;
	this.key = null;
};
hxGeomAlgo__$Tess2_PQHandleElem.__name__ = true;
var hxGeomAlgo__$Tess2_PriorityQ = function(size,leq) {
	this.size = 0;
	this.max = size;
	this.nodes = [];
	var _g = 0;
	var _g1 = size + 1;
	while(_g < _g1) {
		var i = _g++;
		this.nodes[i] = new hxGeomAlgo__$Tess2_PQNode();
	}
	this.handles = [];
	var _g2 = 0;
	var _g3 = size + 1;
	while(_g2 < _g3) {
		var i1 = _g2++;
		this.handles[i1] = new hxGeomAlgo__$Tess2_PQHandleElem();
	}
	this.initialized = false;
	this.freeList = 0;
	this.leq = leq;
	this.nodes[1].handle = 1;
	this.handles[1].key = null;
};
hxGeomAlgo__$Tess2_PriorityQ.__name__ = true;
hxGeomAlgo__$Tess2_PriorityQ.prototype = {
	floatDown_: function(curr) {
		var n = this.nodes;
		var h = this.handles;
		var hChild;
		var child;
		var hCurr = n[curr].handle;
		while(true) {
			child = curr << 1;
			if(child < this.size && this.leq(h[n[child + 1].handle].key,h[n[child].handle].key)) {
				++child;
			}
			hxGeomAlgo_Debug.assert(child <= this.max,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1586, className : "hxGeomAlgo._Tess2.PriorityQ", methodName : "floatDown_"});
			hChild = n[child].handle;
			if(child > this.size || this.leq(h[hCurr].key,h[hChild].key)) {
				n[curr].handle = hCurr;
				h[hCurr].node = curr;
				break;
			}
			n[curr].handle = hChild;
			h[hChild].node = curr;
			curr = child;
		}
	}
	,floatUp_: function(curr) {
		var n = this.nodes;
		var h = this.handles;
		var hParent;
		var parent;
		var hCurr = n[curr].handle;
		while(true) {
			parent = curr >> 1;
			hParent = n[parent].handle;
			if(parent == 0 || this.leq(h[hParent].key,h[hCurr].key)) {
				n[curr].handle = hCurr;
				h[hCurr].node = curr;
				break;
			}
			n[curr].handle = hParent;
			h[hParent].node = curr;
			curr = parent;
		}
	}
	,init: function() {
		var i = this.size;
		while(i >= 1) {
			this.floatDown_(i);
			--i;
		}
		this.initialized = true;
	}
	,min: function() {
		return this.handles[this.nodes[1].handle].key;
	}
	,isEmpty: function() {
		return this.size == 0;
	}
	,insert: function(keyNew) {
		var free;
		var curr = ++this.size;
		if(curr * 2 > this.max) {
			this.max *= 2;
			var s = this.nodes.length;
			var _g = s;
			var _g1 = this.max + 1;
			while(_g < _g1) {
				var i = _g++;
				this.nodes[i] = new hxGeomAlgo__$Tess2_PQNode();
			}
			s = this.handles.length;
			var _g2 = this.handles.length;
			var _g3 = this.max + 1;
			while(_g2 < _g3) {
				var i1 = _g2++;
				this.handles[i1] = new hxGeomAlgo__$Tess2_PQHandleElem();
			}
		}
		if(this.freeList == 0) {
			free = curr;
		} else {
			free = this.freeList;
			this.freeList = this.handles[free].node;
		}
		this.nodes[curr].handle = free;
		this.handles[free].node = curr;
		this.handles[free].key = keyNew;
		if(this.initialized) {
			this.floatUp_(curr);
		}
		return free;
	}
	,extractMin: function() {
		var n = this.nodes;
		var h = this.handles;
		var hMin = n[1].handle;
		var min = h[hMin].key;
		if(this.size > 0) {
			n[1].handle = n[this.size].handle;
			h[n[1].handle].node = 1;
			h[hMin].key = null;
			h[hMin].node = this.freeList;
			this.freeList = hMin;
			--this.size;
			if(this.size > 0) {
				this.floatDown_(1);
			}
		}
		return min;
	}
	,'delete': function(hCurr) {
		var n = this.nodes;
		var h = this.handles;
		hxGeomAlgo_Debug.assert(hCurr >= 1 && hCurr <= this.max && h[hCurr].key != null,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1705, className : "hxGeomAlgo._Tess2.PriorityQ", methodName : "delete"});
		var curr = h[hCurr].node;
		n[curr].handle = n[this.size].handle;
		h[n[curr].handle].node = curr;
		--this.size;
		if(curr <= this.size) {
			if(curr <= 1 || this.leq(h[n[curr >> 1].handle].key,h[n[curr].handle].key)) {
				this.floatDown_(curr);
			} else {
				this.floatUp_(curr);
			}
		}
		h[hCurr].key = null;
		h[hCurr].node = this.freeList;
		this.freeList = hCurr;
	}
};
var hxGeomAlgo__$Tess2_ActiveRegion = function() {
	this.fixUpperEdge = false;
	this.dirty = false;
	this.sentinel = false;
	this.inside = false;
	this.windingNumber = 0;
	this.nodeUp = null;
	this.eUp = null;
};
hxGeomAlgo__$Tess2_ActiveRegion.__name__ = true;
var hxGeomAlgo__$Tess2_Sweep = function() { };
hxGeomAlgo__$Tess2_Sweep.__name__ = true;
hxGeomAlgo__$Tess2_Sweep.regionBelow = function(r) {
	return r.nodeUp.prev.key;
};
hxGeomAlgo__$Tess2_Sweep.regionAbove = function(r) {
	return r.nodeUp.next.key;
};
hxGeomAlgo__$Tess2_Sweep.debugEvent = function(tess) {
};
hxGeomAlgo__$Tess2_Sweep.addWinding = function(eDst,eSrc) {
	eDst.winding += eSrc.winding;
	eDst.Sym.winding += eSrc.Sym.winding;
};
hxGeomAlgo__$Tess2_Sweep.edgeLeq = function(tess,reg1,reg2) {
	var ev = tess.event;
	var t1;
	var t2;
	var e1 = reg1.eUp;
	var e2 = reg2.eUp;
	if(e1.get_Dst() == ev) {
		if(e2.get_Dst() == ev) {
			if(hxGeomAlgo__$Tess2_Geom.vertLeq(e1.Org,e2.Org)) {
				return hxGeomAlgo__$Tess2_Geom.edgeSign(e2.get_Dst(),e1.Org,e2.Org) <= 0;
			}
			return hxGeomAlgo__$Tess2_Geom.edgeSign(e1.get_Dst(),e2.Org,e1.Org) >= 0;
		}
		return hxGeomAlgo__$Tess2_Geom.edgeSign(e2.get_Dst(),ev,e2.Org) <= 0;
	}
	if(e2.get_Dst() == ev) {
		return hxGeomAlgo__$Tess2_Geom.edgeSign(e1.get_Dst(),ev,e1.Org) >= 0;
	}
	var t11 = hxGeomAlgo__$Tess2_Geom.edgeEval(e1.get_Dst(),ev,e1.Org);
	var t21 = hxGeomAlgo__$Tess2_Geom.edgeEval(e2.get_Dst(),ev,e2.Org);
	return t11 >= t21;
};
hxGeomAlgo__$Tess2_Sweep.deleteRegion = function(tess,reg) {
	if(reg.fixUpperEdge) {
		hxGeomAlgo_Debug.assert(reg.eUp.winding == 0,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1849, className : "hxGeomAlgo._Tess2.Sweep", methodName : "deleteRegion"});
	}
	reg.eUp.activeRegion = null;
	tess.dict["delete"](reg.nodeUp);
};
hxGeomAlgo__$Tess2_Sweep.fixUpperEdge = function(tess,reg,newEdge) {
	hxGeomAlgo_Debug.assert(reg.fixUpperEdge,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 1860, className : "hxGeomAlgo._Tess2.Sweep", methodName : "fixUpperEdge"});
	tess.mesh["delete"](reg.eUp);
	reg.fixUpperEdge = false;
	reg.eUp = newEdge;
	newEdge.activeRegion = reg;
};
hxGeomAlgo__$Tess2_Sweep.topLeftRegion = function(tess,reg) {
	var org = reg.eUp.Org;
	var e;
	while(true) {
		reg = hxGeomAlgo__$Tess2_Sweep.regionAbove(reg);
		if(!(reg.eUp.Org == org)) {
			break;
		}
	}
	if(reg.fixUpperEdge) {
		e = tess.mesh.connect(hxGeomAlgo__$Tess2_Sweep.regionBelow(reg).eUp.Sym,reg.eUp.Lnext);
		if(e == null) {
			return null;
		}
		hxGeomAlgo__$Tess2_Sweep.fixUpperEdge(tess,reg,e);
		reg = hxGeomAlgo__$Tess2_Sweep.regionAbove(reg);
	}
	return reg;
};
hxGeomAlgo__$Tess2_Sweep.topRightRegion = function(reg) {
	var dst = reg.eUp.get_Dst();
	while(true) {
		reg = hxGeomAlgo__$Tess2_Sweep.regionAbove(reg);
		if(!(reg.eUp.get_Dst() == dst)) {
			break;
		}
	}
	return reg;
};
hxGeomAlgo__$Tess2_Sweep.addRegionBelow = function(tess,regAbove,eNewUp) {
	var regNew = new hxGeomAlgo__$Tess2_ActiveRegion();
	regNew.eUp = eNewUp;
	regNew.nodeUp = tess.dict.insertBefore(regAbove.nodeUp,regNew);
	regNew.fixUpperEdge = false;
	regNew.sentinel = false;
	regNew.dirty = false;
	eNewUp.activeRegion = regNew;
	return regNew;
};
hxGeomAlgo__$Tess2_Sweep.isWindingInside = function(tess,n) {
	switch(tess.windingRule._hx_index) {
	case 0:
		return (n & 1) != 0;
	case 1:
		return n != 0;
	case 2:
		return n > 0;
	case 3:
		return n < 0;
	case 4:
		if(n < 2) {
			return n <= -2;
		} else {
			return true;
		}
		break;
	}
};
hxGeomAlgo__$Tess2_Sweep.computeWinding = function(tess,reg) {
	reg.windingNumber = hxGeomAlgo__$Tess2_Sweep.regionAbove(reg).windingNumber + reg.eUp.winding;
	reg.inside = hxGeomAlgo__$Tess2_Sweep.isWindingInside(tess,reg.windingNumber);
};
hxGeomAlgo__$Tess2_Sweep.finishRegion = function(tess,reg) {
	var e = reg.eUp;
	var f = e.Lface;
	f.inside = reg.inside;
	f.anEdge = e;
	hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,reg);
};
hxGeomAlgo__$Tess2_Sweep.finishLeftRegions = function(tess,regFirst,regLast) {
	var e;
	var ePrev;
	var reg = null;
	var regPrev = regFirst;
	var ePrev1 = regFirst.eUp;
	while(regPrev != regLast) {
		regPrev.fixUpperEdge = false;
		reg = hxGeomAlgo__$Tess2_Sweep.regionBelow(regPrev);
		e = reg.eUp;
		if(e.Org != ePrev1.Org) {
			if(!reg.fixUpperEdge) {
				hxGeomAlgo__$Tess2_Sweep.finishRegion(tess,regPrev);
				break;
			}
			e = tess.mesh.connect(ePrev1.get_Lprev(),e.Sym);
			hxGeomAlgo__$Tess2_Sweep.fixUpperEdge(tess,reg,e);
		}
		if(ePrev1.Onext != e) {
			tess.mesh.splice(e.get_Oprev(),e);
			tess.mesh.splice(ePrev1,e);
		}
		hxGeomAlgo__$Tess2_Sweep.finishRegion(tess,regPrev);
		ePrev1 = reg.eUp;
		regPrev = reg;
	}
	return ePrev1;
};
hxGeomAlgo__$Tess2_Sweep.addRightEdges = function(tess,regUp,eFirst,eLast,eTopLeft,cleanUp) {
	var reg = null;
	var firstTime = true;
	var e = eFirst;
	while(true) {
		hxGeomAlgo_Debug.assert(hxGeomAlgo__$Tess2_Geom.vertLeq(e.Org,e.get_Dst()),null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 2035, className : "hxGeomAlgo._Tess2.Sweep", methodName : "addRightEdges"});
		hxGeomAlgo__$Tess2_Sweep.addRegionBelow(tess,regUp,e.Sym);
		e = e.Onext;
		if(!(e != eLast)) {
			break;
		}
	}
	if(eTopLeft == null) {
		eTopLeft = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp).eUp.get_Rprev();
	}
	var regPrev = regUp;
	var ePrev = eTopLeft;
	while(true) {
		reg = hxGeomAlgo__$Tess2_Sweep.regionBelow(regPrev);
		e = reg.eUp.Sym;
		if(e.Org != ePrev.Org) {
			break;
		}
		if(e.Onext != ePrev) {
			tess.mesh.splice(e.get_Oprev(),e);
			tess.mesh.splice(ePrev.get_Oprev(),e);
		}
		reg.windingNumber = regPrev.windingNumber - e.winding;
		reg.inside = hxGeomAlgo__$Tess2_Sweep.isWindingInside(tess,reg.windingNumber);
		regPrev.dirty = true;
		if(!firstTime && hxGeomAlgo__$Tess2_Sweep.checkForRightSplice(tess,regPrev)) {
			hxGeomAlgo__$Tess2_Sweep.addWinding(e,ePrev);
			hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,regPrev);
			tess.mesh["delete"](ePrev);
		}
		firstTime = false;
		regPrev = reg;
		ePrev = e;
	}
	regPrev.dirty = true;
	hxGeomAlgo_Debug.assert(regPrev.windingNumber - e.winding == reg.windingNumber,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 2077, className : "hxGeomAlgo._Tess2.Sweep", methodName : "addRightEdges"});
	if(cleanUp) {
		hxGeomAlgo__$Tess2_Sweep.walkDirtyRegions(tess,regPrev);
	}
};
hxGeomAlgo__$Tess2_Sweep.spliceMergeVertices = function(tess,e1,e2) {
	tess.mesh.splice(e1,e2);
};
hxGeomAlgo__$Tess2_Sweep.vertexWeights = function(isect,org,dst) {
	var t1 = hxGeomAlgo__$Tess2_Geom.vertL1dist(org,isect);
	var t2 = hxGeomAlgo__$Tess2_Geom.vertL1dist(dst,isect);
	var w0 = 0.5 * t2 / (t1 + t2);
	var w1 = 0.5 * t1 / (t1 + t2);
	isect.coords[0] += w0 * org.coords[0] + w1 * dst.coords[0];
	isect.coords[1] += w0 * org.coords[1] + w1 * dst.coords[1];
	isect.coords[2] += w0 * org.coords[2] + w1 * dst.coords[2];
};
hxGeomAlgo__$Tess2_Sweep.getIntersectData = function(tess,isect,orgUp,dstUp,orgLo,dstLo) {
	var tmp = isect.coords[1] = isect.coords[2] = 0;
	isect.coords[0] = tmp;
	isect.idx = -1;
	hxGeomAlgo__$Tess2_Sweep.vertexWeights(isect,orgUp,dstUp);
	hxGeomAlgo__$Tess2_Sweep.vertexWeights(isect,orgLo,dstLo);
};
hxGeomAlgo__$Tess2_Sweep.checkForRightSplice = function(tess,regUp) {
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eUp = regUp.eUp;
	var eLo = regLo.eUp;
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(eUp.Org,eLo.Org)) {
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(eLo.get_Dst(),eUp.Org,eLo.Org) > 0) {
			return false;
		}
		if(!hxGeomAlgo__$Tess2_Geom.vertEq(eUp.Org,eLo.Org)) {
			tess.mesh.splitEdge(eLo.Sym);
			tess.mesh.splice(eUp,eLo.get_Oprev());
			regUp.dirty = regLo.dirty = true;
		} else if(eUp.Org != eLo.Org) {
			tess.pq["delete"](eUp.Org.pqHandle);
			hxGeomAlgo__$Tess2_Sweep.spliceMergeVertices(tess,eLo.get_Oprev(),eUp);
		}
	} else {
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(eUp.get_Dst(),eLo.Org,eUp.Org) < 0) {
			return false;
		}
		hxGeomAlgo__$Tess2_Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
		tess.mesh.splitEdge(eUp.Sym);
		tess.mesh.splice(eLo.get_Oprev(),eUp);
	}
	return true;
};
hxGeomAlgo__$Tess2_Sweep.checkForLeftSplice = function(tess,regUp) {
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eUp = regUp.eUp;
	var eLo = regLo.eUp;
	var e;
	hxGeomAlgo_Debug.assert(!hxGeomAlgo__$Tess2_Geom.vertEq(eUp.get_Dst(),eLo.get_Dst()),null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 2207, className : "hxGeomAlgo._Tess2.Sweep", methodName : "checkForLeftSplice"});
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(eUp.get_Dst(),eLo.get_Dst())) {
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(eUp.get_Dst(),eLo.get_Dst(),eUp.Org) < 0) {
			return false;
		}
		hxGeomAlgo__$Tess2_Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
		e = tess.mesh.splitEdge(eUp);
		tess.mesh.splice(eLo.Sym,e);
		e.Lface.inside = regUp.inside;
	} else {
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(eLo.get_Dst(),eUp.get_Dst(),eLo.Org) > 0) {
			return false;
		}
		regUp.dirty = regLo.dirty = true;
		e = tess.mesh.splitEdge(eLo);
		tess.mesh.splice(eUp.Lnext,eLo.Sym);
		e.get_Rface().inside = regUp.inside;
	}
	return true;
};
hxGeomAlgo__$Tess2_Sweep.checkForIntersect = function(tess,regUp) {
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eUp = regUp.eUp;
	var eLo = regLo.eUp;
	var orgUp = eUp.Org;
	var orgLo = eLo.Org;
	var dstUp = eUp.get_Dst();
	var dstLo = eLo.get_Dst();
	var isect = new hxGeomAlgo__$Tess2_TessVertex();
	var e;
	hxGeomAlgo_Debug.assert(!hxGeomAlgo__$Tess2_Geom.vertEq(dstLo,dstUp),null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 2252, className : "hxGeomAlgo._Tess2.Sweep", methodName : "checkForIntersect"});
	hxGeomAlgo_Debug.assert(hxGeomAlgo__$Tess2_Geom.edgeSign(dstUp,tess.event,orgUp) <= 0,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 2253, className : "hxGeomAlgo._Tess2.Sweep", methodName : "checkForIntersect"});
	hxGeomAlgo_Debug.assert(hxGeomAlgo__$Tess2_Geom.edgeSign(dstLo,tess.event,orgLo) >= 0,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 2254, className : "hxGeomAlgo._Tess2.Sweep", methodName : "checkForIntersect"});
	hxGeomAlgo_Debug.assert(orgUp != tess.event && orgLo != tess.event,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 2255, className : "hxGeomAlgo._Tess2.Sweep", methodName : "checkForIntersect"});
	hxGeomAlgo_Debug.assert(!regUp.fixUpperEdge && !regLo.fixUpperEdge,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 2256, className : "hxGeomAlgo._Tess2.Sweep", methodName : "checkForIntersect"});
	if(orgUp == orgLo) {
		return false;
	}
	var tMinUp = Math.min(orgUp.t,dstUp.t);
	var tMaxLo = Math.max(orgLo.t,dstLo.t);
	if(tMinUp > tMaxLo) {
		return false;
	}
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(orgUp,orgLo)) {
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(dstLo,orgUp,orgLo) > 0) {
			return false;
		}
	} else if(hxGeomAlgo__$Tess2_Geom.edgeSign(dstUp,orgLo,orgUp) < 0) {
		return false;
	}
	hxGeomAlgo__$Tess2_Sweep.debugEvent(tess);
	hxGeomAlgo__$Tess2_Geom.intersect(dstUp,orgUp,dstLo,orgLo,isect);
	hxGeomAlgo_Debug.assert(Math.min(orgUp.t,dstUp.t) <= isect.t,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 2275, className : "hxGeomAlgo._Tess2.Sweep", methodName : "checkForIntersect"});
	hxGeomAlgo_Debug.assert(isect.t <= Math.max(orgLo.t,dstLo.t),null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 2276, className : "hxGeomAlgo._Tess2.Sweep", methodName : "checkForIntersect"});
	hxGeomAlgo_Debug.assert(Math.min(dstLo.s,dstUp.s) <= isect.s,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 2277, className : "hxGeomAlgo._Tess2.Sweep", methodName : "checkForIntersect"});
	hxGeomAlgo_Debug.assert(isect.s <= Math.max(orgLo.s,orgUp.s),null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 2278, className : "hxGeomAlgo._Tess2.Sweep", methodName : "checkForIntersect"});
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(isect,tess.event)) {
		isect.s = tess.event.s;
		isect.t = tess.event.t;
	}
	var orgMin = hxGeomAlgo__$Tess2_Geom.vertLeq(orgUp,orgLo) ? orgUp : orgLo;
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(orgMin,isect)) {
		isect.s = orgMin.s;
		isect.t = orgMin.t;
	}
	if(hxGeomAlgo__$Tess2_Geom.vertEq(isect,orgUp) || hxGeomAlgo__$Tess2_Geom.vertEq(isect,orgLo)) {
		hxGeomAlgo__$Tess2_Sweep.checkForRightSplice(tess,regUp);
		return false;
	}
	if(!hxGeomAlgo__$Tess2_Geom.vertEq(dstUp,tess.event) && hxGeomAlgo__$Tess2_Geom.edgeSign(dstUp,tess.event,isect) >= 0 || !hxGeomAlgo__$Tess2_Geom.vertEq(dstLo,tess.event) && hxGeomAlgo__$Tess2_Geom.edgeSign(dstLo,tess.event,isect) <= 0) {
		if(dstLo == tess.event) {
			tess.mesh.splitEdge(eUp.Sym);
			tess.mesh.splice(eLo.Sym,eUp);
			regUp = hxGeomAlgo__$Tess2_Sweep.topLeftRegion(tess,regUp);
			eUp = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp).eUp;
			hxGeomAlgo__$Tess2_Sweep.finishLeftRegions(tess,hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp),regLo);
			hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eUp.get_Oprev(),eUp,eUp,true);
			return true;
		}
		if(dstUp == tess.event) {
			tess.mesh.splitEdge(eLo.Sym);
			tess.mesh.splice(eUp.Lnext,eLo.get_Oprev());
			regLo = regUp;
			regUp = hxGeomAlgo__$Tess2_Sweep.topRightRegion(regUp);
			e = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp).eUp.get_Rprev();
			regLo.eUp = eLo.get_Oprev();
			eLo = hxGeomAlgo__$Tess2_Sweep.finishLeftRegions(tess,regLo,null);
			hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eLo.Onext,eUp.get_Rprev(),e,true);
			return true;
		}
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(dstUp,tess.event,isect) >= 0) {
			hxGeomAlgo__$Tess2_Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
			tess.mesh.splitEdge(eUp.Sym);
			eUp.Org.s = tess.event.s;
			eUp.Org.t = tess.event.t;
		}
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(dstLo,tess.event,isect) <= 0) {
			regUp.dirty = regLo.dirty = true;
			tess.mesh.splitEdge(eLo.Sym);
			eLo.Org.s = tess.event.s;
			eLo.Org.t = tess.event.t;
		}
		return false;
	}
	tess.mesh.splitEdge(eUp.Sym);
	tess.mesh.splitEdge(eLo.Sym);
	tess.mesh.splice(eLo.get_Oprev(),eUp);
	eUp.Org.s = isect.s;
	eUp.Org.t = isect.t;
	eUp.Org.pqHandle = tess.pq.insert(eUp.Org);
	hxGeomAlgo__$Tess2_Sweep.getIntersectData(tess,eUp.Org,orgUp,dstUp,orgLo,dstLo);
	hxGeomAlgo__$Tess2_Sweep.regionAbove(regUp).dirty = regUp.dirty = regLo.dirty = true;
	return false;
};
hxGeomAlgo__$Tess2_Sweep.walkDirtyRegions = function(tess,regUp) {
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eUp;
	var eLo;
	while(true) {
		while(regLo.dirty) {
			regUp = regLo;
			regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regLo);
		}
		if(!regUp.dirty) {
			regLo = regUp;
			regUp = hxGeomAlgo__$Tess2_Sweep.regionAbove(regUp);
			if(regUp == null || !regUp.dirty) {
				return;
			}
		}
		regUp.dirty = false;
		eUp = regUp.eUp;
		eLo = regLo.eUp;
		if(eUp.get_Dst() != eLo.get_Dst()) {
			if(hxGeomAlgo__$Tess2_Sweep.checkForLeftSplice(tess,regUp)) {
				if(regLo.fixUpperEdge) {
					hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,regLo);
					tess.mesh["delete"](eLo);
					regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
					eLo = regLo.eUp;
				} else if(regUp.fixUpperEdge) {
					hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,regUp);
					tess.mesh["delete"](eUp);
					regUp = hxGeomAlgo__$Tess2_Sweep.regionAbove(regLo);
					eUp = regUp.eUp;
				}
			}
		}
		if(eUp.Org != eLo.Org) {
			if(eUp.get_Dst() != eLo.get_Dst() && !regUp.fixUpperEdge && !regLo.fixUpperEdge && (eUp.get_Dst() == tess.event || eLo.get_Dst() == tess.event)) {
				if(hxGeomAlgo__$Tess2_Sweep.checkForIntersect(tess,regUp)) {
					return;
				}
			} else {
				hxGeomAlgo__$Tess2_Sweep.checkForRightSplice(tess,regUp);
			}
		}
		if(eUp.Org == eLo.Org && eUp.get_Dst() == eLo.get_Dst()) {
			hxGeomAlgo__$Tess2_Sweep.addWinding(eLo,eUp);
			hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,regUp);
			tess.mesh["delete"](eUp);
			regUp = hxGeomAlgo__$Tess2_Sweep.regionAbove(regLo);
		}
	}
};
hxGeomAlgo__$Tess2_Sweep.connectRightVertex = function(tess,regUp,eBottomLeft) {
	var eNew;
	var eTopLeft = eBottomLeft.Onext;
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eUp = regUp.eUp;
	var eLo = regLo.eUp;
	var degenerate = false;
	if(eUp.get_Dst() != eLo.get_Dst()) {
		hxGeomAlgo__$Tess2_Sweep.checkForIntersect(tess,regUp);
	}
	if(hxGeomAlgo__$Tess2_Geom.vertEq(eUp.Org,tess.event)) {
		tess.mesh.splice(eTopLeft.get_Oprev(),eUp);
		regUp = hxGeomAlgo__$Tess2_Sweep.topLeftRegion(tess,regUp);
		eTopLeft = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp).eUp;
		hxGeomAlgo__$Tess2_Sweep.finishLeftRegions(tess,hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp),regLo);
		degenerate = true;
	}
	if(hxGeomAlgo__$Tess2_Geom.vertEq(eLo.Org,tess.event)) {
		tess.mesh.splice(eBottomLeft,eLo.get_Oprev());
		eBottomLeft = hxGeomAlgo__$Tess2_Sweep.finishLeftRegions(tess,regLo,null);
		degenerate = true;
	}
	if(degenerate) {
		hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eBottomLeft.Onext,eTopLeft,eTopLeft,true);
		return;
	}
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(eLo.Org,eUp.Org)) {
		eNew = eLo.get_Oprev();
	} else {
		eNew = eUp;
	}
	eNew = tess.mesh.connect(eBottomLeft.get_Lprev(),eNew);
	hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eNew,eNew.Onext,eNew.Onext,false);
	eNew.Sym.activeRegion.fixUpperEdge = true;
	hxGeomAlgo__$Tess2_Sweep.walkDirtyRegions(tess,regUp);
};
hxGeomAlgo__$Tess2_Sweep.connectLeftDegenerate = function(tess,regUp,vEvent) {
	var e = regUp.eUp;
	if(hxGeomAlgo__$Tess2_Geom.vertEq(e.Org,vEvent)) {
		hxGeomAlgo_Debug.assert(false,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 2571, className : "hxGeomAlgo._Tess2.Sweep", methodName : "connectLeftDegenerate"});
		hxGeomAlgo__$Tess2_Sweep.spliceMergeVertices(tess,e,vEvent.anEdge);
		return;
	}
	if(!hxGeomAlgo__$Tess2_Geom.vertEq(e.get_Dst(),vEvent)) {
		tess.mesh.splitEdge(e.Sym);
		if(regUp.fixUpperEdge) {
			tess.mesh["delete"](e.Onext);
			regUp.fixUpperEdge = false;
		}
		tess.mesh.splice(vEvent.anEdge,e);
		hxGeomAlgo__$Tess2_Sweep.sweepEvent(tess,vEvent);
		return;
	}
	hxGeomAlgo_Debug.assert(false,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 2592, className : "hxGeomAlgo._Tess2.Sweep", methodName : "connectLeftDegenerate"});
	regUp = hxGeomAlgo__$Tess2_Sweep.topRightRegion(regUp);
	var reg = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eTopRight = reg.eUp.Sym;
	var eLast = eTopRight.Onext;
	var eTopLeft = eLast;
	if(reg.fixUpperEdge) {
		hxGeomAlgo_Debug.assert(eTopLeft != eTopRight,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 2601, className : "hxGeomAlgo._Tess2.Sweep", methodName : "connectLeftDegenerate"});
		hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,reg);
		tess.mesh["delete"](eTopRight);
		eTopRight = eTopLeft.get_Oprev();
	}
	tess.mesh.splice(vEvent.anEdge,eTopRight);
	if(!hxGeomAlgo__$Tess2_Geom.edgeGoesLeft(eTopLeft)) {
		eTopLeft = null;
	}
	hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eTopRight.Onext,eLast,eTopLeft,true);
};
hxGeomAlgo__$Tess2_Sweep.connectLeftVertex = function(tess,vEvent) {
	var eNew;
	var tmp = new hxGeomAlgo__$Tess2_ActiveRegion();
	tmp.eUp = vEvent.anEdge.Sym;
	var regUp = tess.dict.search(tmp).key;
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	if(regLo == null) {
		return;
	}
	var eUp = regUp.eUp;
	var eLo = regLo.eUp;
	if(hxGeomAlgo__$Tess2_Geom.edgeSign(eUp.get_Dst(),vEvent,eUp.Org) == 0.0) {
		hxGeomAlgo__$Tess2_Sweep.connectLeftDegenerate(tess,regUp,vEvent);
		return;
	}
	var reg = hxGeomAlgo__$Tess2_Geom.vertLeq(eLo.get_Dst(),eUp.get_Dst()) ? regUp : regLo;
	if(regUp.inside || reg.fixUpperEdge) {
		if(reg == regUp) {
			eNew = tess.mesh.connect(vEvent.anEdge.Sym,eUp.Lnext);
		} else {
			var tempHalfEdge = tess.mesh.connect(eLo.get_Dnext(),vEvent.anEdge);
			eNew = tempHalfEdge.Sym;
		}
		if(reg.fixUpperEdge) {
			hxGeomAlgo__$Tess2_Sweep.fixUpperEdge(tess,reg,eNew);
		} else {
			hxGeomAlgo__$Tess2_Sweep.computeWinding(tess,hxGeomAlgo__$Tess2_Sweep.addRegionBelow(tess,regUp,eNew));
		}
		hxGeomAlgo__$Tess2_Sweep.sweepEvent(tess,vEvent);
	} else {
		hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,vEvent.anEdge,vEvent.anEdge,null,true);
	}
};
hxGeomAlgo__$Tess2_Sweep.sweepEvent = function(tess,vEvent) {
	tess.event = vEvent;
	hxGeomAlgo__$Tess2_Sweep.debugEvent(tess);
	var e = vEvent.anEdge;
	while(e.activeRegion == null) {
		e = e.Onext;
		if(e == vEvent.anEdge) {
			hxGeomAlgo__$Tess2_Sweep.connectLeftVertex(tess,vEvent);
			return;
		}
	}
	var regUp = hxGeomAlgo__$Tess2_Sweep.topLeftRegion(tess,e.activeRegion);
	hxGeomAlgo_Debug.assert(regUp != null,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 2714, className : "hxGeomAlgo._Tess2.Sweep", methodName : "sweepEvent"});
	var reg = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eTopLeft = reg.eUp;
	var eBottomLeft = hxGeomAlgo__$Tess2_Sweep.finishLeftRegions(tess,reg,null);
	if(eBottomLeft.Onext == eTopLeft) {
		hxGeomAlgo__$Tess2_Sweep.connectRightVertex(tess,regUp,eBottomLeft);
	} else {
		hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eBottomLeft.Onext,eTopLeft,eTopLeft,true);
	}
};
hxGeomAlgo__$Tess2_Sweep.addSentinel = function(tess,smin,smax,t) {
	var reg = new hxGeomAlgo__$Tess2_ActiveRegion();
	var e = tess.mesh.makeEdge();
	e.Org.s = smax;
	e.Org.t = t;
	e.get_Dst().s = smin;
	e.get_Dst().t = t;
	tess.event = e.get_Dst();
	reg.eUp = e;
	reg.windingNumber = 0;
	reg.inside = false;
	reg.fixUpperEdge = false;
	reg.sentinel = true;
	reg.dirty = false;
	reg.nodeUp = tess.dict.insert(reg);
};
hxGeomAlgo__$Tess2_Sweep.initEdgeDict = function(tess) {
	tess.dict = new hxGeomAlgo__$Tess2_Dict(tess,hxGeomAlgo__$Tess2_Sweep.edgeLeq);
	var w = tess.bmax[0] - tess.bmin[0];
	var h = tess.bmax[1] - tess.bmin[1];
	var smin = tess.bmin[0] - w;
	var smax = tess.bmax[0] + w;
	var tmin = tess.bmin[1] - h;
	var tmax = tess.bmax[1] + h;
	hxGeomAlgo__$Tess2_Sweep.addSentinel(tess,smin,smax,tmin);
	hxGeomAlgo__$Tess2_Sweep.addSentinel(tess,smin,smax,tmax);
};
hxGeomAlgo__$Tess2_Sweep.doneEdgeDict = function(tess) {
	var reg;
	var fixedEdges = 0;
	while(true) {
		reg = tess.dict.min().key;
		if(!(reg != null)) {
			break;
		}
		if(!reg.sentinel) {
			hxGeomAlgo_Debug.assert(reg.fixUpperEdge,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 2796, className : "hxGeomAlgo._Tess2.Sweep", methodName : "doneEdgeDict"});
			hxGeomAlgo_Debug.assert(++fixedEdges == 1,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 2797, className : "hxGeomAlgo._Tess2.Sweep", methodName : "doneEdgeDict"});
		}
		hxGeomAlgo_Debug.assert(reg.windingNumber == 0,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 2799, className : "hxGeomAlgo._Tess2.Sweep", methodName : "doneEdgeDict"});
		hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,reg);
	}
};
hxGeomAlgo__$Tess2_Sweep.removeDegenerateEdges = function(tess) {
	var eNext;
	var eLnext;
	var eHead = tess.mesh.eHead;
	var e = eHead.next;
	while(e != eHead) {
		eNext = e.next;
		eLnext = e.Lnext;
		if(hxGeomAlgo__$Tess2_Geom.vertEq(e.Org,e.get_Dst()) && e.Lnext.Lnext != e) {
			hxGeomAlgo__$Tess2_Sweep.spliceMergeVertices(tess,eLnext,e);
			tess.mesh["delete"](e);
			e = eLnext;
			eLnext = e.Lnext;
		}
		if(eLnext.Lnext == e) {
			if(eLnext != e) {
				if(eLnext == eNext || eLnext == eNext.Sym) {
					eNext = eNext.next;
				}
				tess.mesh["delete"](eLnext);
			}
			if(e == eNext || e == eNext.Sym) {
				eNext = eNext.next;
			}
			tess.mesh["delete"](e);
		}
		e = eNext;
	}
};
hxGeomAlgo__$Tess2_Sweep.initPriorityQ = function(tess) {
	var vertexCount = 0;
	var vHead = tess.mesh.vHead;
	var v = vHead.next;
	while(v != vHead) {
		++vertexCount;
		v = v.next;
	}
	vertexCount += 8;
	var pq = tess.pq = new hxGeomAlgo__$Tess2_PriorityQ(vertexCount,hxGeomAlgo__$Tess2_Geom.vertLeq);
	vHead = tess.mesh.vHead;
	v = vHead.next;
	while(v != vHead) {
		v.pqHandle = pq.insert(v);
		v = v.next;
	}
	if(v != vHead) {
		return false;
	}
	pq.init();
	return true;
};
hxGeomAlgo__$Tess2_Sweep.donePriorityQ = function(tess) {
	tess.pq = null;
};
hxGeomAlgo__$Tess2_Sweep.removeDegenerateFaces = function(tess,mesh) {
	var fNext;
	var e;
	var f = mesh.fHead.next;
	while(f != mesh.fHead) {
		fNext = f.next;
		e = f.anEdge;
		hxGeomAlgo_Debug.assert(e.Lnext != e,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 2905, className : "hxGeomAlgo._Tess2.Sweep", methodName : "removeDegenerateFaces"});
		if(e.Lnext.Lnext == e) {
			hxGeomAlgo__$Tess2_Sweep.addWinding(e.Onext,e);
			tess.mesh["delete"](e);
		}
		f = fNext;
	}
	return true;
};
hxGeomAlgo__$Tess2_Sweep.computeInterior = function(tess) {
	var v;
	var vNext;
	hxGeomAlgo__$Tess2_Sweep.removeDegenerateEdges(tess);
	if(!hxGeomAlgo__$Tess2_Sweep.initPriorityQ(tess)) {
		return false;
	}
	hxGeomAlgo__$Tess2_Sweep.initEdgeDict(tess);
	var pq = tess.pq;
	while(true) {
		v = tess.pq.extractMin();
		if(!(v != null)) {
			break;
		}
		while(true) {
			vNext = tess.pq.min();
			if(vNext == null || !hxGeomAlgo__$Tess2_Geom.vertEq(vNext,v)) {
				break;
			}
			vNext = tess.pq.extractMin();
			hxGeomAlgo__$Tess2_Sweep.spliceMergeVertices(tess,v.anEdge,vNext.anEdge);
		}
		hxGeomAlgo__$Tess2_Sweep.sweepEvent(tess,v);
	}
	tess.event = tess.dict.min().key.eUp.Org;
	hxGeomAlgo__$Tess2_Sweep.debugEvent(tess);
	hxGeomAlgo__$Tess2_Sweep.doneEdgeDict(tess);
	hxGeomAlgo__$Tess2_Sweep.donePriorityQ(tess);
	if(!hxGeomAlgo__$Tess2_Sweep.removeDegenerateFaces(tess,tess.mesh)) {
		return false;
	}
	tess.mesh.check();
	return true;
};
var hxGeomAlgo_Tesselator = $hx_exports["hxGeomAlgo"]["Tesselator"] = function() {
	this.elementCount = 0;
	this.elements = [];
	this.vertexCount = 0;
	this.vertexIndices = [];
	this.vertices = [];
	this.vertexIndexCounter = 0;
	this.event = null;
	this.pq = null;
	this.dict = null;
	this.bmax = [0.0,0.0];
	this.bmin = [0.0,0.0];
	this.tUnit = [0.0,0.0,0.0];
	this.sUnit = [0.0,0.0,0.0];
	this.normal = [0.0,0.0,0.0];
	this.mesh = null;
	this.windingRule = hxGeomAlgo_WindingRule.ODD;
};
hxGeomAlgo_Tesselator.__name__ = true;
hxGeomAlgo_Tesselator.prototype = {
	dot_: function(u,v) {
		return u[0] * v[0] + u[1] * v[1] + u[2] * v[2];
	}
	,normalize_: function(v) {
		var len = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
		hxGeomAlgo_Debug.assert(len > 0.0,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 3031, className : "hxGeomAlgo.Tesselator", methodName : "normalize_"});
		len = Math.sqrt(len);
		v[0] /= len;
		v[1] /= len;
		v[2] /= len;
	}
	,longAxis_: function(v) {
		var i = 0;
		if(Math.abs(v[1]) > Math.abs(v[0])) {
			i = 1;
		}
		if(Math.abs(v[2]) > Math.abs(v[i])) {
			i = 2;
		}
		return i;
	}
	,computeNormal_: function(norm) {
		var c;
		var tLen2;
		var maxVal = [.0,.0,.0];
		var minVal = [.0,.0,.0];
		var d1 = [.0,.0,.0];
		var d2_0 = .0;
		var d2_1 = .0;
		var d2_2 = .0;
		var tNorm_0 = .0;
		var tNorm_1 = .0;
		var tNorm_2 = .0;
		var maxVert = [null,null,null];
		var minVert = [null,null,null];
		var vHead = this.mesh.vHead;
		var v = vHead.next;
		c = v.coords[0];
		minVal[0] = c;
		minVert[0] = v;
		maxVal[0] = c;
		maxVert[0] = v;
		c = v.coords[1];
		minVal[1] = c;
		minVert[1] = v;
		maxVal[1] = c;
		maxVert[1] = v;
		c = v.coords[2];
		minVal[2] = c;
		minVert[2] = v;
		maxVal[2] = c;
		maxVert[2] = v;
		v = vHead.next;
		while(v != vHead) {
			c = v.coords[0];
			if(c < minVal[0]) {
				minVal[0] = c;
				minVert[0] = v;
			}
			if(c > maxVal[0]) {
				maxVal[0] = c;
				maxVert[0] = v;
			}
			c = v.coords[1];
			if(c < minVal[1]) {
				minVal[1] = c;
				minVert[1] = v;
			}
			if(c > maxVal[1]) {
				maxVal[1] = c;
				maxVert[1] = v;
			}
			c = v.coords[2];
			if(c < minVal[2]) {
				minVal[2] = c;
				minVert[2] = v;
			}
			if(c > maxVal[2]) {
				maxVal[2] = c;
				maxVert[2] = v;
			}
			v = v.next;
		}
		var i = 0;
		if(maxVal[1] - minVal[1] > maxVal[0] - minVal[0]) {
			i = 1;
		}
		if(maxVal[2] - minVal[2] > maxVal[i] - minVal[i]) {
			i = 2;
		}
		if(minVal[i] >= maxVal[i]) {
			norm[0] = 0;
			norm[1] = 0;
			norm[2] = 1;
			return;
		}
		var maxLen2 = .0;
		var v1 = minVert[i];
		var v2 = maxVert[i];
		d1[0] = v1.coords[0] - v2.coords[0];
		d1[1] = v1.coords[1] - v2.coords[1];
		d1[2] = v1.coords[2] - v2.coords[2];
		v = vHead.next;
		while(v != vHead) {
			d2_0 = v.coords[0] - v2.coords[0];
			d2_1 = v.coords[1] - v2.coords[1];
			d2_2 = v.coords[2] - v2.coords[2];
			tNorm_0 = d1[1] * d2_2 - d1[2] * d2_1;
			tNorm_1 = d1[2] * d2_0 - d1[0] * d2_2;
			tNorm_2 = d1[0] * d2_1 - d1[1] * d2_0;
			tLen2 = tNorm_0 * tNorm_0 + tNorm_1 * tNorm_1 + tNorm_2 * tNorm_2;
			if(tLen2 > maxLen2) {
				maxLen2 = tLen2;
				norm[0] = tNorm_0;
				norm[1] = tNorm_1;
				norm[2] = tNorm_2;
			}
			v = v.next;
		}
		if(maxLen2 <= 0) {
			norm[0] = norm[1] = norm[2] = 0;
			norm[this.longAxis_(d1)] = 1;
		}
	}
	,checkOrientation_: function() {
		var fHead = this.mesh.fHead;
		var v;
		var vHead = this.mesh.vHead;
		var e;
		var area = .0;
		var f = fHead.next;
		while(f != fHead) {
			e = f.anEdge;
			if(e.winding <= 0) {
				f = f.next;
				continue;
			}
			while(true) {
				area += (e.Org.s - e.get_Dst().s) * (e.Org.t + e.get_Dst().t);
				e = e.Lnext;
				if(!(e != f.anEdge)) {
					break;
				}
			}
			f = f.next;
		}
		if(area < 0) {
			v = vHead.next;
			while(v != vHead) {
				v.t = -v.t;
				v = v.next;
			}
			this.tUnit[0] = -this.tUnit[0];
			this.tUnit[1] = -this.tUnit[1];
			this.tUnit[2] = -this.tUnit[2];
		}
	}
	,projectPolygon_: function() {
		var vHead = this.mesh.vHead;
		var norm = [.0,.0,.0];
		var computedNormal = false;
		norm[0] = this.normal[0];
		norm[1] = this.normal[1];
		norm[2] = this.normal[2];
		if(norm[0] == 0.0 && norm[1] == 0.0 && norm[2] == 0.0) {
			this.computeNormal_(norm);
			computedNormal = true;
		}
		var sUnit = this.sUnit;
		var tUnit = this.tUnit;
		var i = this.longAxis_(norm);
		sUnit[i] = 0;
		sUnit[(i + 1) % 3] = 1.0;
		sUnit[(i + 2) % 3] = 0.0;
		tUnit[i] = 0;
		tUnit[(i + 1) % 3] = 0.0;
		tUnit[(i + 2) % 3] = norm[i] > 0 ? 1.0 : -1.0;
		var v = vHead.next;
		while(v != vHead) {
			v.s = this.dot_(v.coords,sUnit);
			v.t = this.dot_(v.coords,tUnit);
			v = v.next;
		}
		if(computedNormal) {
			this.checkOrientation_();
		}
		var first = true;
		v = vHead.next;
		while(v != vHead) {
			if(first) {
				var tmp = this.bmax[0] = v.s;
				this.bmin[0] = tmp;
				var tmp1 = this.bmax[1] = v.t;
				this.bmin[1] = tmp1;
				first = false;
			} else {
				if(v.s < this.bmin[0]) {
					this.bmin[0] = v.s;
				}
				if(v.s > this.bmax[0]) {
					this.bmax[0] = v.s;
				}
				if(v.t < this.bmin[1]) {
					this.bmin[1] = v.t;
				}
				if(v.t > this.bmax[1]) {
					this.bmax[1] = v.t;
				}
			}
			v = v.next;
		}
	}
	,addWinding_: function(eDst,eSrc) {
		eDst.winding += eSrc.winding;
		eDst.Sym.winding += eSrc.Sym.winding;
	}
	,tessellateMonoRegion_: function(mesh,face) {
		var up = face.anEdge;
		hxGeomAlgo_Debug.assert(up.Lnext != up && up.Lnext.Lnext != up,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 3303, className : "hxGeomAlgo.Tesselator", methodName : "tessellateMonoRegion_"});
		while(hxGeomAlgo__$Tess2_Geom.vertLeq(up.get_Dst(),up.Org)) up = up.get_Lprev();
		while(hxGeomAlgo__$Tess2_Geom.vertLeq(up.Org,up.get_Dst())) up = up.Lnext;
		var lo = up.get_Lprev();
		while(up.Lnext != lo) if(hxGeomAlgo__$Tess2_Geom.vertLeq(up.get_Dst(),lo.Org)) {
			while(lo.Lnext != up && (hxGeomAlgo__$Tess2_Geom.edgeGoesLeft(lo.Lnext) || hxGeomAlgo__$Tess2_Geom.edgeSign(lo.Org,lo.get_Dst(),lo.Lnext.get_Dst()) <= 0.0)) {
				var tempHalfEdge = mesh.connect(lo.Lnext,lo);
				lo = tempHalfEdge.Sym;
			}
			lo = lo.get_Lprev();
		} else {
			while(lo.Lnext != up && (hxGeomAlgo__$Tess2_Geom.edgeGoesRight(up.get_Lprev()) || hxGeomAlgo__$Tess2_Geom.edgeSign(up.get_Dst(),up.Org,up.get_Lprev().Org) >= 0.0)) {
				var tempHalfEdge1 = mesh.connect(up,up.get_Lprev());
				up = tempHalfEdge1.Sym;
			}
			up = up.Lnext;
		}
		hxGeomAlgo_Debug.assert(lo.Lnext != up,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 3340, className : "hxGeomAlgo.Tesselator", methodName : "tessellateMonoRegion_"});
		while(lo.Lnext.Lnext != up) {
			var tempHalfEdge2 = mesh.connect(lo.Lnext,lo);
			lo = tempHalfEdge2.Sym;
		}
		return true;
	}
	,tessellateInterior_: function(mesh) {
		var next;
		var f = mesh.fHead.next;
		while(f != mesh.fHead) {
			next = f.next;
			if(f.inside) {
				if(!this.tessellateMonoRegion_(mesh,f)) {
					return false;
				}
			}
			f = next;
		}
		return true;
	}
	,refineDelaunay_: function(mesh) {
		var stack = [];
		var e;
		var edges_0 = null;
		var edges_1 = null;
		var edges_2 = null;
		var edges_3 = null;
		var f = mesh.fHead.next;
		while(f != mesh.fHead) {
			if(f.inside) {
				e = f.anEdge;
				while(true) {
					e.mark = hxGeomAlgo__$Tess2_Geom.edgeIsInternal(e);
					if(e.mark && !e.Sym.mark) {
						stack.push(e);
					}
					e = e.Lnext;
					if(!(e != f.anEdge)) {
						break;
					}
				}
			}
			f = f.next;
		}
		while(stack.length > 0) {
			e = stack.pop();
			e.mark = e.Sym.mark = false;
			if(!hxGeomAlgo__$Tess2_Geom.edgeIsLocallyDelaunay(e)) {
				hxGeomAlgo__$Tess2_TessMesh.flipEdge(mesh,e);
				edges_0 = e.Lnext;
				edges_1 = e.get_Lprev();
				edges_2 = e.Sym.Lnext;
				edges_3 = e.Sym.get_Lprev();
				if(!edges_0.mark && hxGeomAlgo__$Tess2_Geom.edgeIsInternal(edges_0)) {
					edges_0.mark = edges_0.Sym.mark = true;
					stack.push(edges_0);
				}
				if(!edges_1.mark && hxGeomAlgo__$Tess2_Geom.edgeIsInternal(edges_1)) {
					edges_1.mark = edges_1.Sym.mark = true;
					stack.push(edges_1);
				}
				if(!edges_2.mark && hxGeomAlgo__$Tess2_Geom.edgeIsInternal(edges_2)) {
					edges_2.mark = edges_2.Sym.mark = true;
					stack.push(edges_2);
				}
			}
		}
		var _g = 0;
		while(_g < stack.length) {
			var e1 = stack[_g];
			++_g;
			stack.pop();
		}
		stack = null;
	}
	,discardExterior_: function(mesh) {
		var next;
		var f = mesh.fHead.next;
		while(f != mesh.fHead) {
			next = f.next;
			if(!f.inside) {
				mesh.zapFace(f);
			}
			f = next;
		}
	}
	,setWindingNumber_: function(mesh,value,keepOnlyBoundary) {
		var eNext;
		var e = mesh.eHead.next;
		while(e != mesh.eHead) {
			eNext = e.next;
			if(e.get_Rface().inside != e.Lface.inside) {
				e.winding = e.Lface.inside ? value : -value;
			} else if(!keepOnlyBoundary) {
				e.winding = 0;
			} else {
				mesh["delete"](e);
			}
			e = eNext;
		}
	}
	,getNeighbourFace_: function(edge) {
		if(edge.get_Rface() == null) {
			return -1;
		}
		if(!edge.get_Rface().inside) {
			return -1;
		}
		return edge.get_Rface().n;
	}
	,outputPolymesh_: function(mesh,resultsType,polySize,vertexDim) {
		var edge;
		var maxFaceCount = 0;
		var maxVertexCount = 0;
		var faceVerts;
		var i;
		var elements = 0;
		var vert;
		if(polySize > 3) {
			mesh.mergeConvexFaces(polySize);
		}
		var v = mesh.vHead.next;
		while(v != mesh.vHead) {
			v.n = -1;
			v = v.next;
		}
		var f = mesh.fHead.next;
		while(f != mesh.fHead) {
			f.n = -1;
			if(!f.inside) {
				f = f.next;
				continue;
			}
			edge = f.anEdge;
			faceVerts = 0;
			while(true) {
				v = edge.Org;
				if(v.n == -1) {
					v.n = maxVertexCount;
					++maxVertexCount;
				}
				++faceVerts;
				edge = edge.Lnext;
				if(!(edge != f.anEdge)) {
					break;
				}
			}
			hxGeomAlgo_Debug.assert(faceVerts <= polySize,null,{ fileName : "hxGeomAlgo/Tess2.hx", lineNumber : 3544, className : "hxGeomAlgo.Tesselator", methodName : "outputPolymesh_"});
			f.n = maxFaceCount;
			++maxFaceCount;
			f = f.next;
		}
		this.elementCount = maxFaceCount;
		if(resultsType == hxGeomAlgo_ResultType.CONNECTED_POLYGONS) {
			maxFaceCount *= 2;
		}
		this.elements = [];
		this.vertexCount = maxVertexCount;
		this.vertices = [];
		this.vertexIndices = [];
		v = mesh.vHead.next;
		while(v != mesh.vHead) {
			if(v.n != -1) {
				var idx = v.n * vertexDim;
				this.vertices[idx] = v.coords[0];
				this.vertices[idx + 1] = v.coords[1];
				if(vertexDim > 2) {
					this.vertices[idx + 2] = v.coords[2];
				}
				this.vertexIndices[v.n] = v.idx;
			}
			v = v.next;
		}
		var nel = 0;
		f = mesh.fHead.next;
		while(f != mesh.fHead) {
			if(!f.inside) {
				f = f.next;
				continue;
			}
			edge = f.anEdge;
			faceVerts = 0;
			while(true) {
				v = edge.Org;
				this.elements[nel++] = v.n;
				++faceVerts;
				edge = edge.Lnext;
				if(!(edge != f.anEdge)) {
					break;
				}
			}
			var _g = faceVerts;
			var _g1 = polySize;
			while(_g < _g1) {
				var i1 = _g++;
				this.elements[nel++] = -1;
			}
			if(resultsType == hxGeomAlgo_ResultType.CONNECTED_POLYGONS) {
				edge = f.anEdge;
				while(true) {
					this.elements[nel++] = this.getNeighbourFace_(edge);
					edge = edge.Lnext;
					if(!(edge != f.anEdge)) {
						break;
					}
				}
				var _g2 = faceVerts;
				var _g3 = polySize;
				while(_g2 < _g3) {
					var i2 = _g2++;
					this.elements[nel++] = -1;
				}
			}
			f = f.next;
		}
	}
	,outputContours_: function(mesh,vertexDim) {
		var edge;
		var start;
		var verts;
		var elements;
		var vertInds;
		var startVert = 0;
		var vertCount = 0;
		this.vertexCount = 0;
		this.elementCount = 0;
		var f = mesh.fHead.next;
		while(f != mesh.fHead) {
			if(!f.inside) {
				f = f.next;
				continue;
			}
			edge = f.anEdge;
			start = edge;
			while(true) {
				this.vertexCount++;
				edge = edge.Lnext;
				if(!(edge != start)) {
					break;
				}
			}
			this.elementCount++;
			f = f.next;
		}
		this.elements = [];
		this.vertices = [];
		this.vertexIndices = [];
		var nv = 0;
		var nvi = 0;
		var nel = 0;
		startVert = 0;
		f = mesh.fHead.next;
		while(f != mesh.fHead) {
			if(!f.inside) {
				f = f.next;
				continue;
			}
			vertCount = 0;
			edge = f.anEdge;
			start = edge;
			while(true) {
				this.vertices[nv++] = edge.Org.coords[0];
				this.vertices[nv++] = edge.Org.coords[1];
				if(vertexDim > 2) {
					this.vertices[nv++] = edge.Org.coords[2];
				}
				this.vertexIndices[nvi++] = edge.Org.idx;
				++vertCount;
				edge = edge.Lnext;
				if(!(edge != start)) {
					break;
				}
			}
			this.elements[nel++] = startVert;
			this.elements[nel++] = vertCount;
			startVert += vertCount;
			f = f.next;
		}
	}
	,addContour: function(vertexDim,vertices) {
		if(this.mesh == null) {
			this.mesh = new hxGeomAlgo__$Tess2_TessMesh();
		}
		if(vertexDim < 2) {
			vertexDim = 2;
		}
		if(vertexDim > 3) {
			vertexDim = 3;
		}
		var e = null;
		var i = 0;
		while(i < vertices.length) {
			if(e == null) {
				e = this.mesh.makeEdge();
				this.mesh.splice(e,e.Sym);
			} else {
				this.mesh.splitEdge(e);
				e = e.Lnext;
			}
			e.Org.coords[0] = vertices[i];
			e.Org.coords[1] = vertices[i + 1];
			if(vertexDim > 2) {
				e.Org.coords[2] = vertices[i + 2];
			} else {
				e.Org.coords[2] = 0.0;
			}
			e.Org.idx = this.vertexIndexCounter++;
			e.winding = 1;
			e.Sym.winding = -1;
			i += vertexDim;
		}
	}
	,tesselate: function(windingRule,resultType,polySize,vertexDim,normal) {
		this.vertices = [];
		this.elements = [];
		this.vertexIndices = [];
		this.vertexIndexCounter = 0;
		if(normal != null) {
			this.normal[0] = normal[0];
			this.normal[1] = normal[1];
			this.normal[2] = normal[2];
		}
		this.windingRule = windingRule;
		if(vertexDim < 2) {
			vertexDim = 2;
		}
		if(vertexDim > 3) {
			vertexDim = 3;
		}
		if(this.mesh == null) {
			return false;
		}
		this.projectPolygon_();
		hxGeomAlgo__$Tess2_Sweep.computeInterior(this);
		var mesh = this.mesh;
		if(resultType == hxGeomAlgo_ResultType.BOUNDARY_CONTOURS) {
			this.setWindingNumber_(mesh,1,true);
		} else {
			this.tessellateInterior_(mesh);
			if(resultType == hxGeomAlgo_ResultType.EXPERIMENTAL_DELAUNAY) {
				this.refineDelaunay_(mesh);
				polySize = 3;
			}
		}
		mesh.check();
		if(resultType == hxGeomAlgo_ResultType.BOUNDARY_CONTOURS) {
			this.outputContours_(mesh,vertexDim);
		} else {
			this.outputPolymesh_(mesh,resultType,polySize,vertexDim);
		}
		return true;
	}
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s += "\t";
				var tmp = n + "(";
				var _g = [];
				var _g1 = 0;
				var _g2 = con.__params__;
				while(_g1 < _g2.length) {
					var p = _g2[_g1];
					++_g1;
					_g.push(js_Boot.__string_rec(o[p],s));
				}
				return tmp + _g.join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var l = o.length;
			var i;
			var str = "[";
			s += "\t";
			var _g3 = 0;
			var _g11 = l;
			while(_g3 < _g11) {
				var i1 = _g3++;
				str += (i1 > 0 ? "," : "") + js_Boot.__string_rec(o[i1],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e1 ) {
			var e2 = ((e1) instanceof js__$Boot_HaxeError) ? e1.val : e1;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str1 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str1.length != 2) {
			str1 += ", \n";
		}
		str1 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str1 += "\n" + s + "}";
		return str1;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var js_html__$CanvasElement_CanvasUtil = function() { };
js_html__$CanvasElement_CanvasUtil.__name__ = true;
js_html__$CanvasElement_CanvasUtil.getContextWebGL = function(canvas,attribs) {
	var name = "webgl";
	var ctx = canvas.getContext(name,attribs);
	if(ctx != null) {
		return ctx;
	}
	var name1 = "experimental-webgl";
	var ctx1 = canvas.getContext(name1,attribs);
	if(ctx1 != null) {
		return ctx1;
	}
	return null;
};
var khaMath_Matrix4 = function(_00,_10,_20,_30,_01,_11,_21,_31,_02,_12,_22,_32,_03,_13,_23,_33) {
	this._00 = _00;
	this._10 = _10;
	this._20 = _20;
	this._30 = _30;
	this._01 = _01;
	this._11 = _11;
	this._21 = _21;
	this._31 = _31;
	this._02 = _02;
	this._12 = _12;
	this._22 = _22;
	this._32 = _32;
	this._03 = _03;
	this._13 = _13;
	this._23 = _23;
	this._33 = _33;
};
khaMath_Matrix4.__name__ = true;
khaMath_Matrix4.orthogonalProjection = function(left,right,bottom,top,zn,zf) {
	var tx = -(right + left) / (right - left);
	var ty = -(top + bottom) / (top - bottom);
	var tz = -(zf + zn) / (zf - zn);
	return new khaMath_Matrix4(2 / (right - left),0,0,tx,0,2 / (top - bottom),0,ty,0,0,-2 / (zf - zn),tz,0,0,0,1);
};
khaMath_Matrix4.perspectiveProjection = function(fovY,aspect,zn,zf) {
	var uh = 1.0 / Math.tan(fovY / 2 * (Math.PI / 180));
	var uw = uh / aspect;
	return new khaMath_Matrix4(uw,0,0,0,0,uh,0,0,0,0,(zf + zn) / (zn - zf),2 * zf * zn / (zn - zf),0,0,-1,0);
};
khaMath_Matrix4.lookAt = function(eye,at,up) {
	var zaxis = new khaMath_Vector3(at.x - eye.x,at.y - eye.y,at.z - eye.z);
	zaxis.set_length(1);
	var _x = zaxis.y * up.z - zaxis.z * up.y;
	var _y = zaxis.z * up.x - zaxis.x * up.z;
	var _z = zaxis.x * up.y - zaxis.y * up.x;
	var xaxis = new khaMath_Vector3(_x,_y,_z);
	xaxis.set_length(1);
	var _x1 = xaxis.y * zaxis.z - xaxis.z * zaxis.y;
	var _y1 = xaxis.z * zaxis.x - xaxis.x * zaxis.z;
	var _z1 = xaxis.x * zaxis.y - xaxis.y * zaxis.x;
	var yaxis_x = _x1;
	var yaxis_y = _y1;
	var yaxis_z = _z1;
	return new khaMath_Matrix4(xaxis.x,xaxis.y,xaxis.z,-(xaxis.x * eye.x + xaxis.y * eye.y + xaxis.z * eye.z),yaxis_x,yaxis_y,yaxis_z,-(yaxis_x * eye.x + yaxis_y * eye.y + yaxis_z * eye.z),-zaxis.x,-zaxis.y,-zaxis.z,zaxis.x * eye.x + zaxis.y * eye.y + zaxis.z * eye.z,0,0,0,1);
};
var khaMath_Vector3 = function(x,y,z) {
	if(z == null) {
		z = 0;
	}
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
	this.z = z;
};
khaMath_Vector3.__name__ = true;
khaMath_Vector3.prototype = {
	get_length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	}
	,set_length: function(length) {
		var currentLength = this.get_length();
		if(currentLength == 0) {
			return 0;
		}
		var mul = length / currentLength;
		this.x *= mul;
		this.y *= mul;
		this.z *= mul;
		return length;
	}
};
var khaMath_Vector4 = function(x,y,z,w) {
	if(w == null) {
		w = 1;
	}
	if(z == null) {
		z = 0;
	}
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
	this.z = z;
	this.w = w;
};
khaMath_Vector4.__name__ = true;
khaMath_Vector4.prototype = {
	get_length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	}
	,set_length: function(length) {
		var currentLength = this.get_length();
		if(currentLength == 0) {
			return 0;
		}
		var mul = length / currentLength;
		this.x *= mul;
		this.y *= mul;
		this.z *= mul;
		this.w *= mul;
		return length;
	}
};
var shaders_Shaders = function() { };
shaders_Shaders.__name__ = true;
var trilateral_angle_DifferencePreference = $hxEnums["trilateral.angle.DifferencePreference"] = { __ename__ : "trilateral.angle.DifferencePreference", __constructs__ : ["CLOCKWISE","ANTICLOCKWISE","SMALL","LARGE"]
	,CLOCKWISE: {_hx_index:0,__enum__:"trilateral.angle.DifferencePreference",toString:$estr}
	,ANTICLOCKWISE: {_hx_index:1,__enum__:"trilateral.angle.DifferencePreference",toString:$estr}
	,SMALL: {_hx_index:2,__enum__:"trilateral.angle.DifferencePreference",toString:$estr}
	,LARGE: {_hx_index:3,__enum__:"trilateral.angle.DifferencePreference",toString:$estr}
};
var trilateral_angle_Angles = function() { };
trilateral_angle_Angles.__name__ = true;
trilateral_angle_Angles.pi2pi = function(angle) {
	if(angle <= Math.PI && angle > -Math.PI) {
		return angle;
	} else {
		var a = (angle + Math.PI) % (2 * Math.PI);
		if(a >= 0) {
			return a - Math.PI;
		} else {
			return a + Math.PI;
		}
	}
};
trilateral_angle_Angles.zeroto2pi = function(angle) {
	if(angle >= 0 && angle > Math.PI) {
		return angle;
	} else {
		var a = angle % (2 * Math.PI);
		if(a >= 0) {
			return a;
		} else {
			return a + 2 * Math.PI;
		}
	}
};
trilateral_angle_Angles.zerotoMinus2pi = function(angle) {
	if(angle <= 0 && angle > -Math.PI) {
		return angle;
	} else {
		var a = angle % (2 * Math.PI);
		var a1 = a >= 0 ? a : a + 2 * Math.PI;
		return -(Math.PI * 2 - a1);
	}
};
trilateral_angle_Angles.differencePrefer = function(a,b,prefer) {
	switch(prefer._hx_index) {
	case 0:
		var f;
		if(a >= 0 && a > Math.PI) {
			f = a;
		} else {
			var a1 = a % (2 * Math.PI);
			f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this1 = f;
		var za = this1;
		var f1;
		if(b >= 0 && b > Math.PI) {
			f1 = b;
		} else {
			var a2 = b % (2 * Math.PI);
			f1 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
		}
		var this2 = f1;
		var zb = this2;
		var fa = za;
		var fb = zb;
		var theta = Math.abs(a - b);
		var clockwise = a < b;
		var dif = clockwise ? theta : -theta;
		if(dif > 0) {
			return dif;
		} else {
			return 2 * Math.PI + dif;
		}
		break;
	case 1:
		var f2;
		if(a >= 0 && a > Math.PI) {
			f2 = a;
		} else {
			var a3 = a % (2 * Math.PI);
			f2 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
		}
		var this3 = f2;
		var za1 = this3;
		var f3;
		if(b >= 0 && b > Math.PI) {
			f3 = b;
		} else {
			var a4 = b % (2 * Math.PI);
			f3 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
		}
		var this4 = f3;
		var zb1 = this4;
		var fa1 = za1;
		var fb1 = zb1;
		var theta1 = Math.abs(a - b);
		var clockwise1 = a < b;
		var dif1 = clockwise1 ? theta1 : -theta1;
		if(dif1 < 0) {
			return dif1;
		} else {
			return -2 * Math.PI + dif1;
		}
		break;
	case 2:
		var f4;
		if(a >= 0 && a > Math.PI) {
			f4 = a;
		} else {
			var a5 = a % (2 * Math.PI);
			f4 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
		}
		var this5 = f4;
		var za2 = this5;
		var f5;
		if(b >= 0 && b > Math.PI) {
			f5 = b;
		} else {
			var a6 = b % (2 * Math.PI);
			f5 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
		}
		var this6 = f5;
		var zb2 = this6;
		var fa2 = a;
		var fb2 = b;
		var theta2 = Math.abs(a - b);
		var smallest = theta2 <= Math.PI;
		var clockwise2 = a < b;
		var dif2 = clockwise2 ? theta2 : -theta2;
		if(smallest) {
			return dif2;
		} else if(clockwise2) {
			return -(2 * Math.PI - theta2);
		} else {
			return 2 * Math.PI - theta2;
		}
		break;
	case 3:
		var f6;
		if(a >= 0 && a > Math.PI) {
			f6 = a;
		} else {
			var a7 = a % (2 * Math.PI);
			f6 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
		}
		var this7 = f6;
		var za3 = this7;
		var f7;
		if(b >= 0 && b > Math.PI) {
			f7 = b;
		} else {
			var a8 = b % (2 * Math.PI);
			f7 = a8 >= 0 ? a8 : a8 + 2 * Math.PI;
		}
		var this8 = f7;
		var zb3 = this8;
		var fa3 = a;
		var fb3 = b;
		var theta3 = Math.abs(a - b);
		var largest = theta3 > Math.PI;
		var clockwise3 = a < b;
		var dif3 = clockwise3 ? theta3 : -theta3;
		if(largest) {
			return dif3;
		} else if(clockwise3) {
			return -(2 * Math.PI - theta3);
		} else {
			return 2 * Math.PI - theta3;
		}
		break;
	}
};
trilateral_angle_Angles.difference = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
	}
	var this1 = f;
	var za = this1;
	var f1;
	if(b >= 0 && b > Math.PI) {
		f1 = b;
	} else {
		var a2 = b % (2 * Math.PI);
		f1 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
	}
	var this2 = f1;
	var zb = this2;
	var fa = za;
	var fb = zb;
	var theta = Math.abs(a - b);
	var clockwise = a < b;
	if(clockwise) {
		return theta;
	} else {
		return -theta;
	}
};
trilateral_angle_Angles.differenceClockWise = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
	}
	var this1 = f;
	var za = this1;
	var f1;
	if(b >= 0 && b > Math.PI) {
		f1 = b;
	} else {
		var a2 = b % (2 * Math.PI);
		f1 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
	}
	var this2 = f1;
	var zb = this2;
	var fa = za;
	var fb = zb;
	var theta = Math.abs(a - b);
	var clockwise = a < b;
	var dif = clockwise ? theta : -theta;
	if(dif > 0) {
		return dif;
	} else {
		return 2 * Math.PI + dif;
	}
};
trilateral_angle_Angles.differenceAntiClockwise = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
	}
	var this1 = f;
	var za = this1;
	var f1;
	if(b >= 0 && b > Math.PI) {
		f1 = b;
	} else {
		var a2 = b % (2 * Math.PI);
		f1 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
	}
	var this2 = f1;
	var zb = this2;
	var fa = za;
	var fb = zb;
	var theta = Math.abs(a - b);
	var clockwise = a < b;
	var dif = clockwise ? theta : -theta;
	if(dif < 0) {
		return dif;
	} else {
		return -2 * Math.PI + dif;
	}
};
trilateral_angle_Angles.differenceSmall = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
	}
	var this1 = f;
	var za = this1;
	var f1;
	if(b >= 0 && b > Math.PI) {
		f1 = b;
	} else {
		var a2 = b % (2 * Math.PI);
		f1 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
	}
	var this2 = f1;
	var zb = this2;
	var fa = a;
	var fb = b;
	var theta = Math.abs(a - b);
	var smallest = theta <= Math.PI;
	var clockwise = a < b;
	var dif = clockwise ? theta : -theta;
	if(smallest) {
		return dif;
	} else if(clockwise) {
		return -(2 * Math.PI - theta);
	} else {
		return 2 * Math.PI - theta;
	}
};
trilateral_angle_Angles.differenceLarge = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
	}
	var this1 = f;
	var za = this1;
	var f1;
	if(b >= 0 && b > Math.PI) {
		f1 = b;
	} else {
		var a2 = b % (2 * Math.PI);
		f1 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
	}
	var this2 = f1;
	var zb = this2;
	var fa = a;
	var fb = b;
	var theta = Math.abs(a - b);
	var largest = theta > Math.PI;
	var clockwise = a < b;
	var dif = clockwise ? theta : -theta;
	if(largest) {
		return dif;
	} else if(clockwise) {
		return -(2 * Math.PI - theta);
	} else {
		return 2 * Math.PI - theta;
	}
};
trilateral_angle_Angles.differenceSmallLarge = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		f = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
	}
	var this1 = f;
	var za = this1;
	var f1;
	if(b >= 0 && b > Math.PI) {
		f1 = b;
	} else {
		var a2 = b % (2 * Math.PI);
		f1 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
	}
	var this2 = f1;
	var zb = this2;
	var fa = a;
	var fb = b;
	var theta = Math.abs(a - b);
	var smallest = theta <= Math.PI;
	var clockwise = a < b;
	var dif = clockwise ? theta : -theta;
	var other = clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
	if(smallest) {
		return { small : dif, large : other};
	} else {
		return { small : other, large : dif};
	}
};
var trilateral_angle__$Fraction_FractionArray_$Impl_$ = {};
trilateral_angle__$Fraction_FractionArray_$Impl_$.__name__ = true;
trilateral_angle__$Fraction_FractionArray_$Impl_$._new = function(val) {
	var this1 = val == null ? [] : val;
	return this1;
};
trilateral_angle__$Fraction_FractionArray_$Impl_$.add = function(this1,val) {
	this1[this1.length] = val;
};
trilateral_angle__$Fraction_FractionArray_$Impl_$.toString = function(this1) {
	var l = this1.length;
	var str = "";
	var _g = 0;
	var _g1 = l;
	while(_g < _g1) {
		var i = _g++;
		var this2 = this1[i];
		var n = this2.numerator;
		var d = this2.denominator;
		var out = n == 0 ? "0" : n == d ? "1" : d == 1 ? this2.positive ? "" + n : "-" + n : this2.positive ? "" + n + "/" + d : "-" + n + "/" + d;
		str = str + "\n" + out;
	}
	return str;
};
var trilateral_angle__$Fraction_Fraction_$Impl_$ = {};
trilateral_angle__$Fraction_Fraction_$Impl_$.__name__ = true;
trilateral_angle__$Fraction_Fraction_$Impl_$._new = function(numerator,denominator,positive,value) {
	if(positive == null) {
		positive = true;
	}
	var numNeg = numerator < 0;
	var denoNeg = denominator < 0;
	if(value == null) {
		value = positive ? numerator / denominator : -numerator / denominator;
	}
	if(numNeg || denoNeg) {
		if(!(numNeg && denoNeg)) {
			positive = !positive;
		}
		if(numNeg) {
			numerator = -numerator;
		}
		if(denoNeg) {
			denominator = -denominator;
		}
	}
	var this1 = { numerator : numerator, denominator : denominator, positive : positive, value : value};
	return this1;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.optimize = function(this1) {
	var f = this1.value;
	var arr = trilateral_angle_Fracs.approximateFractions(f);
	var dist = Infinity;
	var dif;
	var l = arr.length;
	var fracFloat;
	var frac = trilateral_angle__$Fraction_Fraction_$Impl_$;
	var fracStore = arr[0];
	var _g = 0;
	var _g1 = l;
	while(_g < _g1) {
		var i = _g++;
		var frac1 = arr[i];
		fracFloat = frac1.positive ? frac1.numerator / frac1.denominator : -frac1.numerator / frac1.denominator;
		dif = Math.abs(fracFloat - f);
		if(dif < dist) {
			dist = dif;
			fracStore = frac1;
		}
	}
	return fracStore;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.optimizeFraction = function(this1) {
	var f = this1.positive ? this1.numerator / this1.denominator : -this1.numerator / this1.denominator;
	var arr = trilateral_angle_Fracs.approximateFractions(f);
	var dist = Infinity;
	var dif;
	var l = arr.length;
	var fracFloat;
	var frac = trilateral_angle__$Fraction_Fraction_$Impl_$;
	var fracStore = arr[0];
	var _g = 0;
	var _g1 = l;
	while(_g < _g1) {
		var i = _g++;
		var frac1 = arr[i];
		fracFloat = frac1.positive ? frac1.numerator / frac1.denominator : -frac1.numerator / frac1.denominator;
		dif = Math.abs(fracFloat - f);
		if(dif < dist) {
			dist = dif;
			fracStore = frac1;
		}
	}
	return fracStore;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.toFloat = function(this1) {
	if(this1.positive) {
		return this1.numerator / this1.denominator;
	} else {
		return -this1.numerator / this1.denominator;
	}
};
trilateral_angle__$Fraction_Fraction_$Impl_$.float = function(this1) {
	return this1.value;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.verbose = function(this1) {
	return "{ numerator:" + this1.numerator + ", denominator: " + this1.denominator + ", positive: " + (this1.positive == null ? "null" : "" + this1.positive) + ", value: " + this1.value + " }";
};
trilateral_angle__$Fraction_Fraction_$Impl_$.fromString = function(val) {
	var i = val.indexOf("/");
	var frac;
	if(i != -1) {
		var numerator = Std.parseInt(HxOverrides.substr(val,0,i));
		var denominator = Std.parseInt(HxOverrides.substr(val,i + 1,val.length));
		var positive = true;
		var value = null;
		var numNeg = numerator < 0;
		var denoNeg = denominator < 0;
		if(value == null) {
			value = positive ? numerator / denominator : -numerator / denominator;
		}
		if(numNeg || denoNeg) {
			if(!(numNeg && denoNeg)) {
				positive = !positive;
			}
			if(numNeg) {
				numerator = -numerator;
			}
			if(denoNeg) {
				denominator = -denominator;
			}
		}
		var this1 = { numerator : numerator, denominator : denominator, positive : positive, value : value};
		frac = this1;
	} else {
		var f = parseFloat(val);
		var arr = trilateral_angle_Fracs.approximateFractions(f);
		var dist = Infinity;
		var dif;
		var l = arr.length;
		var fracFloat;
		var frac1 = trilateral_angle__$Fraction_Fraction_$Impl_$;
		var fracStore = arr[0];
		var _g = 0;
		var _g1 = l;
		while(_g < _g1) {
			var i1 = _g++;
			var frac2 = arr[i1];
			fracFloat = frac2.positive ? frac2.numerator / frac2.denominator : -frac2.numerator / frac2.denominator;
			dif = Math.abs(fracFloat - f);
			if(dif < dist) {
				dist = dif;
				fracStore = frac2;
			}
		}
		frac = fracStore;
	}
	return frac;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.toString = function(this1) {
	var n = this1.numerator;
	var d = this1.denominator;
	var out = n == 0 ? "0" : n == d ? "1" : d == 1 ? this1.positive ? "" + n : "-" + n : this1.positive ? "" + n + "/" + d : "-" + n + "/" + d;
	return out;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.fromFloat = function(f) {
	var arr = trilateral_angle_Fracs.approximateFractions(f);
	var dist = Infinity;
	var dif;
	var l = arr.length;
	var fracFloat;
	var frac = trilateral_angle__$Fraction_Fraction_$Impl_$;
	var fracStore = arr[0];
	var _g = 0;
	var _g1 = l;
	while(_g < _g1) {
		var i = _g++;
		var frac1 = arr[i];
		fracFloat = frac1.positive ? frac1.numerator / frac1.denominator : -frac1.numerator / frac1.denominator;
		dif = Math.abs(fracFloat - f);
		if(dif < dist) {
			dist = dif;
			fracStore = frac1;
		}
	}
	return fracStore;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.firstFloat = function(f) {
	var arr = trilateral_angle_Fracs.approximateFractions(f);
	var fracStore = arr[0];
	return fracStore;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.byDenominator = function(this1,val) {
	var n = this1.numerator;
	var d = this1.denominator;
	var out = n == 0 ? "0" : n == d ? "1" : d == 1 ? this1.positive ? "" + n : "-" + n : this1.positive ? "" + n + "/" + d : "-" + n + "/" + d;
	var out1 = out;
	if(!(this1.denominator == val || out1 == "0" || out1 == "1")) {
		var dom = Math.round(this1.value * val);
		var numerator = dom;
		var denominator = val;
		var positive = true;
		var value = null;
		var numNeg = numerator < 0;
		var denoNeg = denominator < 0;
		if(value == null) {
			value = positive ? numerator / denominator : -numerator / denominator;
		}
		if(numNeg || denoNeg) {
			if(!(numNeg && denoNeg)) {
				positive = !positive;
			}
			if(numNeg) {
				numerator = -numerator;
			}
			if(denoNeg) {
				denominator = -denominator;
			}
		}
		var this2 = { numerator : numerator, denominator : denominator, positive : positive, value : value};
		var frac = this2;
		var n1 = frac.numerator;
		var d1 = frac.denominator;
		var out2 = n1 == 0 ? "0" : n1 == d1 ? "1" : d1 == 1 ? frac.positive ? "" + n1 : "-" + n1 : frac.positive ? "" + n1 + "/" + d1 : "-" + n1 + "/" + d1;
		out1 = out2;
	}
	return out1;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.all = function(f) {
	return trilateral_angle_Fracs.approximateFractions(f);
};
trilateral_angle__$Fraction_Fraction_$Impl_$.similarToFraction = function(this1) {
	var f = this1.positive ? this1.numerator / this1.denominator : -this1.numerator / this1.denominator;
	return trilateral_angle_Fracs.approximateFractions(f);
};
trilateral_angle__$Fraction_Fraction_$Impl_$.similarToValue = function(this1) {
	return trilateral_angle_Fracs.approximateFractions(this1.value);
};
var trilateral_angle_Fracs = function() { };
trilateral_angle_Fracs.__name__ = true;
trilateral_angle_Fracs.grabDecimalInput = function(decimalVal) {
	var decimal = Math.abs(parseFloat(decimalVal));
	if(isNaN(decimal)) {
		return 0.;
	} else {
		return decimal;
	}
};
trilateral_angle_Fracs.approximateFractions = function(f) {
	var positive = f <= 0 ? false : true;
	var numerators = [0,1];
	var denominators = [1,0];
	var f2 = f <= 0 ? -f : f;
	var fStr = f2 == null ? "null" : "" + f2;
	var digits = "";
	var ix = fStr.indexOf(".");
	if(ix == -1) {
		digits = fStr;
	} else if(ix == 0) {
		digits = HxOverrides.substr(fStr,1,fStr.length);
	} else if(ix < fStr.length) {
		digits = HxOverrides.substr(fStr,0,ix) + HxOverrides.substr(fStr,ix + 1,fStr.length);
	}
	var LStr = digits;
	var numDigits = LStr.length;
	var L2 = f2;
	var numIntDigits = Std.string(L2).length;
	if(L2 == 0) {
		numIntDigits = 0;
	}
	var numDigitsPastDecimal = numDigits - numIntDigits;
	var i = numDigitsPastDecimal;
	var L = parseFloat(digits);
	while(i > 0 && L % 2 == 0) {
		L /= 2;
		--i;
	}
	i = numDigitsPastDecimal;
	while(i > 0 && L % 5 == 0) {
		L /= 5;
		--i;
	}
	var maxNumerator = L;
	var d2 = f2;
	var calcD;
	var prevCalcD = null;
	var this1 = [];
	var arrFraction = this1;
	var j = 0;
	var _g = 2;
	while(_g < 1000) {
		var i1 = _g++;
		var L21 = Math.floor(d2);
		numerators[i1] = L21 * numerators[i1 - 1] + numerators[i1 - 2] | 0;
		if(Math.abs(numerators[i1]) > maxNumerator) {
			break;
		}
		denominators[i1] = L21 * denominators[i1 - 1] + denominators[i1 - 2] | 0;
		calcD = numerators[i1] / denominators[i1];
		if(calcD == prevCalcD) {
			break;
		}
		var numerator = numerators[i1];
		var denominator = denominators[i1];
		var positive1 = positive;
		var value = f;
		var numNeg = numerator < 0;
		var denoNeg = denominator < 0;
		if(value == null) {
			value = positive1 ? numerator / denominator : -numerator / denominator;
		}
		if(numNeg || denoNeg) {
			if(!(numNeg && denoNeg)) {
				positive1 = !positive1;
			}
			if(numNeg) {
				numerator = -numerator;
			}
			if(denoNeg) {
				denominator = -denominator;
			}
		}
		var this2 = { numerator : numerator, denominator : denominator, positive : positive1, value : value};
		arrFraction[arrFraction.length] = this2;
		if(calcD == f2) {
			break;
		}
		prevCalcD = calcD;
		d2 = 1 / (d2 - L21);
	}
	return arrFraction;
};
trilateral_angle_Fracs.getMaxNumerator = function(f) {
	var fStr = f == null ? "null" : "" + f;
	var digits = "";
	var ix = fStr.indexOf(".");
	if(ix == -1) {
		digits = fStr;
	} else if(ix == 0) {
		digits = HxOverrides.substr(fStr,1,fStr.length);
	} else if(ix < fStr.length) {
		digits = HxOverrides.substr(fStr,0,ix) + HxOverrides.substr(fStr,ix + 1,fStr.length);
	}
	var LStr = digits;
	var numDigits = LStr.length;
	var L2 = f;
	var numIntDigits = (L2 == null ? "null" : "" + L2).length;
	if(L2 == 0) {
		numIntDigits = 0;
	}
	var numDigitsPastDecimal = numDigits - numIntDigits;
	var i = numDigitsPastDecimal;
	var L = parseFloat(digits);
	while(i > 0 && L % 2 == 0) {
		L /= 2;
		--i;
	}
	i = numDigitsPastDecimal;
	while(i > 0 && L % 5 == 0) {
		L /= 5;
		--i;
	}
	return L;
};
trilateral_angle_Fracs.extractDigitStr = function(fStr) {
	var f2 = "";
	var ixe = fStr.indexOf("E");
	if(ixe == -1) {
		ixe = fStr.indexOf("e");
	}
	if(ixe == -1) {
		f2 = fStr;
	} else {
		f2 = HxOverrides.substr(fStr,0,ixe);
	}
	var digits = "";
	var ix = f2.indexOf(".");
	if(ix == -1) {
		digits = f2;
	} else if(ix == 0) {
		digits = HxOverrides.substr(f2,1,f2.length);
	} else if(ix < f2.length) {
		digits = HxOverrides.substr(f2,0,ix) + HxOverrides.substr(f2,ix + 1,f2.length);
	}
	return digits;
};
trilateral_angle_Fracs.getMaxNumeratorStr = function(fStr) {
	var f2 = "";
	var ixe = fStr.indexOf("E");
	if(ixe == -1) {
		ixe = fStr.indexOf("e");
	}
	if(ixe == -1) {
		f2 = fStr;
	} else {
		f2 = HxOverrides.substr(fStr,0,ixe);
	}
	var digits = "";
	var ix = f2.indexOf(".");
	if(ix == -1) {
		digits = f2;
	} else if(ix == 0) {
		digits = HxOverrides.substr(f2,1,f2.length);
	} else if(ix < f2.length) {
		digits = HxOverrides.substr(f2,0,ix) + HxOverrides.substr(f2,ix + 1,f2.length);
	}
	var LStr = digits;
	var numDigits = LStr.length;
	var L2 = fStr;
	var numIntDigits = L2.length;
	if(L2 == "0") {
		numIntDigits = 0;
	}
	var numDigitsPastDecimal = numDigits - numIntDigits;
	var i = numDigitsPastDecimal;
	var L = parseFloat(fStr);
	while(i > 0 && L % 2 == 0) {
		L /= 2;
		--i;
	}
	i = numDigitsPastDecimal;
	while(i > 0 && L % 5 == 0) {
		L /= 5;
		--i;
	}
	return L;
};
var trilateral_angle__$Pi2pi_Pi2pi_$Impl_$ = {};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.__name__ = true;
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$._new = function(f) {
	var this1 = f;
	return this1;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.fromFloat = function(f) {
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this1 = f1;
	return this1;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.additionPi = function(this1,b) {
	var f = this1 + b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.subtractionPi = function(this1,b) {
	var f = this1 - b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.dividePi = function(this1,b) {
	var f = this1 / b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.timesPi = function(this1,b) {
	var f = this1 * b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.addition = function(this1,b) {
	var f = this1 + b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.subtraction = function(this1,b) {
	var f = this1 - b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.divide = function(this1,b) {
	var f = this1 / b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.times = function(this1,b) {
	var f = this1 * b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.get_degrees = function(this1) {
	return this1 * 180 / Math.PI;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.set_degrees = function(this1,val) {
	this1 = Math.PI * val / 180;
	return val;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.fromFraction = function(val) {
	var f = (val.positive ? val.numerator / val.denominator : -val.numerator / val.denominator) * Math.PI;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		f1 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this1 = f1;
	return this1;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.tofraction = function(this1) {
	var f = this1 / Math.PI;
	var arr = trilateral_angle_Fracs.approximateFractions(f);
	var dist = Infinity;
	var dif;
	var l = arr.length;
	var fracFloat;
	var frac = trilateral_angle__$Fraction_Fraction_$Impl_$;
	var fracStore = arr[0];
	var _g = 0;
	var _g1 = l;
	while(_g < _g1) {
		var i = _g++;
		var frac1 = arr[i];
		fracFloat = frac1.positive ? frac1.numerator / frac1.denominator : -frac1.numerator / frac1.denominator;
		dif = Math.abs(fracFloat - f);
		if(dif < dist) {
			dist = dif;
			fracStore = frac1;
		}
	}
	return fracStore;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.fromString = function(val) {
	var i = val.indexOf("/");
	var frac;
	if(i != -1) {
		var numerator = Std.parseInt(HxOverrides.substr(val,0,i));
		var denominator = Std.parseInt(HxOverrides.substr(val,i + 1,val.length));
		var positive = true;
		var value = null;
		var numNeg = numerator < 0;
		var denoNeg = denominator < 0;
		if(value == null) {
			value = positive ? numerator / denominator : -numerator / denominator;
		}
		if(numNeg || denoNeg) {
			if(!(numNeg && denoNeg)) {
				positive = !positive;
			}
			if(numNeg) {
				numerator = -numerator;
			}
			if(denoNeg) {
				denominator = -denominator;
			}
		}
		var this1 = { numerator : numerator, denominator : denominator, positive : positive, value : value};
		frac = this1;
	} else {
		var f = parseFloat(val);
		var arr = trilateral_angle_Fracs.approximateFractions(f);
		var dist = Infinity;
		var dif;
		var l = arr.length;
		var fracFloat;
		var frac1 = trilateral_angle__$Fraction_Fraction_$Impl_$;
		var fracStore = arr[0];
		var _g = 0;
		var _g1 = l;
		while(_g < _g1) {
			var i1 = _g++;
			var frac2 = arr[i1];
			fracFloat = frac2.positive ? frac2.numerator / frac2.denominator : -frac2.numerator / frac2.denominator;
			dif = Math.abs(fracFloat - f);
			if(dif < dist) {
				dist = dif;
				fracStore = frac2;
			}
		}
		frac = fracStore;
	}
	var frac3 = frac;
	var f1 = (frac3.positive ? frac3.numerator / frac3.denominator : -frac3.numerator / frac3.denominator) * Math.PI;
	var f2;
	if(f1 <= Math.PI && f1 > -Math.PI) {
		f2 = f1;
	} else {
		var a = (f1 + Math.PI) % (2 * Math.PI);
		f2 = a >= 0 ? a - Math.PI : a + Math.PI;
	}
	var this2 = f2;
	return this2;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.toString = function(this1) {
	return Std.string(this1);
};
var trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$ = {};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.__name__ = true;
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$._new = function(f) {
	var this1 = f;
	return this1;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.fromFloat = function(f) {
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this1 = f1;
	return this1;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.additionPi = function(this1,b) {
	var f = this1 + b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.subtractionPi = function(this1,b) {
	var f = this1 - b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.dividePi = function(this1,b) {
	var f = this1 / b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.timesPi = function(this1,b) {
	var f = this1 * b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.addition = function(this1,b) {
	var f = this1 + b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.subtraction = function(this1,b) {
	var f = this1 - b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.divide = function(this1,b) {
	var f = this1 / b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.times = function(this1,b) {
	var f = this1 * b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this2 = f1;
	return this2;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.get_degrees = function(this1) {
	return this1 * 180 / Math.PI;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.set_degrees = function(this1,val) {
	this1 = Math.PI * val / 180;
	return val;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.fromFraction = function(val) {
	var f = (val.positive ? val.numerator / val.denominator : -val.numerator / val.denominator) * Math.PI;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		f1 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this1 = f1;
	return this1;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.tofraction = function(this1) {
	var f = this1 / Math.PI;
	var arr = trilateral_angle_Fracs.approximateFractions(f);
	var dist = Infinity;
	var dif;
	var l = arr.length;
	var fracFloat;
	var frac = trilateral_angle__$Fraction_Fraction_$Impl_$;
	var fracStore = arr[0];
	var _g = 0;
	var _g1 = l;
	while(_g < _g1) {
		var i = _g++;
		var frac1 = arr[i];
		fracFloat = frac1.positive ? frac1.numerator / frac1.denominator : -frac1.numerator / frac1.denominator;
		dif = Math.abs(fracFloat - f);
		if(dif < dist) {
			dist = dif;
			fracStore = frac1;
		}
	}
	return fracStore;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.fromString = function(val) {
	var i = val.indexOf("/");
	var frac;
	if(i != -1) {
		var numerator = Std.parseInt(HxOverrides.substr(val,0,i));
		var denominator = Std.parseInt(HxOverrides.substr(val,i + 1,val.length));
		var positive = true;
		var value = null;
		var numNeg = numerator < 0;
		var denoNeg = denominator < 0;
		if(value == null) {
			value = positive ? numerator / denominator : -numerator / denominator;
		}
		if(numNeg || denoNeg) {
			if(!(numNeg && denoNeg)) {
				positive = !positive;
			}
			if(numNeg) {
				numerator = -numerator;
			}
			if(denoNeg) {
				denominator = -denominator;
			}
		}
		var this1 = { numerator : numerator, denominator : denominator, positive : positive, value : value};
		frac = this1;
	} else {
		var f = parseFloat(val);
		var arr = trilateral_angle_Fracs.approximateFractions(f);
		var dist = Infinity;
		var dif;
		var l = arr.length;
		var fracFloat;
		var frac1 = trilateral_angle__$Fraction_Fraction_$Impl_$;
		var fracStore = arr[0];
		var _g = 0;
		var _g1 = l;
		while(_g < _g1) {
			var i1 = _g++;
			var frac2 = arr[i1];
			fracFloat = frac2.positive ? frac2.numerator / frac2.denominator : -frac2.numerator / frac2.denominator;
			dif = Math.abs(fracFloat - f);
			if(dif < dist) {
				dist = dif;
				fracStore = frac2;
			}
		}
		frac = fracStore;
	}
	var frac3 = frac;
	var f1 = (frac3.positive ? frac3.numerator / frac3.denominator : -frac3.numerator / frac3.denominator) * Math.PI;
	var f2;
	if(f1 >= 0 && f1 > Math.PI) {
		f2 = f1;
	} else {
		var a = f1 % (2 * Math.PI);
		f2 = a >= 0 ? a : a + 2 * Math.PI;
	}
	var this2 = f2;
	return this2;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.toString = function(this1) {
	return Std.string(this1);
};
var trilateral_arr__$ArrayTriple_ArrayTriple_$Impl_$ = {};
trilateral_arr__$ArrayTriple_ArrayTriple_$Impl_$.__name__ = true;
trilateral_arr__$ArrayTriple_ArrayTriple_$Impl_$._new = function(arr) {
	var this1 = arr;
	return this1;
};
trilateral_arr__$ArrayTriple_ArrayTriple_$Impl_$.get_length = function(this1) {
	return this1.length / 3 | 0;
};
trilateral_arr__$ArrayTriple_ArrayTriple_$Impl_$.access = function(this1,key) {
	var i = key * 3 | 0;
	return { a : this1[i], b : this1[i + 1], c : this1[i + 2]};
};
trilateral_arr__$ArrayTriple_ArrayTriple_$Impl_$.reverse = function(this1) {
	var arr = [];
	var _g = 0;
	var _g1 = trilateral_arr__$ArrayTriple_ArrayTriple_$Impl_$._new(this1);
	while(_g < (_g1.length / 3 | 0)) {
		var i = _g * 3 | 0;
		var i_a = _g1[i];
		var i_b = _g1[i + 1];
		var i_c = _g1[i + 2];
		++_g;
		arr.unshift(i_c);
		arr.unshift(i_b);
		arr.unshift(i_a);
	}
	this1 = arr;
	return arr;
};
var trilateral_geom_Algebra = function() { };
trilateral_geom_Algebra.__name__ = true;
trilateral_geom_Algebra.theta = function(p0,p1) {
	var dx = p0.x - p1.x;
	var dy = p0.y - p1.y;
	return Math.atan2(dy,dx);
};
trilateral_geom_Algebra.dist = function(p0,p1) {
	var dx = p0.x - p1.x;
	var dy = p0.y - p1.y;
	return dx * dx + dy * dy;
};
trilateral_geom_Algebra.adjustWinding = function(A_,B_,C_) {
	var p0_x = B_.x - A_.x;
	var p0_y = B_.y - A_.y;
	var p1_x = C_.x - A_.x;
	var p1_y = C_.y - A_.y;
	var val = !(p0_x * p1_y - p0_y * p1_x < 0);
	return val;
};
trilateral_geom_Algebra.subtract = function(p0,p1) {
	return { x : p0.x - p1.x, y : p0.y - p1.y};
};
trilateral_geom_Algebra.cross = function(p0,p1) {
	return p0.x * p1.y - p0.y * p1.x;
};
trilateral_geom_Algebra.sign = function(n) {
	return Math.abs(n) / n | 0;
};
trilateral_geom_Algebra.quadratic = function(t,s,c,e) {
	var u = 1 - t;
	return Math.pow(u,2) * s + 2 * u * t * c + Math.pow(t,2) * e;
};
trilateral_geom_Algebra.cubic = function(t,s,c1,c2,e) {
	var u = 1 - t;
	return Math.pow(u,3) * s + 3 * Math.pow(u,2) * t * c1 + 3 * u * Math.pow(t,2) * c2 + Math.pow(t,3) * e;
};
trilateral_geom_Algebra.quadCurve = function(p,ax,ay,bx,by,cx,cy) {
	var x = ax - bx;
	var y = ay - by;
	var x1 = bx - cx;
	var y1 = by - cy;
	var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
	if(approxDistance == 0) {
		approxDistance = 0.000001;
	}
	var step = Math.min(1 / (approxDistance * 0.707),trilateral_geom_Algebra.quadStep);
	var l = p.length;
	p[l++] = ax;
	p[l++] = ay;
	var t = step;
	while(t < 1.) {
		var u = 1 - t;
		p[l++] = Math.pow(u,2) * ax + 2 * u * t * bx + Math.pow(t,2) * cx;
		var u1 = 1 - t;
		p[l++] = Math.pow(u1,2) * ay + 2 * u1 * t * by + Math.pow(t,2) * cy;
		t += step;
	}
	p[l++] = cx;
	p[l++] = cy;
	return p;
};
trilateral_geom_Algebra.cubicCurve = function(p,ax,ay,bx,by,cx,cy,dx,dy) {
	var x = ax - bx;
	var y = ay - by;
	var x1 = bx - cx;
	var y1 = by - cy;
	var x2 = cx - dx;
	var y2 = cy - dy;
	var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2);
	if(approxDistance == 0) {
		approxDistance = 0.000001;
	}
	var step = Math.min(1 / (approxDistance * 0.707),trilateral_geom_Algebra.cubicStep);
	var l = p.length;
	p[l++] = ax;
	p[l++] = ay;
	var t = step;
	while(t < 1.) {
		var u = 1 - t;
		p[l++] = Math.pow(u,3) * ax + 3 * Math.pow(u,2) * t * bx + 3 * u * Math.pow(t,2) * cx + Math.pow(t,3) * dx;
		var u1 = 1 - t;
		p[l++] = Math.pow(u1,3) * ay + 3 * Math.pow(u1,2) * t * by + 3 * u1 * Math.pow(t,2) * cy + Math.pow(t,3) * dy;
		t += step;
	}
	p[l++] = dx;
	p[l++] = dy;
	return p;
};
trilateral_geom_Algebra.calculateQuadStep = function(ax,ay,bx,by,cx,cy) {
	var x = ax - bx;
	var y = ay - by;
	var x1 = bx - cx;
	var y1 = by - cy;
	var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
	if(approxDistance == 0) {
		approxDistance = 0.000001;
	}
	return Math.min(1 / (approxDistance * 0.707),trilateral_geom_Algebra.quadStep);
};
trilateral_geom_Algebra.calculateCubicStep = function(ax,ay,bx,by,cx,cy,dx,dy) {
	var x = ax - bx;
	var y = ay - by;
	var x1 = bx - cx;
	var y1 = by - cy;
	var x2 = cx - dx;
	var y2 = cy - dy;
	var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2);
	if(approxDistance == 0) {
		approxDistance = 0.000001;
	}
	return Math.min(1 / (approxDistance * 0.707),trilateral_geom_Algebra.cubicStep);
};
trilateral_geom_Algebra.lineAB = function(A,B,width) {
	var dx = A.x - B.x;
	var dy = A.y - B.y;
	var P_x = A.x - width / 2;
	var P_y = A.y;
	var omega = Math.atan2(dy,dx);
	var dim_x = width;
	var dim_y = dx * dx + dy * dy;
	var pivotX = A.x + width / 2;
	var pivotY = A.y;
	var px = P_x;
	var py = P_y;
	var dx1 = dim_x;
	var dy1 = dim_y;
	var A_ = { x : px, y : py};
	var B_ = { x : px + dx1, y : py};
	var C_ = { x : px + dx1, y : py + dy1};
	var D_ = { x : px, y : py + dy1};
	if(omega != 0.) {
		var sin = Math.sin(omega);
		var cos = Math.cos(omega);
		var px1 = A_.x - pivotX;
		var py1 = A_.y - pivotY;
		var px2 = px1 * cos - py1 * sin;
		py1 = py1 * cos + px1 * sin;
		A_ = { x : px2 + pivotX, y : py1 + pivotY};
		var px3 = B_.x - pivotX;
		var py2 = B_.y - pivotY;
		var px21 = px3 * cos - py2 * sin;
		py2 = py2 * cos + px3 * sin;
		B_ = { x : px21 + pivotX, y : py2 + pivotY};
		var px4 = C_.x - pivotX;
		var py3 = C_.y - pivotY;
		var px22 = px4 * cos - py3 * sin;
		py3 = py3 * cos + px4 * sin;
		C_ = { x : px22 + pivotX, y : py3 + pivotY};
		var px5 = D_.x - pivotX;
		var py4 = D_.y - pivotY;
		var px23 = px5 * cos - py4 * sin;
		py4 = py4 * cos + px5 * sin;
		D_ = { x : px23 + pivotX, y : py4 + pivotY};
	}
	return { A : A_, B : B_, C : C_, D : D_};
};
trilateral_geom_Algebra.lineABCoord = function(ax,ay,bx,by,width) {
	var dx = ax - bx;
	var dy = ay - by;
	var P_x = ax - width / 2;
	var P_y = ay;
	var omega = Math.atan2(dy,dx);
	var dim_x = width;
	var dim_y = dx * dx + dy * dy;
	var pivotX = ax + width / 2;
	var px = P_x;
	var py = P_y;
	var dx1 = dim_x;
	var dy1 = dim_y;
	var A_ = { x : px, y : py};
	var B_ = { x : px + dx1, y : py};
	var C_ = { x : px + dx1, y : py + dy1};
	var D_ = { x : px, y : py + dy1};
	if(omega != 0.) {
		var sin = Math.sin(omega);
		var cos = Math.cos(omega);
		var px1 = A_.x - pivotX;
		var py1 = A_.y - ay;
		var px2 = px1 * cos - py1 * sin;
		py1 = py1 * cos + px1 * sin;
		A_ = { x : px2 + pivotX, y : py1 + ay};
		var px3 = B_.x - pivotX;
		var py2 = B_.y - ay;
		var px21 = px3 * cos - py2 * sin;
		py2 = py2 * cos + px3 * sin;
		B_ = { x : px21 + pivotX, y : py2 + ay};
		var px4 = C_.x - pivotX;
		var py3 = C_.y - ay;
		var px22 = px4 * cos - py3 * sin;
		py3 = py3 * cos + px4 * sin;
		C_ = { x : px22 + pivotX, y : py3 + ay};
		var px5 = D_.x - pivotX;
		var py4 = D_.y - ay;
		var px23 = px5 * cos - py4 * sin;
		py4 = py4 * cos + px5 * sin;
		D_ = { x : px23 + pivotX, y : py4 + ay};
	}
	return { A : A_, B : B_, C : C_, D : D_};
};
trilateral_geom_Algebra.rotateVectorLine = function(pos,dim,omega,pivotX,pivotY) {
	var px = pos.x;
	var py = pos.y;
	var dx = dim.x;
	var dy = dim.y;
	var A_ = { x : px, y : py};
	var B_ = { x : px + dx, y : py};
	var C_ = { x : px + dx, y : py + dy};
	var D_ = { x : px, y : py + dy};
	if(omega != 0.) {
		var sin = Math.sin(omega);
		var cos = Math.cos(omega);
		var px1 = A_.x - pivotX;
		var py1 = A_.y - pivotY;
		var px2 = px1 * cos - py1 * sin;
		py1 = py1 * cos + px1 * sin;
		A_ = { x : px2 + pivotX, y : py1 + pivotY};
		var px3 = B_.x - pivotX;
		var py2 = B_.y - pivotY;
		var px21 = px3 * cos - py2 * sin;
		py2 = py2 * cos + px3 * sin;
		B_ = { x : px21 + pivotX, y : py2 + pivotY};
		var px4 = C_.x - pivotX;
		var py3 = C_.y - pivotY;
		var px22 = px4 * cos - py3 * sin;
		py3 = py3 * cos + px4 * sin;
		C_ = { x : px22 + pivotX, y : py3 + pivotY};
		var px5 = D_.x - pivotX;
		var py4 = D_.y - pivotY;
		var px23 = px5 * cos - py4 * sin;
		py4 = py4 * cos + px5 * sin;
		D_ = { x : px23 + pivotX, y : py4 + pivotY};
	}
	return { A : A_, B : B_, C : C_, D : D_};
};
trilateral_geom_Algebra.pivotCheap = function(p,sin,cos,pivotX,pivotY) {
	var px = p.x - pivotX;
	var py = p.y - pivotY;
	var px2 = px * cos - py * sin;
	py = py * cos + px * sin;
	return { x : px2 + pivotX, y : py + pivotY};
};
trilateral_geom_Algebra.pivot = function(p,omega,pivotX,pivotY) {
	var px = p.x - pivotX;
	var py = p.y - pivotY;
	var px2 = px * Math.cos(omega) - py * Math.sin(omega);
	py = py * Math.cos(omega) + px * Math.sin(omega);
	return { x : px2 + pivotX, y : py + pivotY};
};
trilateral_geom_Algebra.thetaCheap = function(dx,dy) {
	return Math.atan2(dy,dx);
};
trilateral_geom_Algebra.distCheap = function(dx,dy) {
	return dx * dx + dy * dy;
};
trilateral_geom_Algebra.distance = function(px,py,qx,qy) {
	var x = px - qx;
	var y = py - qy;
	return Math.sqrt(x * x + y * y);
};
var trilateral_geom_Contour = function(triArr_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.counter = 0;
	this.count = 0;
	this.pointsAnti = [];
	this.pointsClock = [];
	this.triArr = triArr_;
	this.endLine = endLine_;
};
trilateral_geom_Contour.__name__ = true;
trilateral_geom_Contour.thetaCompute = function(px,py,qx,qy) {
	return Math.atan2(py - qy,px - qx);
};
trilateral_geom_Contour.dist = function(px,py,qx,qy) {
	var x = px - qx;
	var y = py - qy;
	return x * x + y * y;
};
trilateral_geom_Contour.prototype = {
	reset: function() {
		this.angleA = 0;
		this.count = 0;
		this.kax = 0;
		this.kay = 0;
		this.kbx = 0;
		this.kby = 0;
		this.kcx = 0;
		this.kcy = 0;
		this.ncx = 0;
		this.ncy = 0;
		this.ax = 0;
		this.ay = 0;
		this.bx = 0;
		this.by = 0;
		this.cx = 0;
		this.cy = 0;
		this.dx = null;
		this.dy = null;
		this.ex = null;
		this.ey = null;
		this.pointsClock.length = 0;
		this.pointsAnti.length = 0;
	}
	,triangleJoin: function(ax_,ay_,bx_,by_,width_,curveEnds,overlap) {
		if(overlap == null) {
			overlap = false;
		}
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = this.dx != null ? this.angle1 : null;
		this.halfA = Math.PI / 2;
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var x = this.dxOld - bx_;
		var y = this.dyOld - by_;
		var x1 = this.exOld - bx_;
		var y1 = this.eyOld - by_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(this.ay - this.dyOld,this.ax - this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.eyPrev,this.ax - this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(this.ay - this.eyOld,this.ax - this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.dyPrev,this.ax - this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f1;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f1 = theta1;
			} else {
				var a1 = theta1 % (2 * Math.PI);
				f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
			}
			var this2 = f1;
			var zb = this2;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(theta0 - theta1);
			var clockwise = theta0 < theta1;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f2;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f2 = theta0;
			} else {
				var a2 = theta0 % (2 * Math.PI);
				f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
			}
			var this3 = f2;
			var za1 = this3;
			var f3;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f3 = theta1;
			} else {
				var a3 = theta1 % (2 * Math.PI);
				f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
			}
			var this4 = f3;
			var zb1 = this4;
			var fa1 = za1;
			var fb1 = zb1;
			var theta2 = Math.abs(theta0 - theta1);
			var clockwise1 = theta0 < theta1;
			var dif2 = clockwise1 ? theta2 : -theta2;
			dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
			break;
		case 2:
			var f4;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f4 = theta0;
			} else {
				var a4 = theta0 % (2 * Math.PI);
				f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
			}
			var this5 = f4;
			var za2 = this5;
			var f5;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f5 = theta1;
			} else {
				var a5 = theta1 % (2 * Math.PI);
				f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
			}
			var this6 = f5;
			var zb2 = this6;
			var fa2 = theta0;
			var fb2 = theta1;
			var theta3 = Math.abs(theta0 - theta1);
			var smallest = theta3 <= Math.PI;
			var clockwise2 = theta0 < theta1;
			var dif3 = clockwise2 ? theta3 : -theta3;
			dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
			break;
		case 3:
			var f6;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f6 = theta0;
			} else {
				var a6 = theta0 % (2 * Math.PI);
				f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
			}
			var this7 = f6;
			var za3 = this7;
			var f7;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f7 = theta1;
			} else {
				var a7 = theta1 % (2 * Math.PI);
				f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
			}
			var this8 = f7;
			var zb3 = this8;
			var fa3 = theta0;
			var fb3 = theta1;
			var theta4 = Math.abs(theta0 - theta1);
			var largest = theta4 > Math.PI;
			var clockwise3 = theta0 < theta1;
			var dif4 = clockwise3 ? theta4 : -theta4;
			dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta4) : 2 * Math.PI - theta4;
			break;
		}
		if(!overlap && this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f8;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f8 = theta0;
			} else {
				var a8 = (theta0 + Math.PI) % (2 * Math.PI);
				f8 = a8 >= 0 ? a8 - Math.PI : a8 + Math.PI;
			}
			var this9 = f8;
			var start = this9;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			this.jx = this.ax + h * Math.sin(delta);
			this.jy = this.ay + h * Math.cos(delta);
		}
		if(this.count == 0 && (this.endLine == 1 || this.endLine == 3)) {
			var ax = this.ax;
			var ay = this.ay;
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma1 = -this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			var this10 = this.triArr;
			var t = [];
			var this11;
			if(t == null) {
				var t1 = [];
				var this12 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
				this11 = this12;
			} else {
				this11 = t;
			}
			var this13 = this11;
			var out = this13;
			var pi = Math.PI;
			var step = pi * 2 / 36;
			var dif5;
			switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f9;
				if(beta >= 0 && beta > Math.PI) {
					f9 = beta;
				} else {
					var a9 = beta % (2 * Math.PI);
					f9 = a9 >= 0 ? a9 : a9 + 2 * Math.PI;
				}
				var this14 = f9;
				var za4 = this14;
				var f10;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f10 = gamma1;
				} else {
					var a10 = gamma1 % (2 * Math.PI);
					f10 = a10 >= 0 ? a10 : a10 + 2 * Math.PI;
				}
				var this15 = f10;
				var zb4 = this15;
				var fa4 = za4;
				var fb4 = zb4;
				var theta5 = Math.abs(beta - gamma1);
				var clockwise4 = beta < gamma1;
				var dif6 = clockwise4 ? theta5 : -theta5;
				dif5 = dif6 > 0 ? dif6 : 2 * Math.PI + dif6;
				break;
			case 1:
				var f11;
				if(beta >= 0 && beta > Math.PI) {
					f11 = beta;
				} else {
					var a11 = beta % (2 * Math.PI);
					f11 = a11 >= 0 ? a11 : a11 + 2 * Math.PI;
				}
				var this16 = f11;
				var za5 = this16;
				var f12;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f12 = gamma1;
				} else {
					var a12 = gamma1 % (2 * Math.PI);
					f12 = a12 >= 0 ? a12 : a12 + 2 * Math.PI;
				}
				var this17 = f12;
				var zb5 = this17;
				var fa5 = za5;
				var fb5 = zb5;
				var theta6 = Math.abs(beta - gamma1);
				var clockwise5 = beta < gamma1;
				var dif7 = clockwise5 ? theta6 : -theta6;
				dif5 = dif7 < 0 ? dif7 : -2 * Math.PI + dif7;
				break;
			case 2:
				var f13;
				if(beta >= 0 && beta > Math.PI) {
					f13 = beta;
				} else {
					var a13 = beta % (2 * Math.PI);
					f13 = a13 >= 0 ? a13 : a13 + 2 * Math.PI;
				}
				var this18 = f13;
				var za6 = this18;
				var f14;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f14 = gamma1;
				} else {
					var a14 = gamma1 % (2 * Math.PI);
					f14 = a14 >= 0 ? a14 : a14 + 2 * Math.PI;
				}
				var this19 = f14;
				var zb6 = this19;
				var fa6 = beta;
				var fb6 = gamma1;
				var theta7 = Math.abs(beta - gamma1);
				var smallest1 = theta7 <= Math.PI;
				var clockwise6 = beta < gamma1;
				var dif8 = clockwise6 ? theta7 : -theta7;
				dif5 = smallest1 ? dif8 : clockwise6 ? -(2 * Math.PI - theta7) : 2 * Math.PI - theta7;
				break;
			case 3:
				var f15;
				if(beta >= 0 && beta > Math.PI) {
					f15 = beta;
				} else {
					var a15 = beta % (2 * Math.PI);
					f15 = a15 >= 0 ? a15 : a15 + 2 * Math.PI;
				}
				var this20 = f15;
				var za7 = this20;
				var f16;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f16 = gamma1;
				} else {
					var a16 = gamma1 % (2 * Math.PI);
					f16 = a16 >= 0 ? a16 : a16 + 2 * Math.PI;
				}
				var this21 = f16;
				var zb7 = this21;
				var fa7 = beta;
				var fb7 = gamma1;
				var theta8 = Math.abs(beta - gamma1);
				var largest1 = theta8 > Math.PI;
				var clockwise7 = beta < gamma1;
				var dif9 = clockwise7 ? theta8 : -theta8;
				dif5 = largest1 ? dif9 : clockwise7 ? -(2 * Math.PI - theta8) : 2 * Math.PI - theta8;
				break;
			}
			var positive = dif5 >= 0;
			var totalSteps = Math.ceil(Math.abs(dif5) / step);
			var step1 = dif5 / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					var t2 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
					out[out.length] = t2;
				}
				angle += step1;
				bx = cx;
				by = cy;
			}
			var triArr = out;
			var _g2 = 0;
			while(_g2 < triArr.length) {
				var t3 = triArr[_g2];
				++_g2;
				this10[this10.length] = t3;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g3 = 0;
			var _g11 = p4;
			while(_g3 < _g11) {
				var i1 = _g3++;
				this.pointsAnti[pA++] = temp[len - 2 * i1 + 1];
				this.pointsAnti[pA++] = temp[len - 2 * i1];
			}
			var pC = this.pointsClock.length;
			var _g21 = 0;
			var _g31 = p4;
			while(_g21 < _g31) {
				var i2 = _g21++;
				this.pointsClock[pC++] = temp[i2 * 2 + len + 1];
				this.pointsClock[pC++] = temp[i2 * 2 + len];
			}
		}
		if(overlap) {
			var this22 = this.triArr;
			var tri = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,0);
			this22[this22.length] = tri;
			var this23 = this.triArr;
			var tri1 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,0);
			this23[this23.length] = tri1;
		} else {
			if(this.count != 0) {
				this.addQuads(clockWise,width_);
			}
			this.quadIndex = this.triArr.length;
			if(this.count == 0) {
				this.penultimateAX = this.dxPrev;
				this.penultimateAY = this.dyPrev;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.penultimateCX = this.dx;
				this.penultimateCY = this.dy;
				this.lastClockX = this.exPrev;
				this.lastClockY = this.eyPrev;
				var this24 = this.triArr;
				var tri2 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,0);
				this24[this24.length] = tri2;
				var this25 = this.triArr;
				var tri3 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,0);
				this25[this25.length] = tri3;
			} else {
				if(clockWise && !this.lastClock) {
					this.penultimateAX = this.jx;
					this.penultimateAY = this.jy;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.exPrev;
					this.lastClockY = this.eyPrev;
					var this26 = this.triArr;
					var tri4 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,0);
					this26[this26.length] = tri4;
					var this27 = this.triArr;
					var tri5 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,0);
					this27[this27.length] = tri5;
				}
				if(clockWise && this.lastClock) {
					this.penultimateAX = this.jx;
					this.penultimateAY = this.jy;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.exPrev;
					this.lastClockY = this.eyPrev;
					var this28 = this.triArr;
					var tri6 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,0);
					this28[this28.length] = tri6;
					var this29 = this.triArr;
					var tri7 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,0);
					this29[this29.length] = tri7;
				}
				if(!clockWise && !this.lastClock) {
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.jx;
					this.lastClockY = this.jy;
					this.penultimateAX = this.dxPrev;
					this.penultimateAY = this.dyPrev;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					var this30 = this.triArr;
					var tri8 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.jx,this.jy,0);
					this30[this30.length] = tri8;
					var this31 = this.triArr;
					var tri9 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,0);
					this31[this31.length] = tri9;
				}
				if(!clockWise && this.lastClock) {
					this.penultimateAX = this.dxPrev;
					this.penultimateAY = this.dyPrev;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.jx;
					this.penultimateCY = this.jy;
					this.lastClockX = this.dx;
					this.lastClockY = this.dy;
					var this32 = this.triArr;
					var tri10 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,0);
					this32[this32.length] = tri10;
					var this33 = this.triArr;
					var tri11 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.jx,this.jy,this.ex,this.ey,0);
					this33[this33.length] = tri11;
				}
			}
		}
		if(curveEnds) {
			if(clockWise) {
				var radius1 = width_ / 2;
				var edgePoly = this.pointsClock;
				var t4 = [];
				var this34;
				if(t4 == null) {
					var t5 = [];
					var this35 = t5 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t5;
					this34 = this35;
				} else {
					this34 = t4;
				}
				var this36 = this34;
				var out1 = this36;
				var pi1 = Math.PI;
				var step2 = pi1 * 2 / 36;
				var positive1 = dif >= 0;
				var totalSteps1 = Math.ceil(Math.abs(dif) / step2);
				var step3 = dif / totalSteps1;
				var angle1 = theta0;
				var cx1;
				var cy1;
				var bx1 = 0;
				var by1 = 0;
				var p21 = edgePoly.length;
				var count = 0;
				var _g4 = 0;
				var _g12 = totalSteps1 + 1;
				while(_g4 < _g12) {
					var i3 = _g4++;
					cx1 = ax_ + radius1 * Math.sin(angle1);
					cy1 = ay_ + radius1 * Math.cos(angle1);
					if(i3 != 0) {
						var t6 = new trilateral_tri_Trilateral(ax_,ay_,bx1,by1,cx1,cy1);
						out1[out1.length] = t6;
						edgePoly[p21++] = cx1;
						edgePoly[p21++] = cy1;
					}
					angle1 += step3;
					bx1 = cx1;
					by1 = cy1;
				}
				var trilateralArray = out1;
				var this37 = this.triArr;
				var _g5 = 0;
				while(_g5 < trilateralArray.length) {
					var t7 = trilateralArray[_g5];
					++_g5;
					this37[this37.length] = t7;
				}
			} else {
				var radius2 = width_ / 2;
				var edgePoly1 = this.pointsAnti;
				var t8 = [];
				var this38;
				if(t8 == null) {
					var t9 = [];
					var this39 = t9 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t9;
					this38 = this39;
				} else {
					this38 = t8;
				}
				var this40 = this38;
				var out2 = this40;
				var pi2 = Math.PI;
				var step4 = pi2 * 2 / 36;
				var positive2 = dif >= 0;
				var totalSteps2 = Math.ceil(Math.abs(dif) / step4);
				var step5 = dif / totalSteps2;
				var angle2 = theta0;
				var cx2;
				var cy2;
				var bx2 = 0;
				var by2 = 0;
				var p22 = edgePoly1.length;
				var count1 = 0;
				var _g6 = 0;
				var _g13 = totalSteps2 + 1;
				while(_g6 < _g13) {
					var i4 = _g6++;
					cx2 = ax_ + radius2 * Math.sin(angle2);
					cy2 = ay_ + radius2 * Math.cos(angle2);
					if(i4 != 0) {
						var t10 = new trilateral_tri_Trilateral(ax_,ay_,bx2,by2,cx2,cy2);
						out2[out2.length] = t10;
						edgePoly1[p22++] = cx2;
						edgePoly1[p22++] = cy2;
					}
					angle2 += step5;
					bx2 = cx2;
					by2 = cy2;
				}
				var trilateralArray1 = out2;
				var this41 = this.triArr;
				var _g7 = 0;
				while(_g7 < trilateralArray1.length) {
					var t11 = trilateralArray1[_g7];
					++_g7;
					this41[this41.length] = t11;
				}
			}
		} else if(this.count != 0) {
			if(overlap) {
				if(clockWise) {
					var this42 = this.triArr;
					var tri12 = new trilateral_tri_Trilateral(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.ax,this.ay,0);
					this42[this42.length] = tri12;
				} else {
					var this43 = this.triArr;
					var tri13 = new trilateral_tri_Trilateral(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.ax,this.ay,0);
					this43[this43.length] = tri13;
				}
			} else if(clockWise) {
				var this44 = this.triArr;
				var tri14 = new trilateral_tri_Trilateral(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.jx,this.jy,0);
				this44[this44.length] = tri14;
			} else {
				var this45 = this.triArr;
				var tri15 = new trilateral_tri_Trilateral(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.jx,this.jy,0);
				this45[this45.length] = tri15;
			}
		}
		this.kax = this.dxPrev;
		this.kay = this.dyPrev;
		this.kbx = this.dx;
		this.kby = this.dy;
		this.ncx = this.exPrev;
		this.ncy = this.eyPrev;
		this.kcx = this.ex;
		this.kcy = this.ey;
		if(curveEnds && !overlap && this.count != 0) {
			if(clockWise) {
				var this46 = this.triArr;
				var tri16 = new trilateral_tri_Trilateral(this.ax,this.ay,this.dxOld,this.dyOld,this.jx,this.jy,0);
				this46[this46.length] = tri16;
				var this47 = this.triArr;
				var tri17 = new trilateral_tri_Trilateral(this.ax,this.ay,this.exPrev,this.eyPrev,this.jx,this.jy,0);
				this47[this47.length] = tri17;
			} else {
				var this48 = this.triArr;
				var tri18 = new trilateral_tri_Trilateral(this.ax,this.ay,this.exOld,this.eyOld,this.jx,this.jy,0);
				this48[this48.length] = tri18;
				var this49 = this.triArr;
				var tri19 = new trilateral_tri_Trilateral(this.ax,this.ay,this.dxPrev,this.dyPrev,this.jx,this.jy,0);
				this49[this49.length] = tri19;
			}
		}
		this.jxOld = this.jx;
		this.jyOld = this.jy;
		this.lastClock = clockWise;
		this.count++;
		return this.triArr;
	}
	,overlapQuad: function() {
		var this1 = this.triArr;
		var tri = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,0);
		this1[this1.length] = tri;
		var this2 = this.triArr;
		var tri1 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,0);
		this2[this2.length] = tri1;
	}
	,end: function(width_) {
		this.endEdges();
		if(this.count != 0) {
			var ax = this.bx;
			var ay = this.by;
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var temp = [];
			var this1 = this.triArr;
			var t = [];
			var this2;
			if(t == null) {
				var t1 = [];
				var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
				this2 = this3;
			} else {
				this2 = t;
			}
			var this4 = this2;
			var out = this4;
			var pi = Math.PI;
			var step = pi * 2 / 36;
			var dif;
			switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this5 = f;
				var za = this5;
				var f1;
				if(gamma >= 0 && gamma > Math.PI) {
					f1 = gamma;
				} else {
					var a1 = gamma % (2 * Math.PI);
					f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
				}
				var this6 = f1;
				var zb = this6;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(beta - gamma);
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f2;
				if(beta >= 0 && beta > Math.PI) {
					f2 = beta;
				} else {
					var a2 = beta % (2 * Math.PI);
					f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
				}
				var this7 = f2;
				var za1 = this7;
				var f3;
				if(gamma >= 0 && gamma > Math.PI) {
					f3 = gamma;
				} else {
					var a3 = gamma % (2 * Math.PI);
					f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
				}
				var this8 = f3;
				var zb1 = this8;
				var fa1 = za1;
				var fb1 = zb1;
				var theta1 = Math.abs(beta - gamma);
				var clockwise1 = beta < gamma;
				var dif2 = clockwise1 ? theta1 : -theta1;
				dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
				break;
			case 2:
				var f4;
				if(beta >= 0 && beta > Math.PI) {
					f4 = beta;
				} else {
					var a4 = beta % (2 * Math.PI);
					f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
				}
				var this9 = f4;
				var za2 = this9;
				var f5;
				if(gamma >= 0 && gamma > Math.PI) {
					f5 = gamma;
				} else {
					var a5 = gamma % (2 * Math.PI);
					f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
				}
				var this10 = f5;
				var zb2 = this10;
				var fa2 = beta;
				var fb2 = gamma;
				var theta2 = Math.abs(beta - gamma);
				var smallest = theta2 <= Math.PI;
				var clockwise2 = beta < gamma;
				var dif3 = clockwise2 ? theta2 : -theta2;
				dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
				break;
			case 3:
				var f6;
				if(beta >= 0 && beta > Math.PI) {
					f6 = beta;
				} else {
					var a6 = beta % (2 * Math.PI);
					f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
				}
				var this11 = f6;
				var za3 = this11;
				var f7;
				if(gamma >= 0 && gamma > Math.PI) {
					f7 = gamma;
				} else {
					var a7 = gamma % (2 * Math.PI);
					f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
				}
				var this12 = f7;
				var zb3 = this12;
				var fa3 = beta;
				var fb3 = gamma;
				var theta3 = Math.abs(beta - gamma);
				var largest = theta3 > Math.PI;
				var clockwise3 = beta < gamma;
				var dif4 = clockwise3 ? theta3 : -theta3;
				dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step1 = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					var t2 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
					out[out.length] = t2;
				}
				angle += step1;
				bx = cx;
				by = cy;
			}
			var triArr = out;
			var _g2 = 0;
			while(_g2 < triArr.length) {
				var t3 = triArr[_g2];
				++_g2;
				this1[this1.length] = t3;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var _g3 = 0;
			var _g11 = len + 2;
			while(_g3 < _g11) {
				var i1 = _g3++;
				this.pointsAnti[pA++] = temp[i1];
			}
			var pC = this.pointsClock.length;
			var _g21 = 1;
			var _g31 = len / 2 + 1 | 0;
			while(_g21 < _g31) {
				var i2 = _g21++;
				this.pointsClock[pC++] = temp[temp.length - 2 * i2];
				this.pointsClock[pC++] = temp[temp.length - 2 * i2 - 1];
			}
		}
	}
	,add: function(trilateral1) {
		var this1 = this.triArr;
		this1[this1.length] = trilateral1;
	}
	,addArray: function(trilateralArray) {
		var this1 = this.triArr;
		var _g = 0;
		while(_g < trilateralArray.length) {
			var t = trilateralArray[_g];
			++_g;
			this1[this1.length] = t;
		}
	}
	,addTri: function(ax_,ay_,bx_,by_,cx_,cy_,mark_) {
		if(mark_ == null) {
			mark_ = 0;
		}
		var this1 = this.triArr;
		var tri = new trilateral_tri_Trilateral(ax_,ay_,bx_,by_,cx_,cy_,mark_);
		this1[this1.length] = tri;
	}
	,addPieXstart: function(ax,ay,radius,beta,gamma,prefer,mark,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(mark == null) {
			mark = 0;
		}
		var temp = [];
		var this1 = this.triArr;
		var t = [];
		var this2;
		if(t == null) {
			var t1 = [];
			var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this2 = this3;
		} else {
			this2 = t;
		}
		var this4 = this2;
		var out = this4;
		var pi = Math.PI;
		var step = pi * 2 / sides;
		var dif;
		switch(prefer._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this5 = f;
			var za = this5;
			var f1;
			if(gamma >= 0 && gamma > Math.PI) {
				f1 = gamma;
			} else {
				var a1 = gamma % (2 * Math.PI);
				f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
			}
			var this6 = f1;
			var zb = this6;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(beta - gamma);
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f2;
			if(beta >= 0 && beta > Math.PI) {
				f2 = beta;
			} else {
				var a2 = beta % (2 * Math.PI);
				f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
			}
			var this7 = f2;
			var za1 = this7;
			var f3;
			if(gamma >= 0 && gamma > Math.PI) {
				f3 = gamma;
			} else {
				var a3 = gamma % (2 * Math.PI);
				f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
			}
			var this8 = f3;
			var zb1 = this8;
			var fa1 = za1;
			var fb1 = zb1;
			var theta1 = Math.abs(beta - gamma);
			var clockwise1 = beta < gamma;
			var dif2 = clockwise1 ? theta1 : -theta1;
			dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
			break;
		case 2:
			var f4;
			if(beta >= 0 && beta > Math.PI) {
				f4 = beta;
			} else {
				var a4 = beta % (2 * Math.PI);
				f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
			}
			var this9 = f4;
			var za2 = this9;
			var f5;
			if(gamma >= 0 && gamma > Math.PI) {
				f5 = gamma;
			} else {
				var a5 = gamma % (2 * Math.PI);
				f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
			}
			var this10 = f5;
			var zb2 = this10;
			var fa2 = beta;
			var fb2 = gamma;
			var theta2 = Math.abs(beta - gamma);
			var smallest = theta2 <= Math.PI;
			var clockwise2 = beta < gamma;
			var dif3 = clockwise2 ? theta2 : -theta2;
			dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
			break;
		case 3:
			var f6;
			if(beta >= 0 && beta > Math.PI) {
				f6 = beta;
			} else {
				var a6 = beta % (2 * Math.PI);
				f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
			}
			var this11 = f6;
			var za3 = this11;
			var f7;
			if(gamma >= 0 && gamma > Math.PI) {
				f7 = gamma;
			} else {
				var a7 = gamma % (2 * Math.PI);
				f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
			}
			var this12 = f7;
			var zb3 = this12;
			var fa3 = beta;
			var fb3 = gamma;
			var theta3 = Math.abs(beta - gamma);
			var largest = theta3 > Math.PI;
			var clockwise3 = beta < gamma;
			var dif4 = clockwise3 ? theta3 : -theta3;
			dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step1 = dif / totalSteps;
		var angle = beta;
		var cx;
		var cy;
		var bx = 0;
		var by = 0;
		var p2 = temp.length;
		var _g = 0;
		var _g1 = totalSteps + 1;
		while(_g < _g1) {
			var i = _g++;
			cx = ax + radius * Math.sin(angle);
			cy = ay + radius * Math.cos(angle);
			temp[p2++] = cx;
			temp[p2++] = cy;
			if(i != 0) {
				var t2 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
				out[out.length] = t2;
				if(mark != 0) {
					t2.mark = mark;
				}
			}
			angle += step1;
			bx = cx;
			by = cy;
		}
		var triArr = out;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t3 = triArr[_g2];
			++_g2;
			this1[this1.length] = t3;
		}
		var pA = this.pointsAnti.length;
		var len = temp.length / 2 | 0;
		var p4 = temp.length / 4 | 0;
		var _g3 = 0;
		var _g11 = p4;
		while(_g3 < _g11) {
			var i1 = _g3++;
			this.pointsAnti[pA++] = temp[len - 2 * i1 + 1];
			this.pointsAnti[pA++] = temp[len - 2 * i1];
		}
		var pC = this.pointsClock.length;
		var _g21 = 0;
		var _g31 = p4;
		while(_g21 < _g31) {
			var i2 = _g21++;
			this.pointsClock[pC++] = temp[i2 * 2 + len + 1];
			this.pointsClock[pC++] = temp[i2 * 2 + len];
		}
	}
	,addPieX: function(ax,ay,radius,beta,gamma,prefer,mark,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(mark == null) {
			mark = 0;
		}
		var temp = [];
		var this1 = this.triArr;
		var t = [];
		var this2;
		if(t == null) {
			var t1 = [];
			var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this2 = this3;
		} else {
			this2 = t;
		}
		var this4 = this2;
		var out = this4;
		var pi = Math.PI;
		var step = pi * 2 / sides;
		var dif;
		switch(prefer._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this5 = f;
			var za = this5;
			var f1;
			if(gamma >= 0 && gamma > Math.PI) {
				f1 = gamma;
			} else {
				var a1 = gamma % (2 * Math.PI);
				f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
			}
			var this6 = f1;
			var zb = this6;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(beta - gamma);
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f2;
			if(beta >= 0 && beta > Math.PI) {
				f2 = beta;
			} else {
				var a2 = beta % (2 * Math.PI);
				f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
			}
			var this7 = f2;
			var za1 = this7;
			var f3;
			if(gamma >= 0 && gamma > Math.PI) {
				f3 = gamma;
			} else {
				var a3 = gamma % (2 * Math.PI);
				f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
			}
			var this8 = f3;
			var zb1 = this8;
			var fa1 = za1;
			var fb1 = zb1;
			var theta1 = Math.abs(beta - gamma);
			var clockwise1 = beta < gamma;
			var dif2 = clockwise1 ? theta1 : -theta1;
			dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
			break;
		case 2:
			var f4;
			if(beta >= 0 && beta > Math.PI) {
				f4 = beta;
			} else {
				var a4 = beta % (2 * Math.PI);
				f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
			}
			var this9 = f4;
			var za2 = this9;
			var f5;
			if(gamma >= 0 && gamma > Math.PI) {
				f5 = gamma;
			} else {
				var a5 = gamma % (2 * Math.PI);
				f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
			}
			var this10 = f5;
			var zb2 = this10;
			var fa2 = beta;
			var fb2 = gamma;
			var theta2 = Math.abs(beta - gamma);
			var smallest = theta2 <= Math.PI;
			var clockwise2 = beta < gamma;
			var dif3 = clockwise2 ? theta2 : -theta2;
			dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
			break;
		case 3:
			var f6;
			if(beta >= 0 && beta > Math.PI) {
				f6 = beta;
			} else {
				var a6 = beta % (2 * Math.PI);
				f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
			}
			var this11 = f6;
			var za3 = this11;
			var f7;
			if(gamma >= 0 && gamma > Math.PI) {
				f7 = gamma;
			} else {
				var a7 = gamma % (2 * Math.PI);
				f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
			}
			var this12 = f7;
			var zb3 = this12;
			var fa3 = beta;
			var fb3 = gamma;
			var theta3 = Math.abs(beta - gamma);
			var largest = theta3 > Math.PI;
			var clockwise3 = beta < gamma;
			var dif4 = clockwise3 ? theta3 : -theta3;
			dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step1 = dif / totalSteps;
		var angle = beta;
		var cx;
		var cy;
		var bx = 0;
		var by = 0;
		var p2 = temp.length;
		var _g = 0;
		var _g1 = totalSteps + 1;
		while(_g < _g1) {
			var i = _g++;
			cx = ax + radius * Math.sin(angle);
			cy = ay + radius * Math.cos(angle);
			temp[p2++] = cx;
			temp[p2++] = cy;
			if(i != 0) {
				var t2 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
				out[out.length] = t2;
				if(mark != 0) {
					t2.mark = mark;
				}
			}
			angle += step1;
			bx = cx;
			by = cy;
		}
		var triArr = out;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t3 = triArr[_g2];
			++_g2;
			this1[this1.length] = t3;
		}
		var pA = this.pointsAnti.length;
		var len = temp.length / 2 | 0;
		var _g3 = 0;
		var _g11 = len + 2;
		while(_g3 < _g11) {
			var i1 = _g3++;
			this.pointsAnti[pA++] = temp[i1];
		}
		var pC = this.pointsClock.length;
		var _g21 = 1;
		var _g31 = len / 2 + 1 | 0;
		while(_g21 < _g31) {
			var i2 = _g21++;
			this.pointsClock[pC++] = temp[temp.length - 2 * i2];
			this.pointsClock[pC++] = temp[temp.length - 2 * i2 - 1];
		}
	}
	,addPie: function(ax,ay,radius,beta,gamma,prefer,mark,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(mark == null) {
			mark = 0;
		}
		var this1 = this.triArr;
		var t = [];
		var this2;
		if(t == null) {
			var t1 = [];
			var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this2 = this3;
		} else {
			this2 = t;
		}
		var this4 = this2;
		var out = this4;
		var pi = Math.PI;
		var step = pi * 2 / sides;
		var dif;
		switch(prefer._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this5 = f;
			var za = this5;
			var f1;
			if(gamma >= 0 && gamma > Math.PI) {
				f1 = gamma;
			} else {
				var a1 = gamma % (2 * Math.PI);
				f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
			}
			var this6 = f1;
			var zb = this6;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(beta - gamma);
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f2;
			if(beta >= 0 && beta > Math.PI) {
				f2 = beta;
			} else {
				var a2 = beta % (2 * Math.PI);
				f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
			}
			var this7 = f2;
			var za1 = this7;
			var f3;
			if(gamma >= 0 && gamma > Math.PI) {
				f3 = gamma;
			} else {
				var a3 = gamma % (2 * Math.PI);
				f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
			}
			var this8 = f3;
			var zb1 = this8;
			var fa1 = za1;
			var fb1 = zb1;
			var theta1 = Math.abs(beta - gamma);
			var clockwise1 = beta < gamma;
			var dif2 = clockwise1 ? theta1 : -theta1;
			dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
			break;
		case 2:
			var f4;
			if(beta >= 0 && beta > Math.PI) {
				f4 = beta;
			} else {
				var a4 = beta % (2 * Math.PI);
				f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
			}
			var this9 = f4;
			var za2 = this9;
			var f5;
			if(gamma >= 0 && gamma > Math.PI) {
				f5 = gamma;
			} else {
				var a5 = gamma % (2 * Math.PI);
				f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
			}
			var this10 = f5;
			var zb2 = this10;
			var fa2 = beta;
			var fb2 = gamma;
			var theta2 = Math.abs(beta - gamma);
			var smallest = theta2 <= Math.PI;
			var clockwise2 = beta < gamma;
			var dif3 = clockwise2 ? theta2 : -theta2;
			dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
			break;
		case 3:
			var f6;
			if(beta >= 0 && beta > Math.PI) {
				f6 = beta;
			} else {
				var a6 = beta % (2 * Math.PI);
				f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
			}
			var this11 = f6;
			var za3 = this11;
			var f7;
			if(gamma >= 0 && gamma > Math.PI) {
				f7 = gamma;
			} else {
				var a7 = gamma % (2 * Math.PI);
				f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
			}
			var this12 = f7;
			var zb3 = this12;
			var fa3 = beta;
			var fb3 = gamma;
			var theta3 = Math.abs(beta - gamma);
			var largest = theta3 > Math.PI;
			var clockwise3 = beta < gamma;
			var dif4 = clockwise3 ? theta3 : -theta3;
			dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step1 = dif / totalSteps;
		var angle = beta;
		var cx;
		var cy;
		var bx = 0;
		var by = 0;
		var _g = 0;
		var _g1 = totalSteps + 1;
		while(_g < _g1) {
			var i = _g++;
			cx = ax + radius * Math.sin(angle);
			cy = ay + radius * Math.cos(angle);
			if(i != 0) {
				var t2 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
				out[out.length] = t2;
				if(mark != 0) {
					t2.mark = mark;
				}
			}
			angle += step1;
			bx = cx;
			by = cy;
		}
		var triArr = out;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t3 = triArr[_g2];
			++_g2;
			this1[this1.length] = t3;
		}
	}
	,computeJ: function(width_,theta0,dif) {
		var gamma = Math.abs(dif) / 2;
		var h = width_ / 2 / Math.cos(gamma);
		var f;
		if(theta0 <= Math.PI && theta0 > -Math.PI) {
			f = theta0;
		} else {
			var a = (theta0 + Math.PI) % (2 * Math.PI);
			f = a >= 0 ? a - Math.PI : a + Math.PI;
		}
		var this1 = f;
		var start = this1;
		var start2 = start;
		var delta = start2 + dif / 2 + Math.PI;
		this.jx = this.ax + h * Math.sin(delta);
		this.jy = this.ay + h * Math.cos(delta);
	}
	,addDot: function(x,y,color,width_) {
		var w = width_ * 0.07;
		var t = [];
		var this1;
		if(t == null) {
			var t1 = [];
			var this2 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this1 = this2;
		} else {
			this1 = t;
		}
		var this3 = this1;
		var out = this3;
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx;
		var by;
		var cx;
		var cy;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = x + w * Math.sin(theta);
			by = y + w * Math.cos(theta);
			theta += step;
			cx = x + w * Math.sin(theta);
			cy = y + w * Math.cos(theta);
			var t2 = new trilateral_tri_Trilateral(x,y,bx,by,cx,cy);
			out[out.length] = t2;
			t2.mark = color;
		}
		var trilateralArray = out;
		var this4 = this.triArr;
		var _g2 = 0;
		while(_g2 < trilateralArray.length) {
			var t3 = trilateralArray[_g2];
			++_g2;
			this4[this4.length] = t3;
		}
	}
	,addSmallTriangles: function(clockWise,width_) {
		if(clockWise) {
			var this1 = this.triArr;
			var tri = new trilateral_tri_Trilateral(this.ax,this.ay,this.dxOld,this.dyOld,this.jx,this.jy,0);
			this1[this1.length] = tri;
			var this2 = this.triArr;
			var tri1 = new trilateral_tri_Trilateral(this.ax,this.ay,this.exPrev,this.eyPrev,this.jx,this.jy,0);
			this2[this2.length] = tri1;
		} else {
			var this3 = this.triArr;
			var tri2 = new trilateral_tri_Trilateral(this.ax,this.ay,this.exOld,this.eyOld,this.jx,this.jy,0);
			this3[this3.length] = tri2;
			var this4 = this.triArr;
			var tri3 = new trilateral_tri_Trilateral(this.ax,this.ay,this.dxPrev,this.dyPrev,this.jx,this.jy,0);
			this4[this4.length] = tri3;
		}
	}
	,addTriangleCorners: function(oldx_,oldy_,prevx_,prevy_,width_) {
		var w = width_ * 0.07;
		var t = [];
		var this1;
		if(t == null) {
			var t1 = [];
			var this2 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this1 = this2;
		} else {
			this1 = t;
		}
		var this3 = this1;
		var out = this3;
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx;
		var by;
		var cx;
		var cy;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = oldx_ + w * Math.sin(theta);
			by = oldy_ + w * Math.cos(theta);
			theta += step;
			cx = oldx_ + w * Math.sin(theta);
			cy = oldy_ + w * Math.cos(theta);
			var t2 = new trilateral_tri_Trilateral(oldx_,oldy_,bx,by,cx,cy);
			out[out.length] = t2;
			t2.mark = 4;
		}
		var trilateralArray = out;
		var this4 = this.triArr;
		var _g2 = 0;
		while(_g2 < trilateralArray.length) {
			var t3 = trilateralArray[_g2];
			++_g2;
			this4[this4.length] = t3;
		}
		var t4 = [];
		var this5;
		if(t4 == null) {
			var t5 = [];
			var this6 = t5 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t5;
			this5 = this6;
		} else {
			this5 = t4;
		}
		var this7 = this5;
		var out1 = this7;
		var pi1 = Math.PI;
		var theta1 = pi1 / 2;
		var step1 = pi1 * 2 / 36;
		var bx1;
		var by1;
		var cx1;
		var cy1;
		var _g3 = 0;
		var _g11 = 36;
		while(_g3 < _g11) {
			var i1 = _g3++;
			bx1 = prevx_ + w * Math.sin(theta1);
			by1 = prevy_ + w * Math.cos(theta1);
			theta1 += step1;
			cx1 = prevx_ + w * Math.sin(theta1);
			cy1 = prevy_ + w * Math.cos(theta1);
			var t6 = new trilateral_tri_Trilateral(prevx_,prevy_,bx1,by1,cx1,cy1);
			out1[out1.length] = t6;
			t6.mark = 3;
		}
		var trilateralArray1 = out1;
		var this8 = this.triArr;
		var _g4 = 0;
		while(_g4 < trilateralArray1.length) {
			var t7 = trilateralArray1[_g4];
			++_g4;
			this8[this8.length] = t7;
		}
		var ax = this.ax;
		var ay = this.ay;
		var t8 = [];
		var this9;
		if(t8 == null) {
			var t9 = [];
			var this10 = t9 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t9;
			this9 = this10;
		} else {
			this9 = t8;
		}
		var this11 = this9;
		var out2 = this11;
		var pi2 = Math.PI;
		var theta2 = pi2 / 2;
		var step2 = pi2 * 2 / 36;
		var bx2;
		var by2;
		var cx2;
		var cy2;
		var _g5 = 0;
		var _g12 = 36;
		while(_g5 < _g12) {
			var i2 = _g5++;
			bx2 = ax + w * Math.sin(theta2);
			by2 = ay + w * Math.cos(theta2);
			theta2 += step2;
			cx2 = ax + w * Math.sin(theta2);
			cy2 = ay + w * Math.cos(theta2);
			var t10 = new trilateral_tri_Trilateral(ax,ay,bx2,by2,cx2,cy2);
			out2[out2.length] = t10;
			t10.mark = 10;
		}
		var trilateralArray2 = out2;
		var this12 = this.triArr;
		var _g6 = 0;
		while(_g6 < trilateralArray2.length) {
			var t11 = trilateralArray2[_g6];
			++_g6;
			this12[this12.length] = t11;
		}
		var ax1 = this.jx;
		var ay1 = this.jy;
		var t12 = [];
		var this13;
		if(t12 == null) {
			var t13 = [];
			var this14 = t13 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t13;
			this13 = this14;
		} else {
			this13 = t12;
		}
		var this15 = this13;
		var out3 = this15;
		var pi3 = Math.PI;
		var theta3 = pi3 / 2;
		var step3 = pi3 * 2 / 36;
		var bx3;
		var by3;
		var cx3;
		var cy3;
		var _g7 = 0;
		var _g13 = 36;
		while(_g7 < _g13) {
			var i3 = _g7++;
			bx3 = ax1 + w * Math.sin(theta3);
			by3 = ay1 + w * Math.cos(theta3);
			theta3 += step3;
			cx3 = ax1 + w * Math.sin(theta3);
			cy3 = ay1 + w * Math.cos(theta3);
			var t14 = new trilateral_tri_Trilateral(ax1,ay1,bx3,by3,cx3,cy3);
			out3[out3.length] = t14;
			t14.mark = 5;
		}
		var trilateralArray3 = out3;
		var this16 = this.triArr;
		var _g8 = 0;
		while(_g8 < trilateralArray3.length) {
			var t15 = trilateralArray3[_g8];
			++_g8;
			this16[this16.length] = t15;
		}
	}
	,addTriangleCornersLess: function(oldx_,oldy_,prevx_,prevy_,width_) {
		var w = width_ * 0.07;
		var t = [];
		var this1;
		if(t == null) {
			var t1 = [];
			var this2 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this1 = this2;
		} else {
			this1 = t;
		}
		var this3 = this1;
		var out = this3;
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx;
		var by;
		var cx;
		var cy;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = oldx_ + w * Math.sin(theta);
			by = oldy_ + w * Math.cos(theta);
			theta += step;
			cx = oldx_ + w * Math.sin(theta);
			cy = oldy_ + w * Math.cos(theta);
			var t2 = new trilateral_tri_Trilateral(oldx_,oldy_,bx,by,cx,cy);
			out[out.length] = t2;
			t2.mark = 4;
		}
		var trilateralArray = out;
		var this4 = this.triArr;
		var _g2 = 0;
		while(_g2 < trilateralArray.length) {
			var t3 = trilateralArray[_g2];
			++_g2;
			this4[this4.length] = t3;
		}
		var t4 = [];
		var this5;
		if(t4 == null) {
			var t5 = [];
			var this6 = t5 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t5;
			this5 = this6;
		} else {
			this5 = t4;
		}
		var this7 = this5;
		var out1 = this7;
		var pi1 = Math.PI;
		var theta1 = pi1 / 2;
		var step1 = pi1 * 2 / 36;
		var bx1;
		var by1;
		var cx1;
		var cy1;
		var _g3 = 0;
		var _g11 = 36;
		while(_g3 < _g11) {
			var i1 = _g3++;
			bx1 = prevx_ + w * Math.sin(theta1);
			by1 = prevy_ + w * Math.cos(theta1);
			theta1 += step1;
			cx1 = prevx_ + w * Math.sin(theta1);
			cy1 = prevy_ + w * Math.cos(theta1);
			var t6 = new trilateral_tri_Trilateral(prevx_,prevy_,bx1,by1,cx1,cy1);
			out1[out1.length] = t6;
			t6.mark = 3;
		}
		var trilateralArray1 = out1;
		var this8 = this.triArr;
		var _g4 = 0;
		while(_g4 < trilateralArray1.length) {
			var t7 = trilateralArray1[_g4];
			++_g4;
			this8[this8.length] = t7;
		}
		var ax = this.jx;
		var ay = this.jy;
		var t8 = [];
		var this9;
		if(t8 == null) {
			var t9 = [];
			var this10 = t9 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t9;
			this9 = this10;
		} else {
			this9 = t8;
		}
		var this11 = this9;
		var out2 = this11;
		var pi2 = Math.PI;
		var theta2 = pi2 / 2;
		var step2 = pi2 * 2 / 36;
		var bx2;
		var by2;
		var cx2;
		var cy2;
		var _g5 = 0;
		var _g12 = 36;
		while(_g5 < _g12) {
			var i2 = _g5++;
			bx2 = ax + w * Math.sin(theta2);
			by2 = ay + w * Math.cos(theta2);
			theta2 += step2;
			cx2 = ax + w * Math.sin(theta2);
			cy2 = ay + w * Math.cos(theta2);
			var t10 = new trilateral_tri_Trilateral(ax,ay,bx2,by2,cx2,cy2);
			out2[out2.length] = t10;
			t10.mark = 5;
		}
		var trilateralArray2 = out2;
		var this12 = this.triArr;
		var _g6 = 0;
		while(_g6 < trilateralArray2.length) {
			var t11 = trilateralArray2[_g6];
			++_g6;
			this12[this12.length] = t11;
		}
	}
	,connectQuadsWhenQuadsOverlay: function(clockWise,width_) {
		if(clockWise) {
			var this1 = this.triArr;
			var tri = new trilateral_tri_Trilateral(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.ax,this.ay,0);
			this1[this1.length] = tri;
		} else {
			var this2 = this.triArr;
			var tri1 = new trilateral_tri_Trilateral(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.ax,this.ay,0);
			this2[this2.length] = tri1;
		}
	}
	,connectQuads: function(clockWise,width_) {
		if(clockWise) {
			var this1 = this.triArr;
			var tri = new trilateral_tri_Trilateral(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.jx,this.jy,0);
			this1[this1.length] = tri;
		} else {
			var this2 = this.triArr;
			var tri1 = new trilateral_tri_Trilateral(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.jx,this.jy,0);
			this2[this2.length] = tri1;
		}
	}
	,addInitialQuads: function(clockWise,width_) {
		this.quadIndex = this.triArr.length;
		if(this.count == 0) {
			this.penultimateAX = this.dxPrev;
			this.penultimateAY = this.dyPrev;
			this.lastAntiX = this.ex;
			this.lastAntiY = this.ey;
			this.penultimateCX = this.dx;
			this.penultimateCY = this.dy;
			this.lastClockX = this.exPrev;
			this.lastClockY = this.eyPrev;
			var this1 = this.triArr;
			var tri = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,0);
			this1[this1.length] = tri;
			var this2 = this.triArr;
			var tri1 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,0);
			this2[this2.length] = tri1;
		} else {
			if(clockWise && !this.lastClock) {
				this.penultimateAX = this.jx;
				this.penultimateAY = this.jy;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.penultimateCX = this.dx;
				this.penultimateCY = this.dy;
				this.lastClockX = this.exPrev;
				this.lastClockY = this.eyPrev;
				var this3 = this.triArr;
				var tri2 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,0);
				this3[this3.length] = tri2;
				var this4 = this.triArr;
				var tri3 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,0);
				this4[this4.length] = tri3;
			}
			if(clockWise && this.lastClock) {
				this.penultimateAX = this.jx;
				this.penultimateAY = this.jy;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.penultimateCX = this.dx;
				this.penultimateCY = this.dy;
				this.lastClockX = this.exPrev;
				this.lastClockY = this.eyPrev;
				var this5 = this.triArr;
				var tri4 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,0);
				this5[this5.length] = tri4;
				var this6 = this.triArr;
				var tri5 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,0);
				this6[this6.length] = tri5;
			}
			if(!clockWise && !this.lastClock) {
				this.penultimateCX = this.dx;
				this.penultimateCY = this.dy;
				this.lastClockX = this.jx;
				this.lastClockY = this.jy;
				this.penultimateAX = this.dxPrev;
				this.penultimateAY = this.dyPrev;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				var this7 = this.triArr;
				var tri6 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.jx,this.jy,0);
				this7[this7.length] = tri6;
				var this8 = this.triArr;
				var tri7 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,0);
				this8[this8.length] = tri7;
			}
			if(!clockWise && this.lastClock) {
				this.penultimateAX = this.dxPrev;
				this.penultimateAY = this.dyPrev;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.penultimateCX = this.jx;
				this.penultimateCY = this.jy;
				this.lastClockX = this.dx;
				this.lastClockY = this.dy;
				var this9 = this.triArr;
				var tri8 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,0);
				this9[this9.length] = tri8;
				var this10 = this.triArr;
				var tri9 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.jx,this.jy,this.ex,this.ey,0);
				this10[this10.length] = tri9;
			}
		}
	}
	,endEdges: function() {
		var pC = this.pointsClock.length;
		var pA = this.pointsAnti.length;
		this.pointsClock[pC++] = this.penultimateCX;
		this.pointsClock[pC++] = this.penultimateCY;
		this.pointsClock[pC++] = this.lastClockX;
		this.pointsClock[pC++] = this.lastClockY;
		this.pointsAnti[pA++] = this.penultimateAX;
		this.pointsAnti[pA++] = this.penultimateAY;
		this.pointsAnti[pA++] = this.lastAntiX;
		this.pointsAnti[pA++] = this.lastAntiY;
	}
	,addQuads: function(clockWise,width_) {
		var pC = 0;
		var pA = 0;
		if(clockWise && !this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.kax,this.kay,this.kbx,this.kby,this.ncx,this.ncy);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.kax,this.kay,this.kbx,this.kby,this.jxOld,this.jyOld);
			}
			this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.kax,this.kay,this.kbx,this.kby,this.jx,this.jy);
		}
		if(clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				this.pointsAnti[pA++] = this.kbx;
				this.pointsAnti[pA++] = this.kby;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kax;
				this.pointsClock[pC++] = this.kay;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.kax,this.kay,this.kbx,this.kby,this.jx,this.jy);
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.kax,this.kay,this.kbx,this.kby,this.ncx,this.ncy);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.jxOld,this.jyOld,this.kbx,this.kby,this.jx,this.jy);
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.jxOld,this.jyOld,this.kbx,this.kby,this.ncx,this.ncy);
			}
		}
		if(!clockWise && !this.lastClock) {
			this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.kax,this.kay,this.jx,this.jy,this.kcx,this.kcy);
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.kax,this.kay,this.jx,this.jy,this.ncx,this.ncy);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.kax,this.kay,this.jx,this.jy,this.jxOld,this.jyOld);
			}
		}
		if(!clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.kax,this.kay,this.jx,this.jy,this.kcx,this.kcy);
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.kax,this.kay,this.jx,this.jy,this.ncx,this.ncy);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.jxOld,this.jyOld,this.jx,this.jy,this.kcx,this.kcy);
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.jxOld,this.jyOld,this.jx,this.jy,this.ncx,this.ncy);
			}
		}
	}
	,storeLastQuads: function() {
		this.kax = this.dxPrev;
		this.kay = this.dyPrev;
		this.kbx = this.dx;
		this.kby = this.dy;
		this.ncx = this.exPrev;
		this.ncy = this.eyPrev;
		this.kcx = this.ex;
		this.kcy = this.ey;
	}
	,isClockwise: function(x,y) {
		var x1 = this.dxOld - x;
		var y1 = this.dyOld - y;
		var x2 = this.exOld - x;
		var y2 = this.eyOld - y;
		return x1 * x1 + y1 * y1 > x2 * x2 + y2 * y2;
	}
	,line: function(ax_,ay_,bx_,by_,width_,endLineCurve) {
		if(endLineCurve == null) {
			endLineCurve = 0;
		}
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.halfA = Math.PI / 2;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var dxPrev_ = this.dx;
		var dyPrev_ = this.dy;
		var exPrev_ = this.ex;
		var eyPrev_ = this.ey;
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		switch(endLineCurve) {
		case 0:
			break;
		case 1:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var this1 = this.triArr;
			var t = [];
			var this2;
			if(t == null) {
				var t1 = [];
				var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
				this2 = this3;
			} else {
				this2 = t;
			}
			var this4 = this2;
			var out = this4;
			var pi = Math.PI;
			var step = pi * 2 / 36;
			var dif;
			switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this5 = f;
				var za = this5;
				var f1;
				if(gamma >= 0 && gamma > Math.PI) {
					f1 = gamma;
				} else {
					var a1 = gamma % (2 * Math.PI);
					f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
				}
				var this6 = f1;
				var zb = this6;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(beta - gamma);
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f2;
				if(beta >= 0 && beta > Math.PI) {
					f2 = beta;
				} else {
					var a2 = beta % (2 * Math.PI);
					f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
				}
				var this7 = f2;
				var za1 = this7;
				var f3;
				if(gamma >= 0 && gamma > Math.PI) {
					f3 = gamma;
				} else {
					var a3 = gamma % (2 * Math.PI);
					f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
				}
				var this8 = f3;
				var zb1 = this8;
				var fa1 = za1;
				var fb1 = zb1;
				var theta1 = Math.abs(beta - gamma);
				var clockwise1 = beta < gamma;
				var dif2 = clockwise1 ? theta1 : -theta1;
				dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
				break;
			case 2:
				var f4;
				if(beta >= 0 && beta > Math.PI) {
					f4 = beta;
				} else {
					var a4 = beta % (2 * Math.PI);
					f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
				}
				var this9 = f4;
				var za2 = this9;
				var f5;
				if(gamma >= 0 && gamma > Math.PI) {
					f5 = gamma;
				} else {
					var a5 = gamma % (2 * Math.PI);
					f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
				}
				var this10 = f5;
				var zb2 = this10;
				var fa2 = beta;
				var fb2 = gamma;
				var theta2 = Math.abs(beta - gamma);
				var smallest = theta2 <= Math.PI;
				var clockwise2 = beta < gamma;
				var dif3 = clockwise2 ? theta2 : -theta2;
				dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
				break;
			case 3:
				var f6;
				if(beta >= 0 && beta > Math.PI) {
					f6 = beta;
				} else {
					var a6 = beta % (2 * Math.PI);
					f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
				}
				var this11 = f6;
				var za3 = this11;
				var f7;
				if(gamma >= 0 && gamma > Math.PI) {
					f7 = gamma;
				} else {
					var a7 = gamma % (2 * Math.PI);
					f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
				}
				var this12 = f7;
				var zb3 = this12;
				var fa3 = beta;
				var fb3 = gamma;
				var theta3 = Math.abs(beta - gamma);
				var largest = theta3 > Math.PI;
				var clockwise3 = beta < gamma;
				var dif4 = clockwise3 ? theta3 : -theta3;
				dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step1 = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var t2 = new trilateral_tri_Trilateral(ax_,ay_,bx,by,cx,cy);
					out[out.length] = t2;
				}
				angle += step1;
				bx = cx;
				by = cy;
			}
			var triArr = out;
			var _g2 = 0;
			while(_g2 < triArr.length) {
				var t3 = triArr[_g2];
				++_g2;
				this1[this1.length] = t3;
			}
			break;
		case 2:
			var radius1 = width_ / 2;
			var beta1 = -this.angle1 - Math.PI / 2;
			var gamma1 = -this.angle1 - Math.PI / 2 - Math.PI;
			var this13 = this.triArr;
			var t4 = [];
			var this14;
			if(t4 == null) {
				var t5 = [];
				var this15 = t5 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t5;
				this14 = this15;
			} else {
				this14 = t4;
			}
			var this16 = this14;
			var out1 = this16;
			var pi1 = Math.PI;
			var step2 = pi1 * 2 / 36;
			var dif5;
			switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f8;
				if(beta1 >= 0 && beta1 > Math.PI) {
					f8 = beta1;
				} else {
					var a8 = beta1 % (2 * Math.PI);
					f8 = a8 >= 0 ? a8 : a8 + 2 * Math.PI;
				}
				var this17 = f8;
				var za4 = this17;
				var f9;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f9 = gamma1;
				} else {
					var a9 = gamma1 % (2 * Math.PI);
					f9 = a9 >= 0 ? a9 : a9 + 2 * Math.PI;
				}
				var this18 = f9;
				var zb4 = this18;
				var fa4 = za4;
				var fb4 = zb4;
				var theta4 = Math.abs(beta1 - gamma1);
				var clockwise4 = beta1 < gamma1;
				var dif6 = clockwise4 ? theta4 : -theta4;
				dif5 = dif6 > 0 ? dif6 : 2 * Math.PI + dif6;
				break;
			case 1:
				var f10;
				if(beta1 >= 0 && beta1 > Math.PI) {
					f10 = beta1;
				} else {
					var a10 = beta1 % (2 * Math.PI);
					f10 = a10 >= 0 ? a10 : a10 + 2 * Math.PI;
				}
				var this19 = f10;
				var za5 = this19;
				var f11;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f11 = gamma1;
				} else {
					var a11 = gamma1 % (2 * Math.PI);
					f11 = a11 >= 0 ? a11 : a11 + 2 * Math.PI;
				}
				var this20 = f11;
				var zb5 = this20;
				var fa5 = za5;
				var fb5 = zb5;
				var theta5 = Math.abs(beta1 - gamma1);
				var clockwise5 = beta1 < gamma1;
				var dif7 = clockwise5 ? theta5 : -theta5;
				dif5 = dif7 < 0 ? dif7 : -2 * Math.PI + dif7;
				break;
			case 2:
				var f12;
				if(beta1 >= 0 && beta1 > Math.PI) {
					f12 = beta1;
				} else {
					var a12 = beta1 % (2 * Math.PI);
					f12 = a12 >= 0 ? a12 : a12 + 2 * Math.PI;
				}
				var this21 = f12;
				var za6 = this21;
				var f13;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f13 = gamma1;
				} else {
					var a13 = gamma1 % (2 * Math.PI);
					f13 = a13 >= 0 ? a13 : a13 + 2 * Math.PI;
				}
				var this22 = f13;
				var zb6 = this22;
				var fa6 = beta1;
				var fb6 = gamma1;
				var theta6 = Math.abs(beta1 - gamma1);
				var smallest1 = theta6 <= Math.PI;
				var clockwise6 = beta1 < gamma1;
				var dif8 = clockwise6 ? theta6 : -theta6;
				dif5 = smallest1 ? dif8 : clockwise6 ? -(2 * Math.PI - theta6) : 2 * Math.PI - theta6;
				break;
			case 3:
				var f14;
				if(beta1 >= 0 && beta1 > Math.PI) {
					f14 = beta1;
				} else {
					var a14 = beta1 % (2 * Math.PI);
					f14 = a14 >= 0 ? a14 : a14 + 2 * Math.PI;
				}
				var this23 = f14;
				var za7 = this23;
				var f15;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f15 = gamma1;
				} else {
					var a15 = gamma1 % (2 * Math.PI);
					f15 = a15 >= 0 ? a15 : a15 + 2 * Math.PI;
				}
				var this24 = f15;
				var zb7 = this24;
				var fa7 = beta1;
				var fb7 = gamma1;
				var theta7 = Math.abs(beta1 - gamma1);
				var largest1 = theta7 > Math.PI;
				var clockwise7 = beta1 < gamma1;
				var dif9 = clockwise7 ? theta7 : -theta7;
				dif5 = largest1 ? dif9 : clockwise7 ? -(2 * Math.PI - theta7) : 2 * Math.PI - theta7;
				break;
			}
			var positive1 = dif5 >= 0;
			var totalSteps1 = Math.ceil(Math.abs(dif5) / step2);
			var step3 = dif5 / totalSteps1;
			var angle1 = beta1;
			var cx1;
			var cy1;
			var bx1 = 0;
			var by1 = 0;
			var _g3 = 0;
			var _g11 = totalSteps1 + 1;
			while(_g3 < _g11) {
				var i1 = _g3++;
				cx1 = bx_ + radius1 * Math.sin(angle1);
				cy1 = by_ + radius1 * Math.cos(angle1);
				if(i1 != 0) {
					var t6 = new trilateral_tri_Trilateral(bx_,by_,bx1,by1,cx1,cy1);
					out1[out1.length] = t6;
				}
				angle1 += step3;
				bx1 = cx1;
				by1 = cy1;
			}
			var triArr1 = out1;
			var _g4 = 0;
			while(_g4 < triArr1.length) {
				var t7 = triArr1[_g4];
				++_g4;
				this13[this13.length] = t7;
			}
			break;
		case 3:
			var radius2 = width_ / 2;
			var beta2 = -this.angle1 - Math.PI / 2;
			var gamma2 = -this.angle1 - Math.PI / 2 + Math.PI;
			var this25 = this.triArr;
			var t8 = [];
			var this26;
			if(t8 == null) {
				var t9 = [];
				var this27 = t9 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t9;
				this26 = this27;
			} else {
				this26 = t8;
			}
			var this28 = this26;
			var out2 = this28;
			var pi2 = Math.PI;
			var step4 = pi2 * 2 / 36;
			var dif10;
			switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f16;
				if(beta2 >= 0 && beta2 > Math.PI) {
					f16 = beta2;
				} else {
					var a16 = beta2 % (2 * Math.PI);
					f16 = a16 >= 0 ? a16 : a16 + 2 * Math.PI;
				}
				var this29 = f16;
				var za8 = this29;
				var f17;
				if(gamma2 >= 0 && gamma2 > Math.PI) {
					f17 = gamma2;
				} else {
					var a17 = gamma2 % (2 * Math.PI);
					f17 = a17 >= 0 ? a17 : a17 + 2 * Math.PI;
				}
				var this30 = f17;
				var zb8 = this30;
				var fa8 = za8;
				var fb8 = zb8;
				var theta8 = Math.abs(beta2 - gamma2);
				var clockwise8 = beta2 < gamma2;
				var dif11 = clockwise8 ? theta8 : -theta8;
				dif10 = dif11 > 0 ? dif11 : 2 * Math.PI + dif11;
				break;
			case 1:
				var f18;
				if(beta2 >= 0 && beta2 > Math.PI) {
					f18 = beta2;
				} else {
					var a18 = beta2 % (2 * Math.PI);
					f18 = a18 >= 0 ? a18 : a18 + 2 * Math.PI;
				}
				var this31 = f18;
				var za9 = this31;
				var f19;
				if(gamma2 >= 0 && gamma2 > Math.PI) {
					f19 = gamma2;
				} else {
					var a19 = gamma2 % (2 * Math.PI);
					f19 = a19 >= 0 ? a19 : a19 + 2 * Math.PI;
				}
				var this32 = f19;
				var zb9 = this32;
				var fa9 = za9;
				var fb9 = zb9;
				var theta9 = Math.abs(beta2 - gamma2);
				var clockwise9 = beta2 < gamma2;
				var dif12 = clockwise9 ? theta9 : -theta9;
				dif10 = dif12 < 0 ? dif12 : -2 * Math.PI + dif12;
				break;
			case 2:
				var f20;
				if(beta2 >= 0 && beta2 > Math.PI) {
					f20 = beta2;
				} else {
					var a20 = beta2 % (2 * Math.PI);
					f20 = a20 >= 0 ? a20 : a20 + 2 * Math.PI;
				}
				var this33 = f20;
				var za10 = this33;
				var f21;
				if(gamma2 >= 0 && gamma2 > Math.PI) {
					f21 = gamma2;
				} else {
					var a21 = gamma2 % (2 * Math.PI);
					f21 = a21 >= 0 ? a21 : a21 + 2 * Math.PI;
				}
				var this34 = f21;
				var zb10 = this34;
				var fa10 = beta2;
				var fb10 = gamma2;
				var theta10 = Math.abs(beta2 - gamma2);
				var smallest2 = theta10 <= Math.PI;
				var clockwise10 = beta2 < gamma2;
				var dif13 = clockwise10 ? theta10 : -theta10;
				dif10 = smallest2 ? dif13 : clockwise10 ? -(2 * Math.PI - theta10) : 2 * Math.PI - theta10;
				break;
			case 3:
				var f22;
				if(beta2 >= 0 && beta2 > Math.PI) {
					f22 = beta2;
				} else {
					var a22 = beta2 % (2 * Math.PI);
					f22 = a22 >= 0 ? a22 : a22 + 2 * Math.PI;
				}
				var this35 = f22;
				var za11 = this35;
				var f23;
				if(gamma2 >= 0 && gamma2 > Math.PI) {
					f23 = gamma2;
				} else {
					var a23 = gamma2 % (2 * Math.PI);
					f23 = a23 >= 0 ? a23 : a23 + 2 * Math.PI;
				}
				var this36 = f23;
				var zb11 = this36;
				var fa11 = beta2;
				var fb11 = gamma2;
				var theta11 = Math.abs(beta2 - gamma2);
				var largest2 = theta11 > Math.PI;
				var clockwise11 = beta2 < gamma2;
				var dif14 = clockwise11 ? theta11 : -theta11;
				dif10 = largest2 ? dif14 : clockwise11 ? -(2 * Math.PI - theta11) : 2 * Math.PI - theta11;
				break;
			}
			var positive2 = dif10 >= 0;
			var totalSteps2 = Math.ceil(Math.abs(dif10) / step4);
			var step5 = dif10 / totalSteps2;
			var angle2 = beta2;
			var cx2;
			var cy2;
			var bx2 = 0;
			var by2 = 0;
			var _g5 = 0;
			var _g12 = totalSteps2 + 1;
			while(_g5 < _g12) {
				var i2 = _g5++;
				cx2 = ax_ + radius2 * Math.sin(angle2);
				cy2 = ay_ + radius2 * Math.cos(angle2);
				if(i2 != 0) {
					var t10 = new trilateral_tri_Trilateral(ax_,ay_,bx2,by2,cx2,cy2);
					out2[out2.length] = t10;
				}
				angle2 += step5;
				bx2 = cx2;
				by2 = cy2;
			}
			var triArr2 = out2;
			var _g6 = 0;
			while(_g6 < triArr2.length) {
				var t11 = triArr2[_g6];
				++_g6;
				this25[this25.length] = t11;
			}
			var radius3 = width_ / 2;
			var beta3 = -this.angle1 - Math.PI / 2;
			var gamma3 = -this.angle1 - Math.PI / 2 - Math.PI;
			var this37 = this.triArr;
			var t12 = [];
			var this38;
			if(t12 == null) {
				var t13 = [];
				var this39 = t13 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t13;
				this38 = this39;
			} else {
				this38 = t12;
			}
			var this40 = this38;
			var out3 = this40;
			var pi3 = Math.PI;
			var step6 = pi3 * 2 / 36;
			var dif15;
			switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f24;
				if(beta3 >= 0 && beta3 > Math.PI) {
					f24 = beta3;
				} else {
					var a24 = beta3 % (2 * Math.PI);
					f24 = a24 >= 0 ? a24 : a24 + 2 * Math.PI;
				}
				var this41 = f24;
				var za12 = this41;
				var f25;
				if(gamma3 >= 0 && gamma3 > Math.PI) {
					f25 = gamma3;
				} else {
					var a25 = gamma3 % (2 * Math.PI);
					f25 = a25 >= 0 ? a25 : a25 + 2 * Math.PI;
				}
				var this42 = f25;
				var zb12 = this42;
				var fa12 = za12;
				var fb12 = zb12;
				var theta12 = Math.abs(beta3 - gamma3);
				var clockwise12 = beta3 < gamma3;
				var dif16 = clockwise12 ? theta12 : -theta12;
				dif15 = dif16 > 0 ? dif16 : 2 * Math.PI + dif16;
				break;
			case 1:
				var f26;
				if(beta3 >= 0 && beta3 > Math.PI) {
					f26 = beta3;
				} else {
					var a26 = beta3 % (2 * Math.PI);
					f26 = a26 >= 0 ? a26 : a26 + 2 * Math.PI;
				}
				var this43 = f26;
				var za13 = this43;
				var f27;
				if(gamma3 >= 0 && gamma3 > Math.PI) {
					f27 = gamma3;
				} else {
					var a27 = gamma3 % (2 * Math.PI);
					f27 = a27 >= 0 ? a27 : a27 + 2 * Math.PI;
				}
				var this44 = f27;
				var zb13 = this44;
				var fa13 = za13;
				var fb13 = zb13;
				var theta13 = Math.abs(beta3 - gamma3);
				var clockwise13 = beta3 < gamma3;
				var dif17 = clockwise13 ? theta13 : -theta13;
				dif15 = dif17 < 0 ? dif17 : -2 * Math.PI + dif17;
				break;
			case 2:
				var f28;
				if(beta3 >= 0 && beta3 > Math.PI) {
					f28 = beta3;
				} else {
					var a28 = beta3 % (2 * Math.PI);
					f28 = a28 >= 0 ? a28 : a28 + 2 * Math.PI;
				}
				var this45 = f28;
				var za14 = this45;
				var f29;
				if(gamma3 >= 0 && gamma3 > Math.PI) {
					f29 = gamma3;
				} else {
					var a29 = gamma3 % (2 * Math.PI);
					f29 = a29 >= 0 ? a29 : a29 + 2 * Math.PI;
				}
				var this46 = f29;
				var zb14 = this46;
				var fa14 = beta3;
				var fb14 = gamma3;
				var theta14 = Math.abs(beta3 - gamma3);
				var smallest3 = theta14 <= Math.PI;
				var clockwise14 = beta3 < gamma3;
				var dif18 = clockwise14 ? theta14 : -theta14;
				dif15 = smallest3 ? dif18 : clockwise14 ? -(2 * Math.PI - theta14) : 2 * Math.PI - theta14;
				break;
			case 3:
				var f30;
				if(beta3 >= 0 && beta3 > Math.PI) {
					f30 = beta3;
				} else {
					var a30 = beta3 % (2 * Math.PI);
					f30 = a30 >= 0 ? a30 : a30 + 2 * Math.PI;
				}
				var this47 = f30;
				var za15 = this47;
				var f31;
				if(gamma3 >= 0 && gamma3 > Math.PI) {
					f31 = gamma3;
				} else {
					var a31 = gamma3 % (2 * Math.PI);
					f31 = a31 >= 0 ? a31 : a31 + 2 * Math.PI;
				}
				var this48 = f31;
				var zb15 = this48;
				var fa15 = beta3;
				var fb15 = gamma3;
				var theta15 = Math.abs(beta3 - gamma3);
				var largest3 = theta15 > Math.PI;
				var clockwise15 = beta3 < gamma3;
				var dif19 = clockwise15 ? theta15 : -theta15;
				dif15 = largest3 ? dif19 : clockwise15 ? -(2 * Math.PI - theta15) : 2 * Math.PI - theta15;
				break;
			}
			var positive3 = dif15 >= 0;
			var totalSteps3 = Math.ceil(Math.abs(dif15) / step6);
			var step7 = dif15 / totalSteps3;
			var angle3 = beta3;
			var cx3;
			var cy3;
			var bx3 = 0;
			var by3 = 0;
			var _g7 = 0;
			var _g13 = totalSteps3 + 1;
			while(_g7 < _g13) {
				var i3 = _g7++;
				cx3 = bx_ + radius3 * Math.sin(angle3);
				cy3 = by_ + radius3 * Math.cos(angle3);
				if(i3 != 0) {
					var t14 = new trilateral_tri_Trilateral(bx_,by_,bx3,by3,cx3,cy3);
					out3[out3.length] = t14;
				}
				angle3 += step7;
				bx3 = cx3;
				by3 = cy3;
			}
			var triArr3 = out3;
			var _g8 = 0;
			while(_g8 < triArr3.length) {
				var t15 = triArr3[_g8];
				++_g8;
				this37[this37.length] = t15;
			}
			break;
		}
		var this49 = this.triArr;
		var tri = new trilateral_tri_Trilateral(dxPrev_,dyPrev_,this.dx,this.dy,exPrev_,eyPrev_,0);
		this49[this49.length] = tri;
		var this50 = this.triArr;
		var tri1 = new trilateral_tri_Trilateral(dxPrev_,dyPrev_,this.dx,this.dy,this.ex,this.ey,0);
		this50[this50.length] = tri1;
	}
	,computeDE: function() {
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
	}
	,anglesCompute: function() {
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
	}
	,thetaComputeAdj: function(qx,qy) {
		return -Math.atan2(this.ay - qy,this.ax - qx) - Math.PI / 2;
	}
};
var trilateral_justPath_IPathContext = function() { };
trilateral_justPath_IPathContext.__name__ = true;
var trilateral_justPath_transform_ScaleContext = function(pathContext_,sx_,sy_) {
	this.pathContext = pathContext_;
	this.sx = sx_;
	this.sy = sy_;
};
trilateral_justPath_transform_ScaleContext.__name__ = true;
trilateral_justPath_transform_ScaleContext.__interfaces__ = [trilateral_justPath_IPathContext];
trilateral_justPath_transform_ScaleContext.prototype = {
	moveTo: function(x,y) {
		this.pathContext.moveTo(x * this.sx,y * this.sy);
	}
	,lineTo: function(x,y) {
		this.pathContext.lineTo(x * this.sx,y * this.sy);
	}
	,quadTo: function(x1,y1,x2,y2) {
		this.pathContext.quadTo(x1 * this.sx,y1 * this.sy,x2 * this.sx,y2 * this.sy);
	}
	,curveTo: function(x1,y1,x2,y2,x3,y3) {
		this.pathContext.curveTo(x1 * this.sx,y1 * this.sy,x2 * this.sx,y2 * this.sy,x3 * this.sx,y3 * this.sy);
	}
};
var trilateral_justPath_transform_ScaleTranslateContext = function(pathContext_,dx_,dy_,sx_,sy_) {
	this.pathContext = pathContext_;
	this.dx = dx_;
	this.dy = dy_;
	this.sx = sx_;
	this.sy = sy_;
};
trilateral_justPath_transform_ScaleTranslateContext.__name__ = true;
trilateral_justPath_transform_ScaleTranslateContext.__interfaces__ = [trilateral_justPath_IPathContext];
trilateral_justPath_transform_ScaleTranslateContext.prototype = {
	moveTo: function(x,y) {
		this.pathContext.moveTo(x * this.sx + this.dx,y * this.sy + this.dy);
	}
	,lineTo: function(x,y) {
		this.pathContext.lineTo(x * this.sx + this.dx,y * this.sy + this.dy);
	}
	,quadTo: function(x1,y1,x2,y2) {
		this.pathContext.quadTo(x1 * this.sx + this.dx,y1 * this.sy + this.dy,x2 * this.sx + this.dx,y2 * this.sy + this.dy);
	}
	,curveTo: function(x1,y1,x2,y2,x3,y3) {
		this.pathContext.curveTo(x1 * this.sx + this.dx,y1 * this.sy + this.dy,x2 * this.sx + this.dx,y2 * this.sy + this.dy,x3 * this.sx + this.dx,y3 * this.sy + this.dy);
	}
};
var trilateral_justPath_transform_TranslationContext = function(pathContext_,dx_,dy_) {
	this.pathContext = pathContext_;
	this.dx = dx_;
	this.dy = dy_;
};
trilateral_justPath_transform_TranslationContext.__name__ = true;
trilateral_justPath_transform_TranslationContext.__interfaces__ = [trilateral_justPath_IPathContext];
trilateral_justPath_transform_TranslationContext.prototype = {
	moveTo: function(x,y) {
		this.pathContext.moveTo(x + this.dx,y + this.dy);
	}
	,lineTo: function(x,y) {
		this.pathContext.lineTo(x + this.dx,y + this.dy);
	}
	,quadTo: function(x1,y1,x2,y2) {
		this.pathContext.quadTo(x1 + this.dx,y1 + this.dy,x2 + this.dx,y2 + this.dy);
	}
	,curveTo: function(x1,y1,x2,y2,x3,y3) {
		this.pathContext.curveTo(x1 + this.dx,y1 + this.dy,x2 + this.dx,y2 + this.dy,x3 + this.dx,y3 + this.dy);
	}
};
var trilateral_pairs_Line = function() { };
trilateral_pairs_Line.__name__ = true;
trilateral_pairs_Line.create = function(A,B,width) {
	var dx = A.x - B.x;
	var dy = A.y - B.y;
	var P_x = A.x - width / 2;
	var P_y = A.y;
	var omega = Math.atan2(dy,dx);
	var dim_x = width;
	var dim_y = dx * dx + dy * dy;
	var pivotX = A.x + width / 2;
	var pivotY = A.y;
	var px = P_x;
	var py = P_y;
	var dx1 = dim_x;
	var dy1 = dim_y;
	var A_ = { x : px, y : py};
	var B_ = { x : px + dx1, y : py};
	var C_ = { x : px + dx1, y : py + dy1};
	var D_ = { x : px, y : py + dy1};
	if(omega != 0.) {
		var sin = Math.sin(omega);
		var cos = Math.cos(omega);
		var px1 = A_.x - pivotX;
		var py1 = A_.y - pivotY;
		var px2 = px1 * cos - py1 * sin;
		py1 = py1 * cos + px1 * sin;
		A_ = { x : px2 + pivotX, y : py1 + pivotY};
		var px3 = B_.x - pivotX;
		var py2 = B_.y - pivotY;
		var px21 = px3 * cos - py2 * sin;
		py2 = py2 * cos + px3 * sin;
		B_ = { x : px21 + pivotX, y : py2 + pivotY};
		var px4 = C_.x - pivotX;
		var py3 = C_.y - pivotY;
		var px22 = px4 * cos - py3 * sin;
		py3 = py3 * cos + px4 * sin;
		C_ = { x : px22 + pivotX, y : py3 + pivotY};
		var px5 = D_.x - pivotX;
		var py4 = D_.y - pivotY;
		var px23 = px5 * cos - py4 * sin;
		py4 = py4 * cos + px5 * sin;
		D_ = { x : px23 + pivotX, y : py4 + pivotY};
	}
	var q_A = A_;
	var q_B = B_;
	var q_C = C_;
	var q_D = D_;
	return { t0 : new trilateral_tri_Trilateral(q_A.x,q_A.y,q_B.x,q_B.y,q_D.x,q_D.y), t1 : new trilateral_tri_Trilateral(q_B.x,q_B.y,q_C.x,q_C.y,q_D.x,q_D.y)};
};
trilateral_pairs_Line.fromCoord = function(ax,ay,bx,by,width) {
	var dx = ax - bx;
	var dy = ay - by;
	var P_x = ax - width / 2;
	var P_y = ay;
	var omega = Math.atan2(dy,dx);
	var dim_x = width;
	var dim_y = dx * dx + dy * dy;
	var pivotX = ax + width / 2;
	var px = P_x;
	var py = P_y;
	var dx1 = dim_x;
	var dy1 = dim_y;
	var A_ = { x : px, y : py};
	var B_ = { x : px + dx1, y : py};
	var C_ = { x : px + dx1, y : py + dy1};
	var D_ = { x : px, y : py + dy1};
	if(omega != 0.) {
		var sin = Math.sin(omega);
		var cos = Math.cos(omega);
		var px1 = A_.x - pivotX;
		var py1 = A_.y - ay;
		var px2 = px1 * cos - py1 * sin;
		py1 = py1 * cos + px1 * sin;
		A_ = { x : px2 + pivotX, y : py1 + ay};
		var px3 = B_.x - pivotX;
		var py2 = B_.y - ay;
		var px21 = px3 * cos - py2 * sin;
		py2 = py2 * cos + px3 * sin;
		B_ = { x : px21 + pivotX, y : py2 + ay};
		var px4 = C_.x - pivotX;
		var py3 = C_.y - ay;
		var px22 = px4 * cos - py3 * sin;
		py3 = py3 * cos + px4 * sin;
		C_ = { x : px22 + pivotX, y : py3 + ay};
		var px5 = D_.x - pivotX;
		var py4 = D_.y - ay;
		var px23 = px5 * cos - py4 * sin;
		py4 = py4 * cos + px5 * sin;
		D_ = { x : px23 + pivotX, y : py4 + ay};
	}
	var q_A = A_;
	var q_B = B_;
	var q_C = C_;
	var q_D = D_;
	return { t0 : new trilateral_tri_Trilateral(q_A.x,q_A.y,q_B.x,q_B.y,q_D.x,q_D.y), t1 : new trilateral_tri_Trilateral(q_B.x,q_B.y,q_C.x,q_C.y,q_D.x,q_D.y)};
};
var trilateral_pairs_Quad = function() { };
trilateral_pairs_Quad.__name__ = true;
trilateral_pairs_Quad.rectangle = function(x,y,w,h) {
	var ax = x;
	var ay = y;
	var bx = x + w;
	var by = ay;
	var cx = bx;
	var cy = ay + h;
	var dx = x;
	var dy = cy;
	return { t0 : new trilateral_tri_Trilateral(ax,ay,bx,by,dx,dy), t1 : new trilateral_tri_Trilateral(bx,by,cx,cy,dx,dy)};
};
trilateral_pairs_Quad.squareOutline = function(px,py,radius,thick,theta) {
	if(theta == null) {
		theta = 0;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var ax = 0.;
	var ay = 0.;
	var bx = 0.;
	var by = 0.;
	var cx = 0.;
	var cy = 0.;
	var dx = 0.;
	var dy = 0.;
	var a0x = 0.;
	var a0y = 0.;
	var b0x = 0.;
	var b0y = 0.;
	var c0x = 0.;
	var c0y = 0.;
	var d0x = 0.;
	var d0y = 0.;
	if(theta != 0) {
		var pi = Math.PI;
		var pi4 = pi / 4;
		var pi2 = pi / 2;
		var sqrt2 = Math.sqrt(2);
		var r = radius * sqrt2;
		var aTheta = -pi + theta - pi4;
		var dTheta = -pi + theta + pi / 2 - pi / 4;
		var cTheta = theta - pi4;
		var bTheta = -pi + theta - pi2 - pi4;
		var as = Math.sin(aTheta);
		var ac = Math.cos(aTheta);
		var bs = Math.sin(bTheta);
		var bc = Math.cos(bTheta);
		var cs = Math.sin(cTheta);
		var cc = Math.cos(cTheta);
		var ds = Math.sin(dTheta);
		var dc = Math.cos(dTheta);
		var r0 = r - thick;
		ax = px + r * as;
		ay = py + r * ac;
		bx = px + r * bs;
		by = py + r * bc;
		cx = px + r * cs;
		cy = py + r * cc;
		dx = px + r * ds;
		dy = py + r * dc;
		a0x = px + r0 * as;
		a0y = py + r0 * ac;
		b0x = px + r0 * bs;
		b0y = py + r0 * bc;
		c0x = px + r0 * cs;
		c0y = py + r0 * cc;
		d0x = px + r0 * ds;
		d0y = py + r0 * dc;
	} else {
		ax = px - radius;
		ay = py - radius;
		var lx = radius * 2;
		var ly = lx;
		bx = ax + lx;
		by = ay;
		cx = bx;
		cy = ay + ly;
		dx = ax;
		dy = cy;
		var radius0 = radius - thick;
		a0x = px - radius0;
		a0y = py - radius0;
		var l0x = radius0 * 2;
		var l0y = l0x;
		b0x = a0x + l0x;
		b0y = a0y;
		c0x = b0x;
		c0y = a0y + l0y;
		d0x = a0x;
		d0y = c0y;
	}
	var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,a0x,a0y);
	out[out.length] = tri;
	var tri1 = new trilateral_tri_Trilateral(bx,by,b0x,b0y,a0x,a0y);
	out[out.length] = tri1;
	var tri2 = new trilateral_tri_Trilateral(d0x,d0y,c0x,c0y,dx,dy);
	out[out.length] = tri2;
	var tri3 = new trilateral_tri_Trilateral(c0x,c0y,cx,cy,dx,dy);
	out[out.length] = tri3;
	var tri4 = new trilateral_tri_Trilateral(ax,ay,a0x,a0y,d0x,d0y);
	out[out.length] = tri4;
	var tri5 = new trilateral_tri_Trilateral(ax,ay,d0x,d0y,dx,dy);
	out[out.length] = tri5;
	var tri6 = new trilateral_tri_Trilateral(b0x,b0y,bx,by,c0x,c0y);
	out[out.length] = tri6;
	var tri7 = new trilateral_tri_Trilateral(bx,by,cx,cy,c0x,c0y);
	out[out.length] = tri7;
	return out;
};
trilateral_pairs_Quad.square = function(px,py,radius,theta) {
	if(theta == null) {
		theta = 0;
	}
	var ax = 0.;
	var ay = 0.;
	var bx = 0.;
	var by = 0.;
	var cx = 0.;
	var cy = 0.;
	var dx = 0.;
	var dy = 0.;
	if(theta != 0) {
		var pi = Math.PI;
		var pi4 = pi / 4;
		var pi2 = pi / 2;
		var sqrt2 = Math.sqrt(2);
		var r = radius * sqrt2;
		var aTheta = -pi + theta - pi4;
		var dTheta = -pi + theta + pi / 2 - pi / 4;
		var cTheta = theta - pi4;
		var bTheta = -pi + theta - pi2 - pi4;
		ax = px + r * Math.sin(aTheta);
		ay = py + r * Math.cos(aTheta);
		bx = px + r * Math.sin(bTheta);
		by = py + r * Math.cos(bTheta);
		cx = px + r * Math.sin(cTheta);
		cy = py + r * Math.cos(cTheta);
		dx = px + r * Math.sin(dTheta);
		dy = py + r * Math.cos(dTheta);
	} else {
		ax = px - radius;
		ay = py - radius;
		var lx = radius * 2;
		var ly = lx;
		bx = ax + lx;
		by = ay;
		cx = bx;
		cy = ay + ly;
		dx = ax;
		dy = cy;
	}
	return { t0 : new trilateral_tri_Trilateral(ax,ay,bx,by,dx,dy), t1 : new trilateral_tri_Trilateral(bx,by,cx,cy,dx,dy)};
};
trilateral_pairs_Quad.diamond = function(x,y,radius,theta) {
	if(theta == null) {
		theta = 0;
	}
	var theta1 = Math.PI / 4 + theta;
	var ax = 0.;
	var ay = 0.;
	var bx = 0.;
	var by = 0.;
	var cx = 0.;
	var cy = 0.;
	var dx = 0.;
	var dy = 0.;
	if(theta1 != 0) {
		var pi = Math.PI;
		var pi4 = pi / 4;
		var pi2 = pi / 2;
		var sqrt2 = Math.sqrt(2);
		var r = radius * sqrt2;
		var aTheta = -pi + theta1 - pi4;
		var dTheta = -pi + theta1 + pi / 2 - pi / 4;
		var cTheta = theta1 - pi4;
		var bTheta = -pi + theta1 - pi2 - pi4;
		ax = x + r * Math.sin(aTheta);
		ay = y + r * Math.cos(aTheta);
		bx = x + r * Math.sin(bTheta);
		by = y + r * Math.cos(bTheta);
		cx = x + r * Math.sin(cTheta);
		cy = y + r * Math.cos(cTheta);
		dx = x + r * Math.sin(dTheta);
		dy = y + r * Math.cos(dTheta);
	} else {
		ax = x - radius;
		ay = y - radius;
		var lx = radius * 2;
		var ly = lx;
		bx = ax + lx;
		by = ay;
		cx = bx;
		cy = ay + ly;
		dx = ax;
		dy = cy;
	}
	return { t0 : new trilateral_tri_Trilateral(ax,ay,bx,by,dx,dy), t1 : new trilateral_tri_Trilateral(bx,by,cx,cy,dx,dy)};
};
trilateral_pairs_Quad.diamondOutline = function(x,y,thick,radius,theta) {
	if(theta == null) {
		theta = 0;
	}
	var theta1 = Math.PI / 4 + theta;
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var ax = 0.;
	var ay = 0.;
	var bx = 0.;
	var by = 0.;
	var cx = 0.;
	var cy = 0.;
	var dx = 0.;
	var dy = 0.;
	var a0x = 0.;
	var a0y = 0.;
	var b0x = 0.;
	var b0y = 0.;
	var c0x = 0.;
	var c0y = 0.;
	var d0x = 0.;
	var d0y = 0.;
	if(theta1 != 0) {
		var pi = Math.PI;
		var pi4 = pi / 4;
		var pi2 = pi / 2;
		var sqrt2 = Math.sqrt(2);
		var r = radius * sqrt2;
		var aTheta = -pi + theta1 - pi4;
		var dTheta = -pi + theta1 + pi / 2 - pi / 4;
		var cTheta = theta1 - pi4;
		var bTheta = -pi + theta1 - pi2 - pi4;
		var as = Math.sin(aTheta);
		var ac = Math.cos(aTheta);
		var bs = Math.sin(bTheta);
		var bc = Math.cos(bTheta);
		var cs = Math.sin(cTheta);
		var cc = Math.cos(cTheta);
		var ds = Math.sin(dTheta);
		var dc = Math.cos(dTheta);
		var r0 = r - thick;
		ax = x + r * as;
		ay = y + r * ac;
		bx = x + r * bs;
		by = y + r * bc;
		cx = x + r * cs;
		cy = y + r * cc;
		dx = x + r * ds;
		dy = y + r * dc;
		a0x = x + r0 * as;
		a0y = y + r0 * ac;
		b0x = x + r0 * bs;
		b0y = y + r0 * bc;
		c0x = x + r0 * cs;
		c0y = y + r0 * cc;
		d0x = x + r0 * ds;
		d0y = y + r0 * dc;
	} else {
		ax = x - radius;
		ay = y - radius;
		var lx = radius * 2;
		var ly = lx;
		bx = ax + lx;
		by = ay;
		cx = bx;
		cy = ay + ly;
		dx = ax;
		dy = cy;
		var radius0 = radius - thick;
		a0x = x - radius0;
		a0y = y - radius0;
		var l0x = radius0 * 2;
		var l0y = l0x;
		b0x = a0x + l0x;
		b0y = a0y;
		c0x = b0x;
		c0y = a0y + l0y;
		d0x = a0x;
		d0y = c0y;
	}
	var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,a0x,a0y);
	out[out.length] = tri;
	var tri1 = new trilateral_tri_Trilateral(bx,by,b0x,b0y,a0x,a0y);
	out[out.length] = tri1;
	var tri2 = new trilateral_tri_Trilateral(d0x,d0y,c0x,c0y,dx,dy);
	out[out.length] = tri2;
	var tri3 = new trilateral_tri_Trilateral(c0x,c0y,cx,cy,dx,dy);
	out[out.length] = tri3;
	var tri4 = new trilateral_tri_Trilateral(ax,ay,a0x,a0y,d0x,d0y);
	out[out.length] = tri4;
	var tri5 = new trilateral_tri_Trilateral(ax,ay,d0x,d0y,dx,dy);
	out[out.length] = tri5;
	var tri6 = new trilateral_tri_Trilateral(b0x,b0y,bx,by,c0x,c0y);
	out[out.length] = tri6;
	var tri7 = new trilateral_tri_Trilateral(bx,by,cx,cy,c0x,c0y);
	out[out.length] = tri7;
	return out;
};
var trilateral_pairs_Star = function() { };
trilateral_pairs_Star.__name__ = true;
trilateral_pairs_Star.create = function(px,py,radius,theta) {
	if(theta == null) {
		theta = 0;
	}
	var pi = Math.PI;
	var omega = -pi + theta;
	var a0x = px + radius * Math.sin(omega);
	var a0y = py + radius * Math.cos(omega);
	omega += pi / 3;
	var a1x = px + radius * Math.sin(omega);
	var a1y = py + radius * Math.cos(omega);
	omega += pi / 3;
	var b0x = px + radius * Math.sin(omega);
	var b0y = py + radius * Math.cos(omega);
	omega += pi / 3;
	var b1x = px + radius * Math.sin(omega);
	var b1y = py + radius * Math.cos(omega);
	omega += pi / 3;
	var c0x = px + radius * Math.sin(omega);
	var c0y = py + radius * Math.cos(omega);
	omega += pi / 3;
	var c1x = px + radius * Math.sin(omega);
	var c1y = py + radius * Math.cos(omega);
	return { t0 : new trilateral_tri_Trilateral(a0x,a0y,b0x,b0y,c0x,c0y), t1 : new trilateral_tri_Trilateral(a1x,a1y,b1x,b1y,c1x,c1y)};
};
var trilateral_parsing_FillDraw = function(width_,height_) {
	var t = [];
	var this2;
	if(t == null) {
		var t1 = [];
		var this3 = t1 == null ? trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new([]) : t1;
		this2 = this3;
	} else {
		this2 = t;
	}
	var this1 = this2;
	this.triangles = this1;
	this.colors = [];
	this.count = 0;
	if(width_ != null) {
		this.width = width_;
	}
	if(height_ != null) {
		this.height = height_;
	}
};
trilateral_parsing_FillDraw.__name__ = true;
trilateral_parsing_FillDraw.prototype = {
	fill: function(p,colorID) {
		if(this.contours == null) {
			this.contours = p;
			this.contourColors = [colorID];
		} else {
			var l = this.contours.length;
			var _g = 0;
			var _g1 = p.length;
			while(_g < _g1) {
				var i = _g++;
				this.contours[l + i] = p[i];
			}
			this.contourColors[this.contourColors.length] = colorID;
		}
		var fillDatas = this.fillFunc(p);
		this.iterFill(fillDatas.vert,fillDatas.tri,colorID);
	}
	,fillRnd: function(p,rnd) {
		if(this.contours == null) {
			this.contours = p;
			this.contourColors = [];
		} else {
			var l = this.contours.length;
			var _g = 0;
			var _g1 = p.length;
			while(_g < _g1) {
				var i = _g++;
				this.contours[l + i] = p[i];
			}
		}
		var fillDatas = this.fillFunc(p);
		this.iterFill(fillDatas.vert,fillDatas.tri,rnd,true);
	}
	,fillFunc: function(p) {
		return { vert : [], tri : []};
	}
	,pathFactory: function() {
		throw new js__$Boot_HaxeError("please extend FillDraw with implementation");
	}
	,rndInt: function(rnd) {
		return Math.round(Math.random() * rnd) | 0;
	}
	,iterFill: function(vert,tri,colorID,ifRnd) {
		if(ifRnd == null) {
			ifRnd = false;
		}
		var triples = trilateral_arr__$ArrayTriple_ArrayTriple_$Impl_$._new(tri);
		var id;
		var _g = 0;
		while(_g < (triples.length / 3 | 0)) {
			var i = _g * 3 | 0;
			var tri_a = triples[i];
			var tri_b = triples[i + 1];
			var tri_c = triples[i + 2];
			++_g;
			var a = tri_a * 2 | 0;
			var b = tri_b * 2 | 0;
			var c = tri_c * 2 | 0;
			id = ifRnd ? Math.round(Math.random() * colorID) | 0 : colorID;
			var this1 = this.triangles;
			var tri1 = new trilateral_tri_Triangle(this.count,{ x : vert[a], y : vert[a + 1]},{ x : vert[b], y : vert[b + 1]},{ x : vert[c], y : vert[c + 1]},0,id);
			this1[this1.length] = tri1;
		}
		this.count++;
	}
	,colorId: function(color) {
		var id = this.colors.indexOf(color);
		if(id == -1) {
			id = this.colors.length;
			this.colors[id] = color;
		}
		return id;
	}
};
var trilateral_path_Base = function(contour_,trilateralArray_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.width = 0.01;
	this.y = 0.;
	this.x = 0.;
	var tmp;
	if(trilateralArray_ == null) {
		var t = [];
		var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
		var this2 = this1;
		tmp = this2;
	} else {
		tmp = trilateralArray_;
	}
	this.trilateralArray = tmp;
	this.contour = contour_ == null ? new trilateral_geom_Contour(this.trilateralArray,endLine_) : contour_;
	this.endLine = endLine_;
	this.points = [];
	this.pointsClock = [];
	this.pointsAnti = [];
	this.points[0] = [];
	this.dim = [];
};
trilateral_path_Base.__name__ = true;
trilateral_path_Base.__interfaces__ = [trilateral_justPath_IPathContext];
trilateral_path_Base.prototype = {
	reset: function() {
		var t = [];
		var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
		var this2 = this1;
		this.trilateralArray = this2;
		this.contour = new trilateral_geom_Contour(this.trilateralArray,this.endLine);
		this.points = [];
		this.pointsClock = [];
		this.pointsAnti = [];
		this.points[0] = [];
		this.dim = [];
	}
	,pointsNoEndOverlap: function() {
		var p;
		var l;
		var j = 0;
		var pointsClean = [];
		var _g = 0;
		var _g1 = this.points.length;
		while(_g < _g1) {
			var i = _g++;
			p = this.points[i];
			if(p.length > 2) {
				pointsClean[j++] = p;
			}
		}
		this.points = pointsClean;
		var _g2 = 0;
		var _g3 = this.points.length;
		while(_g2 < _g3) {
			var i1 = _g2++;
			p = this.points[i1];
			l = p.length;
			var repeat = p[0] == p[l - 2] && p[1] == p[l - 1];
			if(repeat) {
				this.points[i1].pop();
				this.points[i1].pop();
				l -= 2;
			}
		}
		return this.points;
	}
	,pointsRewound: function() {
		var p;
		var l;
		var j = 0;
		var pointsClean = [];
		var _g = 0;
		var _g1 = this.points.length;
		while(_g < _g1) {
			var i = _g++;
			p = this.points[i];
			if(p.length > 2) {
				pointsClean[j++] = p;
			}
		}
		this.points = pointsClean;
		var _g2 = 0;
		var _g3 = this.points.length;
		while(_g2 < _g3) {
			var i1 = _g2++;
			p = this.points[i1];
			l = p.length;
			var repeat = p[0] == p[l - 2] && p[1] == p[l - 1];
			if(repeat) {
				this.points[i1].pop();
				this.points[i1].pop();
				l -= 2;
			}
			var cc = 0.;
			var k = 0;
			var x1;
			var y1;
			var x2;
			var y2;
			var last = l - 2;
			while(k < l) {
				x1 = p[k];
				y1 = p[k + 1];
				if(k == last) {
					x2 = p[0];
					y2 = p[1];
				} else {
					x2 = p[k + 2];
					y2 = p[k + 3];
				}
				cc += (x2 - x1) * (y2 + y1);
				k += 2;
			}
			var reverse = cc > 0;
			if(reverse) {
				k = 0;
				while(k < l) {
					x1 = p[k];
					p[k] = p[k + 1];
					p[k + 1] = x1;
					k += 2;
				}
			}
			p.reverse();
			this.points[i1] = p;
		}
		return this.points;
	}
	,initDim: function() {
		return { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
	}
	,updateDim: function(x,y) {
		var d = this.dim[this.dim.length - 1];
		if(x < d.minX) {
			d.minX = x;
		}
		if(x > d.maxX) {
			d.maxX = x;
		}
		if(y < d.minY) {
			d.minY = y;
		}
		if(y > d.maxY) {
			d.maxY = y;
		}
	}
	,moveTo: function(x_,y_) {
		if(this.endLine == 2 || this.endLine == 3) {
			var _this = this.contour;
			var width_ = this.width;
			_this.endEdges();
			if(_this.count != 0) {
				var ax = _this.bx;
				var ay = _this.by;
				var radius = width_ / 2;
				var beta = -_this.angle1 - Math.PI / 2;
				var gamma = -_this.angle1 - Math.PI / 2 - Math.PI;
				var temp = [];
				var this1 = _this.triArr;
				var t = [];
				var this2;
				if(t == null) {
					var t1 = [];
					var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
					this2 = this3;
				} else {
					this2 = t;
				}
				var this4 = this2;
				var out = this4;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var dif;
				switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
				case 0:
					var f;
					if(beta >= 0 && beta > Math.PI) {
						f = beta;
					} else {
						var a = beta % (2 * Math.PI);
						f = a >= 0 ? a : a + 2 * Math.PI;
					}
					var this5 = f;
					var za = this5;
					var f1;
					if(gamma >= 0 && gamma > Math.PI) {
						f1 = gamma;
					} else {
						var a1 = gamma % (2 * Math.PI);
						f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
					}
					var this6 = f1;
					var zb = this6;
					var fa = za;
					var fb = zb;
					var theta = Math.abs(beta - gamma);
					var clockwise = beta < gamma;
					var dif1 = clockwise ? theta : -theta;
					dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
					break;
				case 1:
					var f2;
					if(beta >= 0 && beta > Math.PI) {
						f2 = beta;
					} else {
						var a2 = beta % (2 * Math.PI);
						f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
					}
					var this7 = f2;
					var za1 = this7;
					var f3;
					if(gamma >= 0 && gamma > Math.PI) {
						f3 = gamma;
					} else {
						var a3 = gamma % (2 * Math.PI);
						f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
					}
					var this8 = f3;
					var zb1 = this8;
					var fa1 = za1;
					var fb1 = zb1;
					var theta1 = Math.abs(beta - gamma);
					var clockwise1 = beta < gamma;
					var dif2 = clockwise1 ? theta1 : -theta1;
					dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
					break;
				case 2:
					var f4;
					if(beta >= 0 && beta > Math.PI) {
						f4 = beta;
					} else {
						var a4 = beta % (2 * Math.PI);
						f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
					}
					var this9 = f4;
					var za2 = this9;
					var f5;
					if(gamma >= 0 && gamma > Math.PI) {
						f5 = gamma;
					} else {
						var a5 = gamma % (2 * Math.PI);
						f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
					}
					var this10 = f5;
					var zb2 = this10;
					var fa2 = beta;
					var fb2 = gamma;
					var theta2 = Math.abs(beta - gamma);
					var smallest = theta2 <= Math.PI;
					var clockwise2 = beta < gamma;
					var dif3 = clockwise2 ? theta2 : -theta2;
					dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
					break;
				case 3:
					var f6;
					if(beta >= 0 && beta > Math.PI) {
						f6 = beta;
					} else {
						var a6 = beta % (2 * Math.PI);
						f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
					}
					var this11 = f6;
					var za3 = this11;
					var f7;
					if(gamma >= 0 && gamma > Math.PI) {
						f7 = gamma;
					} else {
						var a7 = gamma % (2 * Math.PI);
						f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
					}
					var this12 = f7;
					var zb3 = this12;
					var fa3 = beta;
					var fb3 = gamma;
					var theta3 = Math.abs(beta - gamma);
					var largest = theta3 > Math.PI;
					var clockwise3 = beta < gamma;
					var dif4 = clockwise3 ? theta3 : -theta3;
					dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
					break;
				}
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step1 = dif / totalSteps;
				var angle = beta;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = temp.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax + radius * Math.sin(angle);
					cy = ay + radius * Math.cos(angle);
					temp[p2++] = cx;
					temp[p2++] = cy;
					if(i != 0) {
						var t2 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
						out[out.length] = t2;
					}
					angle += step1;
					bx = cx;
					by = cy;
				}
				var triArr = out;
				var _g2 = 0;
				while(_g2 < triArr.length) {
					var t3 = triArr[_g2];
					++_g2;
					this1[this1.length] = t3;
				}
				var pA = _this.pointsAnti.length;
				var len = temp.length / 2 | 0;
				var _g3 = 0;
				var _g11 = len + 2;
				while(_g3 < _g11) {
					var i1 = _g3++;
					_this.pointsAnti[pA++] = temp[i1];
				}
				var pC = _this.pointsClock.length;
				var _g21 = 1;
				var _g31 = len / 2 + 1 | 0;
				while(_g21 < _g31) {
					var i2 = _g21++;
					_this.pointsClock[pC++] = temp[temp.length - 2 * i2];
					_this.pointsClock[pC++] = temp[temp.length - 2 * i2 - 1];
				}
			}
		}
		this.x = x_;
		this.y = y_;
		var l = this.points.length;
		this.points[l] = [];
		this.points[l][0] = x_;
		this.points[l][1] = y_;
		this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
		this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
		this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
		var d = this.dim[this.dim.length - 1];
		if(x_ < d.minX) {
			d.minX = x_;
		}
		if(x_ > d.maxX) {
			d.maxX = x_;
		}
		if(y_ < d.minY) {
			d.minY = y_;
		}
		if(y_ > d.maxY) {
			d.maxY = y_;
		}
		this.contour.reset();
	}
	,lastClock: function() {
		if(this.contour.pointsClock.length != 0) {
			this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
			this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
		}
	}
	,getEdges: function() {
		var edges = [];
		var no = this.pointsClock.length;
		if(no > this.pointsAnti.length) {
			no = this.pointsAnti.length;
		}
		var pClock;
		var pAnti;
		var shape;
		var _g = 0;
		var _g1 = no;
		while(_g < _g1) {
			var s = _g++;
			pClock = this.pointsClock[s];
			pAnti = this.pointsAnti[s];
			var lc = pClock.length;
			var la = pAnti.length;
			edges[s] = [];
			shape = edges[s];
			var _g2 = 0;
			var _g11 = lc;
			while(_g2 < _g11) {
				var i = _g2++;
				shape[i] = pClock[i];
			}
			var j = shape.length;
			var l5 = la / 2 | 0;
			var _g21 = 0;
			var _g3 = l5;
			while(_g21 < _g3) {
				var i1 = _g21++;
				shape[j + i1 * 2] = pAnti[la - i1 * 2 - 1];
				shape[j + i1 * 2 + 1] = pAnti[la - i1 * 2];
			}
			j = shape.length;
			shape[j++] = pClock[0];
			shape[j] = pClock[1];
		}
		return edges;
	}
	,lineTo: function(x_,y_) {
		var repeat = this.x == x_ && this.y == y_;
		if(!repeat) {
			if(this.widthFunction != null) {
				this.width = this.widthFunction(this.width,this.x,this.x,x_,y_);
			}
			this.line(x_,y_);
			var l = this.points.length;
			var p = this.points[l - 1];
			var l2 = p.length;
			p[l2] = x_;
			p[l2 + 1] = y_;
			var d = this.dim[this.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			this.x = x_;
			this.y = y_;
		}
	}
	,line: function(x_,y_) {
		console.log("trilateral/path/Base.hx:245:","lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )");
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.halfA = Math.PI / 2;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var dxPrev_ = _this.dx;
		var dyPrev_ = _this.dy;
		var exPrev_ = _this.ex;
		var eyPrev_ = _this.ey;
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var this1 = _this.triArr;
		var tri = new trilateral_tri_Trilateral(dxPrev_,dyPrev_,_this.dx,_this.dy,exPrev_,eyPrev_,0);
		this1[this1.length] = tri;
		var this2 = _this.triArr;
		var tri1 = new trilateral_tri_Trilateral(dxPrev_,dyPrev_,_this.dx,_this.dy,_this.ex,_this.ey,0);
		this2[this2.length] = tri1;
	}
	,lineTrace: function(x_,y_) {
		console.log("trilateral/path/Base.hx:245:","lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )");
	}
	,quadTo: function(x1,y1,x2,y2) {
		this.tempArr = [];
		var p = this.tempArr;
		var ax = this.x;
		var ay = this.y;
		var x = ax - x1;
		var y = ay - y1;
		var x3 = x1 - x2;
		var y3 = y1 - y2;
		var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x3 * x3 + y3 * y3);
		if(approxDistance == 0) {
			approxDistance = 0.000001;
		}
		var step = Math.min(1 / (approxDistance * 0.707),trilateral_geom_Algebra.quadStep);
		var l = p.length;
		p[l++] = ax;
		p[l++] = ay;
		var t = step;
		while(t < 1.) {
			var u = 1 - t;
			p[l++] = Math.pow(u,2) * ax + 2 * u * t * x1 + Math.pow(t,2) * x2;
			var u1 = 1 - t;
			p[l++] = Math.pow(u1,2) * ay + 2 * u1 * t * y1 + Math.pow(t,2) * y2;
			t += step;
		}
		p[l++] = x2;
		p[l++] = y2;
		var arr = this.tempArr;
		var l1 = arr.length;
		var i = 2;
		var x_ = arr[0];
		var y_ = arr[1];
		var repeat = this.x == x_ && this.y == y_;
		if(!repeat) {
			if(this.widthFunction != null) {
				this.width = this.widthFunction(this.width,this.x,this.x,x_,y_);
			}
			this.line(x_,y_);
			var l2 = this.points.length;
			var p1 = this.points[l2 - 1];
			var l21 = p1.length;
			p1[l21] = x_;
			p1[l21 + 1] = y_;
			var d = this.dim[this.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			this.x = x_;
			this.y = y_;
		}
		while(i < l1) {
			var x_1 = arr[i];
			var y_1 = arr[i + 1];
			var repeat1 = this.x == x_1 && this.y == y_1;
			if(!repeat1) {
				if(this.widthFunction != null) {
					this.width = this.widthFunction(this.width,this.x,this.x,x_1,y_1);
				}
				this.line(x_1,y_1);
				var l3 = this.points.length;
				var p2 = this.points[l3 - 1];
				var l22 = p2.length;
				p2[l22] = x_1;
				p2[l22 + 1] = y_1;
				var d1 = this.dim[this.dim.length - 1];
				if(x_1 < d1.minX) {
					d1.minX = x_1;
				}
				if(x_1 > d1.maxX) {
					d1.maxX = x_1;
				}
				if(y_1 < d1.minY) {
					d1.minY = y_1;
				}
				if(y_1 > d1.maxY) {
					d1.maxY = y_1;
				}
				this.x = x_1;
				this.y = y_1;
			}
			i += 2;
		}
		this.x = x2;
		this.y = y2;
	}
	,quadThru: function(x1,y1,x2,y2) {
		var newx = 2 * x1 - 0.5 * (this.x + x2);
		var newy = 2 * y1 - 0.5 * (this.y + y2);
		this.tempArr = [];
		var p = this.tempArr;
		var ax = this.x;
		var ay = this.y;
		var x = ax - newx;
		var y = ay - newy;
		var x3 = newx - x2;
		var y3 = newy - y2;
		var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x3 * x3 + y3 * y3);
		if(approxDistance == 0) {
			approxDistance = 0.000001;
		}
		var step = Math.min(1 / (approxDistance * 0.707),trilateral_geom_Algebra.quadStep);
		var l = p.length;
		p[l++] = ax;
		p[l++] = ay;
		var t = step;
		while(t < 1.) {
			var u = 1 - t;
			p[l++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * x2;
			var u1 = 1 - t;
			p[l++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * y2;
			t += step;
		}
		p[l++] = x2;
		p[l++] = y2;
		var arr = this.tempArr;
		var l1 = arr.length;
		var i = 2;
		var x_ = arr[0];
		var y_ = arr[1];
		var repeat = this.x == x_ && this.y == y_;
		if(!repeat) {
			if(this.widthFunction != null) {
				this.width = this.widthFunction(this.width,this.x,this.x,x_,y_);
			}
			this.line(x_,y_);
			var l2 = this.points.length;
			var p1 = this.points[l2 - 1];
			var l21 = p1.length;
			p1[l21] = x_;
			p1[l21 + 1] = y_;
			var d = this.dim[this.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			this.x = x_;
			this.y = y_;
		}
		while(i < l1) {
			var x_1 = arr[i];
			var y_1 = arr[i + 1];
			var repeat1 = this.x == x_1 && this.y == y_1;
			if(!repeat1) {
				if(this.widthFunction != null) {
					this.width = this.widthFunction(this.width,this.x,this.x,x_1,y_1);
				}
				this.line(x_1,y_1);
				var l3 = this.points.length;
				var p2 = this.points[l3 - 1];
				var l22 = p2.length;
				p2[l22] = x_1;
				p2[l22 + 1] = y_1;
				var d1 = this.dim[this.dim.length - 1];
				if(x_1 < d1.minX) {
					d1.minX = x_1;
				}
				if(x_1 > d1.maxX) {
					d1.maxX = x_1;
				}
				if(y_1 < d1.minY) {
					d1.minY = y_1;
				}
				if(y_1 > d1.maxY) {
					d1.maxY = y_1;
				}
				this.x = x_1;
				this.y = y_1;
			}
			i += 2;
		}
		this.x = x2;
		this.y = y2;
		return;
	}
	,curveTo: function(x1,y1,x2,y2,x3,y3) {
		this.tempArr = [];
		var p = this.tempArr;
		var ax = this.x;
		var ay = this.y;
		var x = ax - x1;
		var y = ay - y1;
		var x4 = x1 - x2;
		var y4 = y1 - y2;
		var x5 = x2 - x3;
		var y5 = y2 - y3;
		var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x4 * x4 + y4 * y4) + Math.sqrt(x5 * x5 + y5 * y5);
		if(approxDistance == 0) {
			approxDistance = 0.000001;
		}
		var step = Math.min(1 / (approxDistance * 0.707),trilateral_geom_Algebra.cubicStep);
		var l = p.length;
		p[l++] = ax;
		p[l++] = ay;
		var t = step;
		while(t < 1.) {
			var u = 1 - t;
			p[l++] = Math.pow(u,3) * ax + 3 * Math.pow(u,2) * t * x1 + 3 * u * Math.pow(t,2) * x2 + Math.pow(t,3) * x3;
			var u1 = 1 - t;
			p[l++] = Math.pow(u1,3) * ay + 3 * Math.pow(u1,2) * t * y1 + 3 * u1 * Math.pow(t,2) * y2 + Math.pow(t,3) * y3;
			t += step;
		}
		p[l++] = x3;
		p[l++] = y3;
		var arr = this.tempArr;
		var l1 = arr.length;
		var i = 2;
		var x_ = arr[0];
		var y_ = arr[1];
		var repeat = this.x == x_ && this.y == y_;
		if(!repeat) {
			if(this.widthFunction != null) {
				this.width = this.widthFunction(this.width,this.x,this.x,x_,y_);
			}
			this.line(x_,y_);
			var l2 = this.points.length;
			var p1 = this.points[l2 - 1];
			var l21 = p1.length;
			p1[l21] = x_;
			p1[l21 + 1] = y_;
			var d = this.dim[this.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			this.x = x_;
			this.y = y_;
		}
		while(i < l1) {
			var x_1 = arr[i];
			var y_1 = arr[i + 1];
			var repeat1 = this.x == x_1 && this.y == y_1;
			if(!repeat1) {
				if(this.widthFunction != null) {
					this.width = this.widthFunction(this.width,this.x,this.x,x_1,y_1);
				}
				this.line(x_1,y_1);
				var l3 = this.points.length;
				var p2 = this.points[l3 - 1];
				var l22 = p2.length;
				p2[l22] = x_1;
				p2[l22 + 1] = y_1;
				var d1 = this.dim[this.dim.length - 1];
				if(x_1 < d1.minX) {
					d1.minX = x_1;
				}
				if(x_1 > d1.maxX) {
					d1.maxX = x_1;
				}
				if(y_1 < d1.minY) {
					d1.minY = y_1;
				}
				if(y_1 > d1.maxY) {
					d1.maxY = y_1;
				}
				this.x = x_1;
				this.y = y_1;
			}
			i += 2;
		}
		this.x = x3;
		this.y = y3;
	}
	,plotCoord: function(arr,withMove) {
		if(withMove == null) {
			withMove = true;
		}
		var l = arr.length;
		var i = 2;
		if(withMove) {
			this.moveTo(arr[0],arr[1]);
		} else {
			var x_ = arr[0];
			var y_ = arr[1];
			var repeat = this.x == x_ && this.y == y_;
			if(!repeat) {
				if(this.widthFunction != null) {
					this.width = this.widthFunction(this.width,this.x,this.x,x_,y_);
				}
				this.line(x_,y_);
				var l1 = this.points.length;
				var p = this.points[l1 - 1];
				var l2 = p.length;
				p[l2] = x_;
				p[l2 + 1] = y_;
				var d = this.dim[this.dim.length - 1];
				if(x_ < d.minX) {
					d.minX = x_;
				}
				if(x_ > d.maxX) {
					d.maxX = x_;
				}
				if(y_ < d.minY) {
					d.minY = y_;
				}
				if(y_ > d.maxY) {
					d.maxY = y_;
				}
				this.x = x_;
				this.y = y_;
			}
		}
		while(i < l) {
			var x_1 = arr[i];
			var y_1 = arr[i + 1];
			var repeat1 = this.x == x_1 && this.y == y_1;
			if(!repeat1) {
				if(this.widthFunction != null) {
					this.width = this.widthFunction(this.width,this.x,this.x,x_1,y_1);
				}
				this.line(x_1,y_1);
				var l3 = this.points.length;
				var p1 = this.points[l3 - 1];
				var l21 = p1.length;
				p1[l21] = x_1;
				p1[l21 + 1] = y_1;
				var d1 = this.dim[this.dim.length - 1];
				if(x_1 < d1.minX) {
					d1.minX = x_1;
				}
				if(x_1 > d1.maxX) {
					d1.maxX = x_1;
				}
				if(y_1 < d1.minY) {
					d1.minY = y_1;
				}
				if(y_1 > d1.maxY) {
					d1.maxY = y_1;
				}
				this.x = x_1;
				this.y = y_1;
			}
			i += 2;
		}
	}
};
var trilateral_path_FillOnly = function(contour_,trilateralArray_,endLine_) {
	trilateral_path_Base.call(this,contour_,trilateralArray_,endLine_);
};
trilateral_path_FillOnly.__name__ = true;
trilateral_path_FillOnly.__super__ = trilateral_path_Base;
trilateral_path_FillOnly.prototype = $extend(trilateral_path_Base.prototype,{
	line: function(x_,y_) {
	}
});
var trilateral_path_Fine = function(contour_,trilateralArray_,endLine_) {
	trilateral_path_Base.call(this,contour_,trilateralArray_,endLine_);
};
trilateral_path_Fine.__name__ = true;
trilateral_path_Fine.__super__ = trilateral_path_Base;
trilateral_path_Fine.prototype = $extend(trilateral_path_Base.prototype,{
	line: function(x_,y_) {
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		var oldAngle = _this.dx != null ? _this.angle1 : null;
		_this.halfA = Math.PI / 2;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var x = _this.dxOld - x_;
		var y = _this.dyOld - y_;
		var x1 = _this.exOld - x_;
		var y1 = _this.eyOld - y_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(_this.ay - _this.dyOld,_this.ax - _this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.eyPrev,_this.ax - _this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(_this.ay - _this.eyOld,_this.ax - _this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.dyPrev,_this.ax - _this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f1;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f1 = theta1;
			} else {
				var a1 = theta1 % (2 * Math.PI);
				f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
			}
			var this2 = f1;
			var zb = this2;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(theta0 - theta1);
			var clockwise = theta0 < theta1;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f2;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f2 = theta0;
			} else {
				var a2 = theta0 % (2 * Math.PI);
				f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
			}
			var this3 = f2;
			var za1 = this3;
			var f3;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f3 = theta1;
			} else {
				var a3 = theta1 % (2 * Math.PI);
				f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
			}
			var this4 = f3;
			var zb1 = this4;
			var fa1 = za1;
			var fb1 = zb1;
			var theta2 = Math.abs(theta0 - theta1);
			var clockwise1 = theta0 < theta1;
			var dif2 = clockwise1 ? theta2 : -theta2;
			dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
			break;
		case 2:
			var f4;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f4 = theta0;
			} else {
				var a4 = theta0 % (2 * Math.PI);
				f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
			}
			var this5 = f4;
			var za2 = this5;
			var f5;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f5 = theta1;
			} else {
				var a5 = theta1 % (2 * Math.PI);
				f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
			}
			var this6 = f5;
			var zb2 = this6;
			var fa2 = theta0;
			var fb2 = theta1;
			var theta3 = Math.abs(theta0 - theta1);
			var smallest = theta3 <= Math.PI;
			var clockwise2 = theta0 < theta1;
			var dif3 = clockwise2 ? theta3 : -theta3;
			dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
			break;
		case 3:
			var f6;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f6 = theta0;
			} else {
				var a6 = theta0 % (2 * Math.PI);
				f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
			}
			var this7 = f6;
			var za3 = this7;
			var f7;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f7 = theta1;
			} else {
				var a7 = theta1 % (2 * Math.PI);
				f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
			}
			var this8 = f7;
			var zb3 = this8;
			var fa3 = theta0;
			var fb3 = theta1;
			var theta4 = Math.abs(theta0 - theta1);
			var largest = theta4 > Math.PI;
			var clockwise3 = theta0 < theta1;
			var dif4 = clockwise3 ? theta4 : -theta4;
			dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta4) : 2 * Math.PI - theta4;
			break;
		}
		if(_this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f8;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f8 = theta0;
			} else {
				var a8 = (theta0 + Math.PI) % (2 * Math.PI);
				f8 = a8 >= 0 ? a8 - Math.PI : a8 + Math.PI;
			}
			var this9 = f8;
			var start = this9;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			_this.jx = _this.ax + h * Math.sin(delta);
			_this.jy = _this.ay + h * Math.cos(delta);
		}
		if(_this.count == 0 && (_this.endLine == 1 || _this.endLine == 3)) {
			var ax = _this.ax;
			var ay = _this.ay;
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma1 = -_this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			var this10 = _this.triArr;
			var t = [];
			var this11;
			if(t == null) {
				var t1 = [];
				var this12 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
				this11 = this12;
			} else {
				this11 = t;
			}
			var this13 = this11;
			var out = this13;
			var pi = Math.PI;
			var step = pi * 2 / 36;
			var dif5;
			switch(trilateral_angle_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f9;
				if(beta >= 0 && beta > Math.PI) {
					f9 = beta;
				} else {
					var a9 = beta % (2 * Math.PI);
					f9 = a9 >= 0 ? a9 : a9 + 2 * Math.PI;
				}
				var this14 = f9;
				var za4 = this14;
				var f10;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f10 = gamma1;
				} else {
					var a10 = gamma1 % (2 * Math.PI);
					f10 = a10 >= 0 ? a10 : a10 + 2 * Math.PI;
				}
				var this15 = f10;
				var zb4 = this15;
				var fa4 = za4;
				var fb4 = zb4;
				var theta5 = Math.abs(beta - gamma1);
				var clockwise4 = beta < gamma1;
				var dif6 = clockwise4 ? theta5 : -theta5;
				dif5 = dif6 > 0 ? dif6 : 2 * Math.PI + dif6;
				break;
			case 1:
				var f11;
				if(beta >= 0 && beta > Math.PI) {
					f11 = beta;
				} else {
					var a11 = beta % (2 * Math.PI);
					f11 = a11 >= 0 ? a11 : a11 + 2 * Math.PI;
				}
				var this16 = f11;
				var za5 = this16;
				var f12;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f12 = gamma1;
				} else {
					var a12 = gamma1 % (2 * Math.PI);
					f12 = a12 >= 0 ? a12 : a12 + 2 * Math.PI;
				}
				var this17 = f12;
				var zb5 = this17;
				var fa5 = za5;
				var fb5 = zb5;
				var theta6 = Math.abs(beta - gamma1);
				var clockwise5 = beta < gamma1;
				var dif7 = clockwise5 ? theta6 : -theta6;
				dif5 = dif7 < 0 ? dif7 : -2 * Math.PI + dif7;
				break;
			case 2:
				var f13;
				if(beta >= 0 && beta > Math.PI) {
					f13 = beta;
				} else {
					var a13 = beta % (2 * Math.PI);
					f13 = a13 >= 0 ? a13 : a13 + 2 * Math.PI;
				}
				var this18 = f13;
				var za6 = this18;
				var f14;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f14 = gamma1;
				} else {
					var a14 = gamma1 % (2 * Math.PI);
					f14 = a14 >= 0 ? a14 : a14 + 2 * Math.PI;
				}
				var this19 = f14;
				var zb6 = this19;
				var fa6 = beta;
				var fb6 = gamma1;
				var theta7 = Math.abs(beta - gamma1);
				var smallest1 = theta7 <= Math.PI;
				var clockwise6 = beta < gamma1;
				var dif8 = clockwise6 ? theta7 : -theta7;
				dif5 = smallest1 ? dif8 : clockwise6 ? -(2 * Math.PI - theta7) : 2 * Math.PI - theta7;
				break;
			case 3:
				var f15;
				if(beta >= 0 && beta > Math.PI) {
					f15 = beta;
				} else {
					var a15 = beta % (2 * Math.PI);
					f15 = a15 >= 0 ? a15 : a15 + 2 * Math.PI;
				}
				var this20 = f15;
				var za7 = this20;
				var f16;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f16 = gamma1;
				} else {
					var a16 = gamma1 % (2 * Math.PI);
					f16 = a16 >= 0 ? a16 : a16 + 2 * Math.PI;
				}
				var this21 = f16;
				var zb7 = this21;
				var fa7 = beta;
				var fb7 = gamma1;
				var theta8 = Math.abs(beta - gamma1);
				var largest1 = theta8 > Math.PI;
				var clockwise7 = beta < gamma1;
				var dif9 = clockwise7 ? theta8 : -theta8;
				dif5 = largest1 ? dif9 : clockwise7 ? -(2 * Math.PI - theta8) : 2 * Math.PI - theta8;
				break;
			}
			var positive = dif5 >= 0;
			var totalSteps = Math.ceil(Math.abs(dif5) / step);
			var step1 = dif5 / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					var t2 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
					out[out.length] = t2;
				}
				angle += step1;
				bx = cx;
				by = cy;
			}
			var triArr = out;
			var _g2 = 0;
			while(_g2 < triArr.length) {
				var t3 = triArr[_g2];
				++_g2;
				this10[this10.length] = t3;
			}
			var pA = _this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g3 = 0;
			var _g11 = p4;
			while(_g3 < _g11) {
				var i1 = _g3++;
				_this.pointsAnti[pA++] = temp[len - 2 * i1 + 1];
				_this.pointsAnti[pA++] = temp[len - 2 * i1];
			}
			var pC = _this.pointsClock.length;
			var _g21 = 0;
			var _g31 = p4;
			while(_g21 < _g31) {
				var i2 = _g21++;
				_this.pointsClock[pC++] = temp[i2 * 2 + len + 1];
				_this.pointsClock[pC++] = temp[i2 * 2 + len];
			}
		}
		if(_this.count != 0) {
			_this.addQuads(clockWise,width_);
		}
		_this.quadIndex = _this.triArr.length;
		if(_this.count == 0) {
			_this.penultimateAX = _this.dxPrev;
			_this.penultimateAY = _this.dyPrev;
			_this.lastAntiX = _this.ex;
			_this.lastAntiY = _this.ey;
			_this.penultimateCX = _this.dx;
			_this.penultimateCY = _this.dy;
			_this.lastClockX = _this.exPrev;
			_this.lastClockY = _this.eyPrev;
			var this22 = _this.triArr;
			var tri = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.dx,_this.dy,_this.ex,_this.ey,0);
			this22[this22.length] = tri;
			var this23 = _this.triArr;
			var tri1 = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.dx,_this.dy,_this.exPrev,_this.eyPrev,0);
			this23[this23.length] = tri1;
		} else {
			if(clockWise && !_this.lastClock) {
				_this.penultimateAX = _this.jx;
				_this.penultimateAY = _this.jy;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.exPrev;
				_this.lastClockY = _this.eyPrev;
				var this24 = _this.triArr;
				var tri2 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.ex,_this.ey,0);
				this24[this24.length] = tri2;
				var this25 = _this.triArr;
				var tri3 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.exPrev,_this.eyPrev,0);
				this25[this25.length] = tri3;
			}
			if(clockWise && _this.lastClock) {
				_this.penultimateAX = _this.jx;
				_this.penultimateAY = _this.jy;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.exPrev;
				_this.lastClockY = _this.eyPrev;
				var this26 = _this.triArr;
				var tri4 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.ex,_this.ey,0);
				this26[this26.length] = tri4;
				var this27 = _this.triArr;
				var tri5 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.exPrev,_this.eyPrev,0);
				this27[this27.length] = tri5;
			}
			if(!clockWise && !_this.lastClock) {
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.jx;
				_this.lastClockY = _this.jy;
				_this.penultimateAX = _this.dxPrev;
				_this.penultimateAY = _this.dyPrev;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				var this28 = _this.triArr;
				var tri6 = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.dx,_this.dy,_this.jx,_this.jy,0);
				this28[this28.length] = tri6;
				var this29 = _this.triArr;
				var tri7 = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.dx,_this.dy,_this.ex,_this.ey,0);
				this29[this29.length] = tri7;
			}
			if(!clockWise && _this.lastClock) {
				_this.penultimateAX = _this.dxPrev;
				_this.penultimateAY = _this.dyPrev;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.jx;
				_this.penultimateCY = _this.jy;
				_this.lastClockX = _this.dx;
				_this.lastClockY = _this.dy;
				var this30 = _this.triArr;
				var tri8 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.ex,_this.ey,0);
				this30[this30.length] = tri8;
				var this31 = _this.triArr;
				var tri9 = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.jx,_this.jy,_this.ex,_this.ey,0);
				this31[this31.length] = tri9;
			}
		}
		if(clockWise) {
			var radius1 = width_ / 2;
			var edgePoly = _this.pointsClock;
			var t4 = [];
			var this32;
			if(t4 == null) {
				var t5 = [];
				var this33 = t5 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t5;
				this32 = this33;
			} else {
				this32 = t4;
			}
			var this34 = this32;
			var out1 = this34;
			var pi1 = Math.PI;
			var step2 = pi1 * 2 / 36;
			var positive1 = dif >= 0;
			var totalSteps1 = Math.ceil(Math.abs(dif) / step2);
			var step3 = dif / totalSteps1;
			var angle1 = theta0;
			var cx1;
			var cy1;
			var bx1 = 0;
			var by1 = 0;
			var p21 = edgePoly.length;
			var count = 0;
			var _g4 = 0;
			var _g12 = totalSteps1 + 1;
			while(_g4 < _g12) {
				var i3 = _g4++;
				cx1 = ax_ + radius1 * Math.sin(angle1);
				cy1 = ay_ + radius1 * Math.cos(angle1);
				if(i3 != 0) {
					var t6 = new trilateral_tri_Trilateral(ax_,ay_,bx1,by1,cx1,cy1);
					out1[out1.length] = t6;
					edgePoly[p21++] = cx1;
					edgePoly[p21++] = cy1;
				}
				angle1 += step3;
				bx1 = cx1;
				by1 = cy1;
			}
			var trilateralArray = out1;
			var this35 = _this.triArr;
			var _g5 = 0;
			while(_g5 < trilateralArray.length) {
				var t7 = trilateralArray[_g5];
				++_g5;
				this35[this35.length] = t7;
			}
		} else {
			var radius2 = width_ / 2;
			var edgePoly1 = _this.pointsAnti;
			var t8 = [];
			var this36;
			if(t8 == null) {
				var t9 = [];
				var this37 = t9 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t9;
				this36 = this37;
			} else {
				this36 = t8;
			}
			var this38 = this36;
			var out2 = this38;
			var pi2 = Math.PI;
			var step4 = pi2 * 2 / 36;
			var positive2 = dif >= 0;
			var totalSteps2 = Math.ceil(Math.abs(dif) / step4);
			var step5 = dif / totalSteps2;
			var angle2 = theta0;
			var cx2;
			var cy2;
			var bx2 = 0;
			var by2 = 0;
			var p22 = edgePoly1.length;
			var count1 = 0;
			var _g6 = 0;
			var _g13 = totalSteps2 + 1;
			while(_g6 < _g13) {
				var i4 = _g6++;
				cx2 = ax_ + radius2 * Math.sin(angle2);
				cy2 = ay_ + radius2 * Math.cos(angle2);
				if(i4 != 0) {
					var t10 = new trilateral_tri_Trilateral(ax_,ay_,bx2,by2,cx2,cy2);
					out2[out2.length] = t10;
					edgePoly1[p22++] = cx2;
					edgePoly1[p22++] = cy2;
				}
				angle2 += step5;
				bx2 = cx2;
				by2 = cy2;
			}
			var trilateralArray1 = out2;
			var this39 = _this.triArr;
			var _g7 = 0;
			while(_g7 < trilateralArray1.length) {
				var t11 = trilateralArray1[_g7];
				++_g7;
				this39[this39.length] = t11;
			}
		}
		_this.kax = _this.dxPrev;
		_this.kay = _this.dyPrev;
		_this.kbx = _this.dx;
		_this.kby = _this.dy;
		_this.ncx = _this.exPrev;
		_this.ncy = _this.eyPrev;
		_this.kcx = _this.ex;
		_this.kcy = _this.ey;
		if(_this.count != 0) {
			if(clockWise) {
				var this40 = _this.triArr;
				var tri10 = new trilateral_tri_Trilateral(_this.ax,_this.ay,_this.dxOld,_this.dyOld,_this.jx,_this.jy,0);
				this40[this40.length] = tri10;
				var this41 = _this.triArr;
				var tri11 = new trilateral_tri_Trilateral(_this.ax,_this.ay,_this.exPrev,_this.eyPrev,_this.jx,_this.jy,0);
				this41[this41.length] = tri11;
			} else {
				var this42 = _this.triArr;
				var tri12 = new trilateral_tri_Trilateral(_this.ax,_this.ay,_this.exOld,_this.eyOld,_this.jx,_this.jy,0);
				this42[this42.length] = tri12;
				var this43 = _this.triArr;
				var tri13 = new trilateral_tri_Trilateral(_this.ax,_this.ay,_this.dxPrev,_this.dyPrev,_this.jx,_this.jy,0);
				this43[this43.length] = tri13;
			}
		}
		_this.jxOld = _this.jx;
		_this.jyOld = _this.jy;
		_this.lastClock = clockWise;
		_this.count++;
	}
});
var trilateral_polys_Poly = function() { };
trilateral_polys_Poly.__name__ = true;
trilateral_polys_Poly.circle = function(ax,ay,radius,sides,omega) {
	if(omega == null) {
		omega = 0.;
	}
	if(sides == null) {
		sides = 36;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var theta = pi / 2 + omega;
	var step = pi * 2 / sides;
	var bx;
	var by;
	var cx;
	var cy;
	var _g = 0;
	var _g1 = sides;
	while(_g < _g1) {
		var i = _g++;
		bx = ax + radius * Math.sin(theta);
		by = ay + radius * Math.cos(theta);
		theta += step;
		cx = ax + radius * Math.sin(theta);
		cy = ay + radius * Math.cos(theta);
		var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
		out[out.length] = tri;
	}
	return out;
};
trilateral_polys_Poly.ellipse = function(ax,ay,rx,ry,sides) {
	if(sides == null) {
		sides = 36;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var theta = pi / 2;
	var step = pi * 2 / sides;
	var bx;
	var by;
	var cx;
	var cy;
	var _g = 0;
	var _g1 = sides;
	while(_g < _g1) {
		var i = _g++;
		bx = ax + rx * Math.sin(theta);
		by = ay + ry * Math.cos(theta);
		theta += step;
		cx = ax + rx * Math.sin(theta);
		cy = ay + ry * Math.cos(theta);
		var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
		out[out.length] = tri;
	}
	return out;
};
trilateral_polys_Poly.pie = function(ax,ay,radius,beta,gamma,prefer,mark,sides) {
	if(sides == null) {
		sides = 36;
	}
	if(mark == null) {
		mark = 0;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var step = pi * 2 / sides;
	var dif;
	switch(prefer._hx_index) {
	case 0:
		var f;
		if(beta >= 0 && beta > Math.PI) {
			f = beta;
		} else {
			var a = beta % (2 * Math.PI);
			f = a >= 0 ? a : a + 2 * Math.PI;
		}
		var this3 = f;
		var za = this3;
		var f1;
		if(gamma >= 0 && gamma > Math.PI) {
			f1 = gamma;
		} else {
			var a1 = gamma % (2 * Math.PI);
			f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this4 = f1;
		var zb = this4;
		var fa = za;
		var fb = zb;
		var theta = Math.abs(beta - gamma);
		var clockwise = beta < gamma;
		var dif1 = clockwise ? theta : -theta;
		dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
		break;
	case 1:
		var f2;
		if(beta >= 0 && beta > Math.PI) {
			f2 = beta;
		} else {
			var a2 = beta % (2 * Math.PI);
			f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
		}
		var this5 = f2;
		var za1 = this5;
		var f3;
		if(gamma >= 0 && gamma > Math.PI) {
			f3 = gamma;
		} else {
			var a3 = gamma % (2 * Math.PI);
			f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
		}
		var this6 = f3;
		var zb1 = this6;
		var fa1 = za1;
		var fb1 = zb1;
		var theta1 = Math.abs(beta - gamma);
		var clockwise1 = beta < gamma;
		var dif2 = clockwise1 ? theta1 : -theta1;
		dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
		break;
	case 2:
		var f4;
		if(beta >= 0 && beta > Math.PI) {
			f4 = beta;
		} else {
			var a4 = beta % (2 * Math.PI);
			f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
		}
		var this7 = f4;
		var za2 = this7;
		var f5;
		if(gamma >= 0 && gamma > Math.PI) {
			f5 = gamma;
		} else {
			var a5 = gamma % (2 * Math.PI);
			f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
		}
		var this8 = f5;
		var zb2 = this8;
		var fa2 = beta;
		var fb2 = gamma;
		var theta2 = Math.abs(beta - gamma);
		var smallest = theta2 <= Math.PI;
		var clockwise2 = beta < gamma;
		var dif3 = clockwise2 ? theta2 : -theta2;
		dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
		break;
	case 3:
		var f6;
		if(beta >= 0 && beta > Math.PI) {
			f6 = beta;
		} else {
			var a6 = beta % (2 * Math.PI);
			f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
		}
		var this9 = f6;
		var za3 = this9;
		var f7;
		if(gamma >= 0 && gamma > Math.PI) {
			f7 = gamma;
		} else {
			var a7 = gamma % (2 * Math.PI);
			f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
		}
		var this10 = f7;
		var zb3 = this10;
		var fa3 = beta;
		var fb3 = gamma;
		var theta3 = Math.abs(beta - gamma);
		var largest = theta3 > Math.PI;
		var clockwise3 = beta < gamma;
		var dif4 = clockwise3 ? theta3 : -theta3;
		dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
		break;
	}
	var positive = dif >= 0;
	var totalSteps = Math.ceil(Math.abs(dif) / step);
	var step1 = dif / totalSteps;
	var angle = beta;
	var cx;
	var cy;
	var bx = 0;
	var by = 0;
	var _g = 0;
	var _g1 = totalSteps + 1;
	while(_g < _g1) {
		var i = _g++;
		cx = ax + radius * Math.sin(angle);
		cy = ay + radius * Math.cos(angle);
		if(i != 0) {
			var t1 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
			out[out.length] = t1;
			if(mark != 0) {
				t1.mark = mark;
			}
		}
		angle += step1;
		bx = cx;
		by = cy;
	}
	return out;
};
trilateral_polys_Poly.pieX = function(ax,ay,radius,beta,gamma,prefer,edgePoly,mark,sides) {
	if(sides == null) {
		sides = 36;
	}
	if(mark == null) {
		mark = 0;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var step = pi * 2 / sides;
	var dif;
	switch(prefer._hx_index) {
	case 0:
		var f;
		if(beta >= 0 && beta > Math.PI) {
			f = beta;
		} else {
			var a = beta % (2 * Math.PI);
			f = a >= 0 ? a : a + 2 * Math.PI;
		}
		var this3 = f;
		var za = this3;
		var f1;
		if(gamma >= 0 && gamma > Math.PI) {
			f1 = gamma;
		} else {
			var a1 = gamma % (2 * Math.PI);
			f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this4 = f1;
		var zb = this4;
		var fa = za;
		var fb = zb;
		var theta = Math.abs(beta - gamma);
		var clockwise = beta < gamma;
		var dif1 = clockwise ? theta : -theta;
		dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
		break;
	case 1:
		var f2;
		if(beta >= 0 && beta > Math.PI) {
			f2 = beta;
		} else {
			var a2 = beta % (2 * Math.PI);
			f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
		}
		var this5 = f2;
		var za1 = this5;
		var f3;
		if(gamma >= 0 && gamma > Math.PI) {
			f3 = gamma;
		} else {
			var a3 = gamma % (2 * Math.PI);
			f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
		}
		var this6 = f3;
		var zb1 = this6;
		var fa1 = za1;
		var fb1 = zb1;
		var theta1 = Math.abs(beta - gamma);
		var clockwise1 = beta < gamma;
		var dif2 = clockwise1 ? theta1 : -theta1;
		dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
		break;
	case 2:
		var f4;
		if(beta >= 0 && beta > Math.PI) {
			f4 = beta;
		} else {
			var a4 = beta % (2 * Math.PI);
			f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
		}
		var this7 = f4;
		var za2 = this7;
		var f5;
		if(gamma >= 0 && gamma > Math.PI) {
			f5 = gamma;
		} else {
			var a5 = gamma % (2 * Math.PI);
			f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
		}
		var this8 = f5;
		var zb2 = this8;
		var fa2 = beta;
		var fb2 = gamma;
		var theta2 = Math.abs(beta - gamma);
		var smallest = theta2 <= Math.PI;
		var clockwise2 = beta < gamma;
		var dif3 = clockwise2 ? theta2 : -theta2;
		dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
		break;
	case 3:
		var f6;
		if(beta >= 0 && beta > Math.PI) {
			f6 = beta;
		} else {
			var a6 = beta % (2 * Math.PI);
			f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
		}
		var this9 = f6;
		var za3 = this9;
		var f7;
		if(gamma >= 0 && gamma > Math.PI) {
			f7 = gamma;
		} else {
			var a7 = gamma % (2 * Math.PI);
			f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
		}
		var this10 = f7;
		var zb3 = this10;
		var fa3 = beta;
		var fb3 = gamma;
		var theta3 = Math.abs(beta - gamma);
		var largest = theta3 > Math.PI;
		var clockwise3 = beta < gamma;
		var dif4 = clockwise3 ? theta3 : -theta3;
		dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
		break;
	}
	var positive = dif >= 0;
	var totalSteps = Math.ceil(Math.abs(dif) / step);
	var step1 = dif / totalSteps;
	var angle = beta;
	var cx;
	var cy;
	var bx = 0;
	var by = 0;
	var p2 = edgePoly.length;
	var _g = 0;
	var _g1 = totalSteps + 1;
	while(_g < _g1) {
		var i = _g++;
		cx = ax + radius * Math.sin(angle);
		cy = ay + radius * Math.cos(angle);
		edgePoly[p2++] = cx;
		edgePoly[p2++] = cy;
		if(i != 0) {
			var t1 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
			out[out.length] = t1;
			if(mark != 0) {
				t1.mark = mark;
			}
		}
		angle += step1;
		bx = cx;
		by = cy;
	}
	return out;
};
trilateral_polys_Poly.ellpisePie = function(ax,ay,rx,ry,beta,gamma,prefer,mark,sides) {
	if(sides == null) {
		sides = 36;
	}
	if(mark == null) {
		mark = 0;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var step = pi * 2 / sides;
	var dif;
	switch(prefer._hx_index) {
	case 0:
		var f;
		if(beta >= 0 && beta > Math.PI) {
			f = beta;
		} else {
			var a = beta % (2 * Math.PI);
			f = a >= 0 ? a : a + 2 * Math.PI;
		}
		var this3 = f;
		var za = this3;
		var f1;
		if(gamma >= 0 && gamma > Math.PI) {
			f1 = gamma;
		} else {
			var a1 = gamma % (2 * Math.PI);
			f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this4 = f1;
		var zb = this4;
		var fa = za;
		var fb = zb;
		var theta = Math.abs(beta - gamma);
		var clockwise = beta < gamma;
		var dif1 = clockwise ? theta : -theta;
		dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
		break;
	case 1:
		var f2;
		if(beta >= 0 && beta > Math.PI) {
			f2 = beta;
		} else {
			var a2 = beta % (2 * Math.PI);
			f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
		}
		var this5 = f2;
		var za1 = this5;
		var f3;
		if(gamma >= 0 && gamma > Math.PI) {
			f3 = gamma;
		} else {
			var a3 = gamma % (2 * Math.PI);
			f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
		}
		var this6 = f3;
		var zb1 = this6;
		var fa1 = za1;
		var fb1 = zb1;
		var theta1 = Math.abs(beta - gamma);
		var clockwise1 = beta < gamma;
		var dif2 = clockwise1 ? theta1 : -theta1;
		dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
		break;
	case 2:
		var f4;
		if(beta >= 0 && beta > Math.PI) {
			f4 = beta;
		} else {
			var a4 = beta % (2 * Math.PI);
			f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
		}
		var this7 = f4;
		var za2 = this7;
		var f5;
		if(gamma >= 0 && gamma > Math.PI) {
			f5 = gamma;
		} else {
			var a5 = gamma % (2 * Math.PI);
			f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
		}
		var this8 = f5;
		var zb2 = this8;
		var fa2 = beta;
		var fb2 = gamma;
		var theta2 = Math.abs(beta - gamma);
		var smallest = theta2 <= Math.PI;
		var clockwise2 = beta < gamma;
		var dif3 = clockwise2 ? theta2 : -theta2;
		dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
		break;
	case 3:
		var f6;
		if(beta >= 0 && beta > Math.PI) {
			f6 = beta;
		} else {
			var a6 = beta % (2 * Math.PI);
			f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
		}
		var this9 = f6;
		var za3 = this9;
		var f7;
		if(gamma >= 0 && gamma > Math.PI) {
			f7 = gamma;
		} else {
			var a7 = gamma % (2 * Math.PI);
			f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
		}
		var this10 = f7;
		var zb3 = this10;
		var fa3 = beta;
		var fb3 = gamma;
		var theta3 = Math.abs(beta - gamma);
		var largest = theta3 > Math.PI;
		var clockwise3 = beta < gamma;
		var dif4 = clockwise3 ? theta3 : -theta3;
		dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
		break;
	}
	var positive = dif >= 0;
	var totalSteps = Math.ceil(Math.abs(dif) / step);
	var step1 = dif / totalSteps;
	var angle = beta;
	var cx;
	var cy;
	var bx = 0;
	var by = 0;
	var _g = 0;
	var _g1 = totalSteps + 1;
	while(_g < _g1) {
		var i = _g++;
		cx = ax + rx * Math.sin(angle);
		cy = ay + ry * Math.cos(angle);
		if(i != 0) {
			var t1 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
			out[out.length] = t1;
			if(mark != 0) {
				t1.mark = mark;
			}
		}
		angle += step1;
		bx = cx;
		by = cy;
	}
	return out;
};
trilateral_polys_Poly.pieDif = function(ax,ay,radius,beta,dif,mark,sides) {
	if(sides == null) {
		sides = 36;
	}
	if(mark == null) {
		mark = 0;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var step = pi * 2 / sides;
	var positive = dif >= 0;
	var totalSteps = Math.ceil(Math.abs(dif) / step);
	var step1 = dif / totalSteps;
	var angle = beta;
	var cx;
	var cy;
	var bx = 0;
	var by = 0;
	var _g = 0;
	var _g1 = totalSteps + 1;
	while(_g < _g1) {
		var i = _g++;
		cx = ax + radius * Math.sin(angle);
		cy = ay + radius * Math.cos(angle);
		if(i != 0) {
			var t1 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
			out[out.length] = t1;
			if(mark != 0) {
				t1.mark = mark;
			}
		}
		angle += step1;
		bx = cx;
		by = cy;
	}
	return out;
};
trilateral_polys_Poly.pieDifX = function(ax,ay,radius,beta,dif,edgePoly,mark,sides) {
	if(sides == null) {
		sides = 36;
	}
	if(mark == null) {
		mark = 0;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var step = pi * 2 / sides;
	var positive = dif >= 0;
	var totalSteps = Math.ceil(Math.abs(dif) / step);
	var step1 = dif / totalSteps;
	var angle = beta;
	var cx;
	var cy;
	var bx = 0;
	var by = 0;
	var p2 = edgePoly.length;
	var count = 0;
	var _g = 0;
	var _g1 = totalSteps + 1;
	while(_g < _g1) {
		var i = _g++;
		cx = ax + radius * Math.sin(angle);
		cy = ay + radius * Math.cos(angle);
		if(i != 0) {
			var t1 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
			out[out.length] = t1;
			if(mark != 0) {
				t1.mark = mark;
			}
			edgePoly[p2++] = cx;
			edgePoly[p2++] = cy;
		}
		angle += step1;
		bx = cx;
		by = cy;
	}
	return out;
};
trilateral_polys_Poly.arc = function(ax,ay,radius,width,beta,gamma,prefer,mark,sides) {
	if(sides == null) {
		sides = 36;
	}
	if(mark == null) {
		mark = 0;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var step = pi * 2 / sides;
	var dif;
	switch(prefer._hx_index) {
	case 0:
		var f;
		if(beta >= 0 && beta > Math.PI) {
			f = beta;
		} else {
			var a = beta % (2 * Math.PI);
			f = a >= 0 ? a : a + 2 * Math.PI;
		}
		var this3 = f;
		var za = this3;
		var f1;
		if(gamma >= 0 && gamma > Math.PI) {
			f1 = gamma;
		} else {
			var a1 = gamma % (2 * Math.PI);
			f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this4 = f1;
		var zb = this4;
		var fa = za;
		var fb = zb;
		var theta = Math.abs(beta - gamma);
		var clockwise = beta < gamma;
		var dif1 = clockwise ? theta : -theta;
		dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
		break;
	case 1:
		var f2;
		if(beta >= 0 && beta > Math.PI) {
			f2 = beta;
		} else {
			var a2 = beta % (2 * Math.PI);
			f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
		}
		var this5 = f2;
		var za1 = this5;
		var f3;
		if(gamma >= 0 && gamma > Math.PI) {
			f3 = gamma;
		} else {
			var a3 = gamma % (2 * Math.PI);
			f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
		}
		var this6 = f3;
		var zb1 = this6;
		var fa1 = za1;
		var fb1 = zb1;
		var theta1 = Math.abs(beta - gamma);
		var clockwise1 = beta < gamma;
		var dif2 = clockwise1 ? theta1 : -theta1;
		dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
		break;
	case 2:
		var f4;
		if(beta >= 0 && beta > Math.PI) {
			f4 = beta;
		} else {
			var a4 = beta % (2 * Math.PI);
			f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
		}
		var this7 = f4;
		var za2 = this7;
		var f5;
		if(gamma >= 0 && gamma > Math.PI) {
			f5 = gamma;
		} else {
			var a5 = gamma % (2 * Math.PI);
			f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
		}
		var this8 = f5;
		var zb2 = this8;
		var fa2 = beta;
		var fb2 = gamma;
		var theta2 = Math.abs(beta - gamma);
		var smallest = theta2 <= Math.PI;
		var clockwise2 = beta < gamma;
		var dif3 = clockwise2 ? theta2 : -theta2;
		dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
		break;
	case 3:
		var f6;
		if(beta >= 0 && beta > Math.PI) {
			f6 = beta;
		} else {
			var a6 = beta % (2 * Math.PI);
			f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
		}
		var this9 = f6;
		var za3 = this9;
		var f7;
		if(gamma >= 0 && gamma > Math.PI) {
			f7 = gamma;
		} else {
			var a7 = gamma % (2 * Math.PI);
			f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
		}
		var this10 = f7;
		var zb3 = this10;
		var fa3 = beta;
		var fb3 = gamma;
		var theta3 = Math.abs(beta - gamma);
		var largest = theta3 > Math.PI;
		var clockwise3 = beta < gamma;
		var dif4 = clockwise3 ? theta3 : -theta3;
		dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
		break;
	}
	var positive = dif >= 0;
	var totalSteps = Math.ceil(Math.abs(dif) / step);
	var step1 = dif / totalSteps;
	var angle = beta;
	var cx;
	var cy;
	var bx = 0;
	var by = 0;
	var dx = 0;
	var dy = 0;
	var ex = 0;
	var ey = 0;
	var r2 = radius - width;
	var _g = 0;
	var _g1 = totalSteps + 1;
	while(_g < _g1) {
		var i = _g++;
		cx = ax + radius * Math.sin(angle);
		cy = ay + radius * Math.cos(angle);
		ex = ax + r2 * Math.sin(angle);
		ey = ay + r2 * Math.cos(angle);
		if(i != 0) {
			var t0 = new trilateral_tri_Trilateral(dx,dy,bx,by,cx,cy);
			var t1 = new trilateral_tri_Trilateral(dx,dy,cx,cy,ex,ey);
			out[out.length] = t0;
			out[out.length] = t1;
			if(mark != 0) {
				t0.mark = mark;
				t1.mark = mark;
			}
		}
		angle += step1;
		bx = cx;
		by = cy;
		dx = ex;
		dy = ey;
	}
	return out;
};
trilateral_polys_Poly.circleMarked = function(ax,ay,radius,mark,sides,omega) {
	if(omega == null) {
		omega = 0.;
	}
	if(sides == null) {
		sides = 36;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var theta = pi / 2 + omega;
	var step = pi * 2 / sides;
	var bx;
	var by;
	var cx;
	var cy;
	var _g = 0;
	var _g1 = sides;
	while(_g < _g1) {
		var i = _g++;
		bx = ax + radius * Math.sin(theta);
		by = ay + radius * Math.cos(theta);
		theta += step;
		cx = ax + radius * Math.sin(theta);
		cy = ay + radius * Math.cos(theta);
		var t1 = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
		out[out.length] = t1;
		t1.mark = mark;
	}
	return out;
};
trilateral_polys_Poly.circleOnSide = function(ax,ay,radius,sides,omega) {
	if(omega == null) {
		omega = 0.;
	}
	if(sides == null) {
		sides = 36;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var theta = pi / 2;
	var step = pi * 2 / sides;
	theta -= step / 2 + omega;
	var bx;
	var by;
	var cx;
	var cy;
	var _g = 0;
	var _g1 = sides;
	while(_g < _g1) {
		var i = _g++;
		bx = ax + radius * Math.sin(theta);
		by = ay + radius * Math.cos(theta);
		theta += step;
		cx = ax + radius * Math.sin(theta);
		cy = ay + radius * Math.cos(theta);
		var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
		out[out.length] = tri;
	}
	return out;
};
trilateral_polys_Poly.ellipseOnSide = function(ax,ay,rx,ry,sides) {
	if(sides == null) {
		sides = 36;
	}
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var theta = pi / 2;
	var step = pi * 2 / sides;
	theta -= step / 2;
	var bx;
	var by;
	var cx;
	var cy;
	var _g = 0;
	var _g1 = sides;
	while(_g < _g1) {
		var i = _g++;
		bx = ax + rx * Math.sin(theta);
		by = ay + rx * Math.cos(theta);
		theta += step;
		cx = ax + rx * Math.sin(theta);
		cy = ay + ry * Math.cos(theta);
		var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
		out[out.length] = tri;
	}
	return out;
};
trilateral_polys_Poly.shape = function(x,y,radius,p,omega) {
	if(omega == null) {
		omega = 0.;
	}
	if((p & 1) == 0) {
		var t = [];
		var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
		var this2 = this1;
		var out = this2;
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / p;
		theta -= step / 2 + omega;
		var bx;
		var by;
		var cx;
		var cy;
		var _g = 0;
		var _g1 = p;
		while(_g < _g1) {
			var i = _g++;
			bx = x + radius * Math.sin(theta);
			by = y + radius * Math.cos(theta);
			theta += step;
			cx = x + radius * Math.sin(theta);
			cy = y + radius * Math.cos(theta);
			var tri = new trilateral_tri_Trilateral(x,y,bx,by,cx,cy);
			out[out.length] = tri;
		}
		return out;
	} else {
		var t1 = [];
		var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
		var this4 = this3;
		var out1 = this4;
		var pi1 = Math.PI;
		var theta1 = pi1 / 2 + omega;
		var step1 = pi1 * 2 / p;
		var bx1;
		var by1;
		var cx1;
		var cy1;
		var _g2 = 0;
		var _g11 = p;
		while(_g2 < _g11) {
			var i1 = _g2++;
			bx1 = x + radius * Math.sin(theta1);
			by1 = y + radius * Math.cos(theta1);
			theta1 += step1;
			cx1 = x + radius * Math.sin(theta1);
			cy1 = y + radius * Math.cos(theta1);
			var tri1 = new trilateral_tri_Trilateral(x,y,bx1,by1,cx1,cy1);
			out1[out1.length] = tri1;
		}
		return out1;
	}
};
trilateral_polys_Poly.roundedRectangle = function(x,y,width,height,radius) {
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var pi_2 = Math.PI / 2;
	var ax = x + radius;
	var ay = y + radius;
	var bx = x + width - radius;
	var by = y + radius;
	var cx = bx;
	var cy = y + height - radius;
	var dx = ax;
	var dy = cy;
	var ax1 = ax;
	var ay1 = y;
	var bx1 = ax + (width - radius * 2);
	var by1 = ay1;
	var cx1 = bx1;
	var cy1 = ay1 + height;
	var dx1 = ax;
	var dy1 = cy1;
	var tp_t0 = new trilateral_tri_Trilateral(ax1,ay1,bx1,by1,dx1,dy1);
	var tp_t1 = new trilateral_tri_Trilateral(bx1,by1,cx1,cy1,dx1,dy1);
	out[out.length] = tp_t0;
	out[out.length] = tp_t1;
	var dimY = height - 2 * radius;
	var ax2 = x;
	var ay2 = ay;
	var bx2 = x + radius;
	var by2 = ay2;
	var cx2 = bx2;
	var cy2 = ay2 + dimY;
	var dx2 = x;
	var dy2 = cy2;
	var tp_t01 = new trilateral_tri_Trilateral(ax2,ay2,bx2,by2,dx2,dy2);
	var tp_t11 = new trilateral_tri_Trilateral(bx2,by2,cx2,cy2,dx2,dy2);
	out[out.length] = tp_t01;
	out[out.length] = tp_t11;
	var ax3 = bx;
	var ay3 = by;
	var bx3 = bx + radius;
	var by3 = ay3;
	var cx3 = bx3;
	var cy3 = ay3 + dimY;
	var dx3 = bx;
	var dy3 = cy3;
	var tp_t02 = new trilateral_tri_Trilateral(ax3,ay3,bx3,by3,dx3,dy3);
	var tp_t12 = new trilateral_tri_Trilateral(bx3,by3,cx3,cy3,dx3,dy3);
	out[out.length] = tp_t02;
	out[out.length] = tp_t12;
	var beta = -pi;
	var gamma = -pi_2;
	var t1 = [];
	var this3;
	if(t1 == null) {
		var t2 = [];
		var this4 = t2 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t2;
		this3 = this4;
	} else {
		this3 = t1;
	}
	var this5 = this3;
	var out1 = this5;
	var pi1 = Math.PI;
	var step = pi1 * 2 / 36;
	var dif;
	switch(trilateral_angle_DifferencePreference.CLOCKWISE._hx_index) {
	case 0:
		var f;
		if(beta >= 0 && beta > Math.PI) {
			f = beta;
		} else {
			var a = beta % (2 * Math.PI);
			f = a >= 0 ? a : a + 2 * Math.PI;
		}
		var this6 = f;
		var za = this6;
		var f1;
		if(gamma >= 0 && gamma > Math.PI) {
			f1 = gamma;
		} else {
			var a1 = gamma % (2 * Math.PI);
			f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this7 = f1;
		var zb = this7;
		var fa = za;
		var fb = zb;
		var theta = Math.abs(beta - gamma);
		var clockwise = beta < gamma;
		var dif1 = clockwise ? theta : -theta;
		dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
		break;
	case 1:
		var f2;
		if(beta >= 0 && beta > Math.PI) {
			f2 = beta;
		} else {
			var a2 = beta % (2 * Math.PI);
			f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
		}
		var this8 = f2;
		var za1 = this8;
		var f3;
		if(gamma >= 0 && gamma > Math.PI) {
			f3 = gamma;
		} else {
			var a3 = gamma % (2 * Math.PI);
			f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
		}
		var this9 = f3;
		var zb1 = this9;
		var fa1 = za1;
		var fb1 = zb1;
		var theta1 = Math.abs(beta - gamma);
		var clockwise1 = beta < gamma;
		var dif2 = clockwise1 ? theta1 : -theta1;
		dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
		break;
	case 2:
		var f4;
		if(beta >= 0 && beta > Math.PI) {
			f4 = beta;
		} else {
			var a4 = beta % (2 * Math.PI);
			f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
		}
		var this10 = f4;
		var za2 = this10;
		var f5;
		if(gamma >= 0 && gamma > Math.PI) {
			f5 = gamma;
		} else {
			var a5 = gamma % (2 * Math.PI);
			f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
		}
		var this11 = f5;
		var zb2 = this11;
		var fa2 = beta;
		var fb2 = gamma;
		var theta2 = Math.abs(beta - gamma);
		var smallest = theta2 <= Math.PI;
		var clockwise2 = beta < gamma;
		var dif3 = clockwise2 ? theta2 : -theta2;
		dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
		break;
	case 3:
		var f6;
		if(beta >= 0 && beta > Math.PI) {
			f6 = beta;
		} else {
			var a6 = beta % (2 * Math.PI);
			f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
		}
		var this12 = f6;
		var za3 = this12;
		var f7;
		if(gamma >= 0 && gamma > Math.PI) {
			f7 = gamma;
		} else {
			var a7 = gamma % (2 * Math.PI);
			f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
		}
		var this13 = f7;
		var zb3 = this13;
		var fa3 = beta;
		var fb3 = gamma;
		var theta3 = Math.abs(beta - gamma);
		var largest = theta3 > Math.PI;
		var clockwise3 = beta < gamma;
		var dif4 = clockwise3 ? theta3 : -theta3;
		dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
		break;
	}
	var positive = dif >= 0;
	var totalSteps = Math.ceil(Math.abs(dif) / step);
	var step1 = dif / totalSteps;
	var angle = beta;
	var cx4;
	var cy4;
	var bx4 = 0;
	var by4 = 0;
	var _g = 0;
	var _g1 = totalSteps + 1;
	while(_g < _g1) {
		var i = _g++;
		cx4 = ax + radius * Math.sin(angle);
		cy4 = ay + radius * Math.cos(angle);
		if(i != 0) {
			var t3 = new trilateral_tri_Trilateral(ax,ay,bx4,by4,cx4,cy4);
			out1[out1.length] = t3;
		}
		angle += step1;
		bx4 = cx4;
		by4 = cy4;
	}
	var triArr = out1;
	var _g2 = 0;
	while(_g2 < triArr.length) {
		var t4 = triArr[_g2];
		++_g2;
		out[out.length] = t4;
	}
	var t5 = [];
	var this14;
	if(t5 == null) {
		var t6 = [];
		var this15 = t6 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t6;
		this14 = this15;
	} else {
		this14 = t5;
	}
	var this16 = this14;
	var out2 = this16;
	var pi2 = Math.PI;
	var step2 = pi2 * 2 / 36;
	var dif5;
	switch(trilateral_angle_DifferencePreference.CLOCKWISE._hx_index) {
	case 0:
		var f8;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f8 = pi_2;
		} else {
			var a8 = pi_2 % (2 * Math.PI);
			f8 = a8 >= 0 ? a8 : a8 + 2 * Math.PI;
		}
		var this17 = f8;
		var za4 = this17;
		var f9;
		if(pi >= 0 && pi > Math.PI) {
			f9 = pi;
		} else {
			var a9 = pi % (2 * Math.PI);
			f9 = a9 >= 0 ? a9 : a9 + 2 * Math.PI;
		}
		var this18 = f9;
		var zb4 = this18;
		var fa4 = za4;
		var fb4 = zb4;
		var theta4 = Math.abs(pi_2 - pi);
		var clockwise4 = pi_2 < pi;
		var dif6 = clockwise4 ? theta4 : -theta4;
		dif5 = dif6 > 0 ? dif6 : 2 * Math.PI + dif6;
		break;
	case 1:
		var f10;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f10 = pi_2;
		} else {
			var a10 = pi_2 % (2 * Math.PI);
			f10 = a10 >= 0 ? a10 : a10 + 2 * Math.PI;
		}
		var this19 = f10;
		var za5 = this19;
		var f11;
		if(pi >= 0 && pi > Math.PI) {
			f11 = pi;
		} else {
			var a11 = pi % (2 * Math.PI);
			f11 = a11 >= 0 ? a11 : a11 + 2 * Math.PI;
		}
		var this20 = f11;
		var zb5 = this20;
		var fa5 = za5;
		var fb5 = zb5;
		var theta5 = Math.abs(pi_2 - pi);
		var clockwise5 = pi_2 < pi;
		var dif7 = clockwise5 ? theta5 : -theta5;
		dif5 = dif7 < 0 ? dif7 : -2 * Math.PI + dif7;
		break;
	case 2:
		var f12;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f12 = pi_2;
		} else {
			var a12 = pi_2 % (2 * Math.PI);
			f12 = a12 >= 0 ? a12 : a12 + 2 * Math.PI;
		}
		var this21 = f12;
		var za6 = this21;
		var f13;
		if(pi >= 0 && pi > Math.PI) {
			f13 = pi;
		} else {
			var a13 = pi % (2 * Math.PI);
			f13 = a13 >= 0 ? a13 : a13 + 2 * Math.PI;
		}
		var this22 = f13;
		var zb6 = this22;
		var fa6 = pi_2;
		var fb6 = pi;
		var theta6 = Math.abs(pi_2 - pi);
		var smallest1 = theta6 <= Math.PI;
		var clockwise6 = pi_2 < pi;
		var dif8 = clockwise6 ? theta6 : -theta6;
		dif5 = smallest1 ? dif8 : clockwise6 ? -(2 * Math.PI - theta6) : 2 * Math.PI - theta6;
		break;
	case 3:
		var f14;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f14 = pi_2;
		} else {
			var a14 = pi_2 % (2 * Math.PI);
			f14 = a14 >= 0 ? a14 : a14 + 2 * Math.PI;
		}
		var this23 = f14;
		var za7 = this23;
		var f15;
		if(pi >= 0 && pi > Math.PI) {
			f15 = pi;
		} else {
			var a15 = pi % (2 * Math.PI);
			f15 = a15 >= 0 ? a15 : a15 + 2 * Math.PI;
		}
		var this24 = f15;
		var zb7 = this24;
		var fa7 = pi_2;
		var fb7 = pi;
		var theta7 = Math.abs(pi_2 - pi);
		var largest1 = theta7 > Math.PI;
		var clockwise7 = pi_2 < pi;
		var dif9 = clockwise7 ? theta7 : -theta7;
		dif5 = largest1 ? dif9 : clockwise7 ? -(2 * Math.PI - theta7) : 2 * Math.PI - theta7;
		break;
	}
	var positive1 = dif5 >= 0;
	var totalSteps1 = Math.ceil(Math.abs(dif5) / step2);
	var step3 = dif5 / totalSteps1;
	var angle1 = pi_2;
	var cx5;
	var cy5;
	var bx5 = 0;
	var by5 = 0;
	var _g3 = 0;
	var _g11 = totalSteps1 + 1;
	while(_g3 < _g11) {
		var i1 = _g3++;
		cx5 = bx + radius * Math.sin(angle1);
		cy5 = by + radius * Math.cos(angle1);
		if(i1 != 0) {
			var t7 = new trilateral_tri_Trilateral(bx,by,bx5,by5,cx5,cy5);
			out2[out2.length] = t7;
		}
		angle1 += step3;
		bx5 = cx5;
		by5 = cy5;
	}
	var triArr1 = out2;
	var _g4 = 0;
	while(_g4 < triArr1.length) {
		var t8 = triArr1[_g4];
		++_g4;
		out[out.length] = t8;
	}
	var t9 = [];
	var this25;
	if(t9 == null) {
		var t10 = [];
		var this26 = t10 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t10;
		this25 = this26;
	} else {
		this25 = t9;
	}
	var this27 = this25;
	var out3 = this27;
	var pi3 = Math.PI;
	var step4 = pi3 * 2 / 36;
	var dif10;
	switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE._hx_index) {
	case 0:
		var f16;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f16 = pi_2;
		} else {
			var a16 = pi_2 % (2 * Math.PI);
			f16 = a16 >= 0 ? a16 : a16 + 2 * Math.PI;
		}
		var this28 = f16;
		var za8 = this28;
		var f17;
		if(0 > Math.PI) {
			f17 = 0;
		} else {
			var a17 = 0 % (2 * Math.PI);
			f17 = a17 >= 0 ? a17 : a17 + 2 * Math.PI;
		}
		var this29 = f17;
		var zb8 = this29;
		var fa8 = za8;
		var fb8 = zb8;
		var theta8 = Math.abs(pi_2);
		var clockwise8 = pi_2 < 0;
		var dif11 = clockwise8 ? theta8 : -theta8;
		dif10 = dif11 > 0 ? dif11 : 2 * Math.PI + dif11;
		break;
	case 1:
		var f18;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f18 = pi_2;
		} else {
			var a18 = pi_2 % (2 * Math.PI);
			f18 = a18 >= 0 ? a18 : a18 + 2 * Math.PI;
		}
		var this30 = f18;
		var za9 = this30;
		var f19;
		if(0 > Math.PI) {
			f19 = 0;
		} else {
			var a19 = 0 % (2 * Math.PI);
			f19 = a19 >= 0 ? a19 : a19 + 2 * Math.PI;
		}
		var this31 = f19;
		var zb9 = this31;
		var fa9 = za9;
		var fb9 = zb9;
		var theta9 = Math.abs(pi_2);
		var clockwise9 = pi_2 < 0;
		var dif12 = clockwise9 ? theta9 : -theta9;
		dif10 = dif12 < 0 ? dif12 : -2 * Math.PI + dif12;
		break;
	case 2:
		var f20;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f20 = pi_2;
		} else {
			var a20 = pi_2 % (2 * Math.PI);
			f20 = a20 >= 0 ? a20 : a20 + 2 * Math.PI;
		}
		var this32 = f20;
		var za10 = this32;
		var f21;
		if(0 > Math.PI) {
			f21 = 0;
		} else {
			var a21 = 0 % (2 * Math.PI);
			f21 = a21 >= 0 ? a21 : a21 + 2 * Math.PI;
		}
		var this33 = f21;
		var zb10 = this33;
		var fa10 = pi_2;
		var fb10 = 0;
		var theta10 = Math.abs(pi_2);
		var smallest2 = theta10 <= Math.PI;
		var clockwise10 = pi_2 < 0;
		var dif13 = clockwise10 ? theta10 : -theta10;
		dif10 = smallest2 ? dif13 : clockwise10 ? -(2 * Math.PI - theta10) : 2 * Math.PI - theta10;
		break;
	case 3:
		var f22;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f22 = pi_2;
		} else {
			var a22 = pi_2 % (2 * Math.PI);
			f22 = a22 >= 0 ? a22 : a22 + 2 * Math.PI;
		}
		var this34 = f22;
		var za11 = this34;
		var f23;
		if(0 > Math.PI) {
			f23 = 0;
		} else {
			var a23 = 0 % (2 * Math.PI);
			f23 = a23 >= 0 ? a23 : a23 + 2 * Math.PI;
		}
		var this35 = f23;
		var zb11 = this35;
		var fa11 = pi_2;
		var fb11 = 0;
		var theta11 = Math.abs(pi_2);
		var largest2 = theta11 > Math.PI;
		var clockwise11 = pi_2 < 0;
		var dif14 = clockwise11 ? theta11 : -theta11;
		dif10 = largest2 ? dif14 : clockwise11 ? -(2 * Math.PI - theta11) : 2 * Math.PI - theta11;
		break;
	}
	var positive2 = dif10 >= 0;
	var totalSteps2 = Math.ceil(Math.abs(dif10) / step4);
	var step5 = dif10 / totalSteps2;
	var angle2 = pi_2;
	var cx6;
	var cy6;
	var bx6 = 0;
	var by6 = 0;
	var _g5 = 0;
	var _g12 = totalSteps2 + 1;
	while(_g5 < _g12) {
		var i2 = _g5++;
		cx6 = cx + radius * Math.sin(angle2);
		cy6 = cy + radius * Math.cos(angle2);
		if(i2 != 0) {
			var t11 = new trilateral_tri_Trilateral(cx,cy,bx6,by6,cx6,cy6);
			out3[out3.length] = t11;
		}
		angle2 += step5;
		bx6 = cx6;
		by6 = cy6;
	}
	var triArr2 = out3;
	var _g6 = 0;
	while(_g6 < triArr2.length) {
		var t12 = triArr2[_g6];
		++_g6;
		out[out.length] = t12;
	}
	var gamma1 = -pi_2;
	var t13 = [];
	var this36;
	if(t13 == null) {
		var t14 = [];
		var this37 = t14 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t14;
		this36 = this37;
	} else {
		this36 = t13;
	}
	var this38 = this36;
	var out4 = this38;
	var pi4 = Math.PI;
	var step6 = pi4 * 2 / 36;
	var dif15;
	switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE._hx_index) {
	case 0:
		var f24;
		if(0 > Math.PI) {
			f24 = 0;
		} else {
			var a24 = 0 % (2 * Math.PI);
			f24 = a24 >= 0 ? a24 : a24 + 2 * Math.PI;
		}
		var this39 = f24;
		var za12 = this39;
		var f25;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f25 = gamma1;
		} else {
			var a25 = gamma1 % (2 * Math.PI);
			f25 = a25 >= 0 ? a25 : a25 + 2 * Math.PI;
		}
		var this40 = f25;
		var zb12 = this40;
		var fa12 = za12;
		var fb12 = zb12;
		var theta12 = Math.abs(0 - gamma1);
		var clockwise12 = 0 < gamma1;
		var dif16 = clockwise12 ? theta12 : -theta12;
		dif15 = dif16 > 0 ? dif16 : 2 * Math.PI + dif16;
		break;
	case 1:
		var f26;
		if(0 > Math.PI) {
			f26 = 0;
		} else {
			var a26 = 0 % (2 * Math.PI);
			f26 = a26 >= 0 ? a26 : a26 + 2 * Math.PI;
		}
		var this41 = f26;
		var za13 = this41;
		var f27;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f27 = gamma1;
		} else {
			var a27 = gamma1 % (2 * Math.PI);
			f27 = a27 >= 0 ? a27 : a27 + 2 * Math.PI;
		}
		var this42 = f27;
		var zb13 = this42;
		var fa13 = za13;
		var fb13 = zb13;
		var theta13 = Math.abs(0 - gamma1);
		var clockwise13 = 0 < gamma1;
		var dif17 = clockwise13 ? theta13 : -theta13;
		dif15 = dif17 < 0 ? dif17 : -2 * Math.PI + dif17;
		break;
	case 2:
		var f28;
		if(0 > Math.PI) {
			f28 = 0;
		} else {
			var a28 = 0 % (2 * Math.PI);
			f28 = a28 >= 0 ? a28 : a28 + 2 * Math.PI;
		}
		var this43 = f28;
		var za14 = this43;
		var f29;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f29 = gamma1;
		} else {
			var a29 = gamma1 % (2 * Math.PI);
			f29 = a29 >= 0 ? a29 : a29 + 2 * Math.PI;
		}
		var this44 = f29;
		var zb14 = this44;
		var fa14 = 0;
		var fb14 = gamma1;
		var theta14 = Math.abs(0 - gamma1);
		var smallest3 = theta14 <= Math.PI;
		var clockwise14 = 0 < gamma1;
		var dif18 = clockwise14 ? theta14 : -theta14;
		dif15 = smallest3 ? dif18 : clockwise14 ? -(2 * Math.PI - theta14) : 2 * Math.PI - theta14;
		break;
	case 3:
		var f30;
		if(0 > Math.PI) {
			f30 = 0;
		} else {
			var a30 = 0 % (2 * Math.PI);
			f30 = a30 >= 0 ? a30 : a30 + 2 * Math.PI;
		}
		var this45 = f30;
		var za15 = this45;
		var f31;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f31 = gamma1;
		} else {
			var a31 = gamma1 % (2 * Math.PI);
			f31 = a31 >= 0 ? a31 : a31 + 2 * Math.PI;
		}
		var this46 = f31;
		var zb15 = this46;
		var fa15 = 0;
		var fb15 = gamma1;
		var theta15 = Math.abs(0 - gamma1);
		var largest3 = theta15 > Math.PI;
		var clockwise15 = 0 < gamma1;
		var dif19 = clockwise15 ? theta15 : -theta15;
		dif15 = largest3 ? dif19 : clockwise15 ? -(2 * Math.PI - theta15) : 2 * Math.PI - theta15;
		break;
	}
	var positive3 = dif15 >= 0;
	var totalSteps3 = Math.ceil(Math.abs(dif15) / step6);
	var step7 = dif15 / totalSteps3;
	var angle3 = 0;
	var cx7;
	var cy7;
	var bx7 = 0;
	var by7 = 0;
	var _g7 = 0;
	var _g13 = totalSteps3 + 1;
	while(_g7 < _g13) {
		var i3 = _g7++;
		cx7 = dx + radius * Math.sin(angle3);
		cy7 = dy + radius * Math.cos(angle3);
		if(i3 != 0) {
			var t15 = new trilateral_tri_Trilateral(dx,dy,bx7,by7,cx7,cy7);
			out4[out4.length] = t15;
		}
		angle3 += step7;
		bx7 = cx7;
		by7 = cy7;
	}
	var triArr3 = out4;
	var _g8 = 0;
	while(_g8 < triArr3.length) {
		var t16 = triArr3[_g8];
		++_g8;
		out[out.length] = t16;
	}
	return out;
};
trilateral_polys_Poly.roundedRectangleOutline = function(x,y,width,height,thick,radius) {
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this2 = this1;
	var out = this2;
	var pi = Math.PI;
	var pi_2 = Math.PI / 2;
	var ax = x + radius;
	var ay = y + radius;
	var bx = x + width - radius;
	var by = y + radius;
	var cx = bx;
	var cy = y + height - radius;
	var dx = ax;
	var dy = cy;
	var ax1 = ax;
	var ay1 = y;
	var bx1 = ax + (width - radius * 2);
	var by1 = ay1;
	var cx1 = bx1;
	var cy1 = ay1 + thick;
	var dx1 = ax;
	var dy1 = cy1;
	var tp_t0 = new trilateral_tri_Trilateral(ax1,ay1,bx1,by1,dx1,dy1);
	var tp_t1 = new trilateral_tri_Trilateral(bx1,by1,cx1,cy1,dx1,dy1);
	out[out.length] = tp_t0;
	out[out.length] = tp_t1;
	var ax2 = ax;
	var ay2 = y + height - thick;
	var bx2 = ax + (width - radius * 2);
	var by2 = ay2;
	var cx2 = bx2;
	var cy2 = ay2 + thick;
	var dx2 = ax;
	var dy2 = cy2;
	var tp_t01 = new trilateral_tri_Trilateral(ax2,ay2,bx2,by2,dx2,dy2);
	var tp_t11 = new trilateral_tri_Trilateral(bx2,by2,cx2,cy2,dx2,dy2);
	out[out.length] = tp_t01;
	out[out.length] = tp_t11;
	var dimY = height - 2 * radius;
	var ax3 = x;
	var ay3 = ay;
	var bx3 = x + thick;
	var by3 = ay3;
	var cx3 = bx3;
	var cy3 = ay3 + dimY;
	var dx3 = x;
	var dy3 = cy3;
	var tp_t02 = new trilateral_tri_Trilateral(ax3,ay3,bx3,by3,dx3,dy3);
	var tp_t12 = new trilateral_tri_Trilateral(bx3,by3,cx3,cy3,dx3,dy3);
	out[out.length] = tp_t02;
	out[out.length] = tp_t12;
	var x1 = x + width - thick;
	var ax4 = x1;
	var ay4 = by;
	var bx4 = x1 + thick;
	var by4 = ay4;
	var cx4 = bx4;
	var cy4 = ay4 + dimY;
	var dx4 = x1;
	var dy4 = cy4;
	var tp_t03 = new trilateral_tri_Trilateral(ax4,ay4,bx4,by4,dx4,dy4);
	var tp_t13 = new trilateral_tri_Trilateral(bx4,by4,cx4,cy4,dx4,dy4);
	out[out.length] = tp_t03;
	out[out.length] = tp_t13;
	var beta = -pi;
	var gamma = -pi_2;
	var t1 = [];
	var this3;
	if(t1 == null) {
		var t2 = [];
		var this4 = t2 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t2;
		this3 = this4;
	} else {
		this3 = t1;
	}
	var this5 = this3;
	var out1 = this5;
	var pi1 = Math.PI;
	var step = pi1 * 2 / 36;
	var dif;
	switch(trilateral_angle_DifferencePreference.CLOCKWISE._hx_index) {
	case 0:
		var f;
		if(beta >= 0 && beta > Math.PI) {
			f = beta;
		} else {
			var a = beta % (2 * Math.PI);
			f = a >= 0 ? a : a + 2 * Math.PI;
		}
		var this6 = f;
		var za = this6;
		var f1;
		if(gamma >= 0 && gamma > Math.PI) {
			f1 = gamma;
		} else {
			var a1 = gamma % (2 * Math.PI);
			f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
		}
		var this7 = f1;
		var zb = this7;
		var fa = za;
		var fb = zb;
		var theta = Math.abs(beta - gamma);
		var clockwise = beta < gamma;
		var dif1 = clockwise ? theta : -theta;
		dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
		break;
	case 1:
		var f2;
		if(beta >= 0 && beta > Math.PI) {
			f2 = beta;
		} else {
			var a2 = beta % (2 * Math.PI);
			f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
		}
		var this8 = f2;
		var za1 = this8;
		var f3;
		if(gamma >= 0 && gamma > Math.PI) {
			f3 = gamma;
		} else {
			var a3 = gamma % (2 * Math.PI);
			f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
		}
		var this9 = f3;
		var zb1 = this9;
		var fa1 = za1;
		var fb1 = zb1;
		var theta1 = Math.abs(beta - gamma);
		var clockwise1 = beta < gamma;
		var dif2 = clockwise1 ? theta1 : -theta1;
		dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
		break;
	case 2:
		var f4;
		if(beta >= 0 && beta > Math.PI) {
			f4 = beta;
		} else {
			var a4 = beta % (2 * Math.PI);
			f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
		}
		var this10 = f4;
		var za2 = this10;
		var f5;
		if(gamma >= 0 && gamma > Math.PI) {
			f5 = gamma;
		} else {
			var a5 = gamma % (2 * Math.PI);
			f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
		}
		var this11 = f5;
		var zb2 = this11;
		var fa2 = beta;
		var fb2 = gamma;
		var theta2 = Math.abs(beta - gamma);
		var smallest = theta2 <= Math.PI;
		var clockwise2 = beta < gamma;
		var dif3 = clockwise2 ? theta2 : -theta2;
		dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
		break;
	case 3:
		var f6;
		if(beta >= 0 && beta > Math.PI) {
			f6 = beta;
		} else {
			var a6 = beta % (2 * Math.PI);
			f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
		}
		var this12 = f6;
		var za3 = this12;
		var f7;
		if(gamma >= 0 && gamma > Math.PI) {
			f7 = gamma;
		} else {
			var a7 = gamma % (2 * Math.PI);
			f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
		}
		var this13 = f7;
		var zb3 = this13;
		var fa3 = beta;
		var fb3 = gamma;
		var theta3 = Math.abs(beta - gamma);
		var largest = theta3 > Math.PI;
		var clockwise3 = beta < gamma;
		var dif4 = clockwise3 ? theta3 : -theta3;
		dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
		break;
	}
	var positive = dif >= 0;
	var totalSteps = Math.ceil(Math.abs(dif) / step);
	var step1 = dif / totalSteps;
	var angle = beta;
	var cx5;
	var cy5;
	var bx5 = 0;
	var by5 = 0;
	var dx5 = 0;
	var dy5 = 0;
	var ex = 0;
	var ey = 0;
	var r2 = radius - thick;
	var _g = 0;
	var _g1 = totalSteps + 1;
	while(_g < _g1) {
		var i = _g++;
		cx5 = ax + radius * Math.sin(angle);
		cy5 = ay + radius * Math.cos(angle);
		ex = ax + r2 * Math.sin(angle);
		ey = ay + r2 * Math.cos(angle);
		if(i != 0) {
			var t0 = new trilateral_tri_Trilateral(dx5,dy5,bx5,by5,cx5,cy5);
			var t11 = new trilateral_tri_Trilateral(dx5,dy5,cx5,cy5,ex,ey);
			out1[out1.length] = t0;
			out1[out1.length] = t11;
		}
		angle += step1;
		bx5 = cx5;
		by5 = cy5;
		dx5 = ex;
		dy5 = ey;
	}
	var triArr = out1;
	var _g2 = 0;
	while(_g2 < triArr.length) {
		var t3 = triArr[_g2];
		++_g2;
		out[out.length] = t3;
	}
	var t4 = [];
	var this14;
	if(t4 == null) {
		var t5 = [];
		var this15 = t5 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t5;
		this14 = this15;
	} else {
		this14 = t4;
	}
	var this16 = this14;
	var out2 = this16;
	var pi2 = Math.PI;
	var step2 = pi2 * 2 / 36;
	var dif5;
	switch(trilateral_angle_DifferencePreference.CLOCKWISE._hx_index) {
	case 0:
		var f8;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f8 = pi_2;
		} else {
			var a8 = pi_2 % (2 * Math.PI);
			f8 = a8 >= 0 ? a8 : a8 + 2 * Math.PI;
		}
		var this17 = f8;
		var za4 = this17;
		var f9;
		if(pi >= 0 && pi > Math.PI) {
			f9 = pi;
		} else {
			var a9 = pi % (2 * Math.PI);
			f9 = a9 >= 0 ? a9 : a9 + 2 * Math.PI;
		}
		var this18 = f9;
		var zb4 = this18;
		var fa4 = za4;
		var fb4 = zb4;
		var theta4 = Math.abs(pi_2 - pi);
		var clockwise4 = pi_2 < pi;
		var dif6 = clockwise4 ? theta4 : -theta4;
		dif5 = dif6 > 0 ? dif6 : 2 * Math.PI + dif6;
		break;
	case 1:
		var f10;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f10 = pi_2;
		} else {
			var a10 = pi_2 % (2 * Math.PI);
			f10 = a10 >= 0 ? a10 : a10 + 2 * Math.PI;
		}
		var this19 = f10;
		var za5 = this19;
		var f11;
		if(pi >= 0 && pi > Math.PI) {
			f11 = pi;
		} else {
			var a11 = pi % (2 * Math.PI);
			f11 = a11 >= 0 ? a11 : a11 + 2 * Math.PI;
		}
		var this20 = f11;
		var zb5 = this20;
		var fa5 = za5;
		var fb5 = zb5;
		var theta5 = Math.abs(pi_2 - pi);
		var clockwise5 = pi_2 < pi;
		var dif7 = clockwise5 ? theta5 : -theta5;
		dif5 = dif7 < 0 ? dif7 : -2 * Math.PI + dif7;
		break;
	case 2:
		var f12;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f12 = pi_2;
		} else {
			var a12 = pi_2 % (2 * Math.PI);
			f12 = a12 >= 0 ? a12 : a12 + 2 * Math.PI;
		}
		var this21 = f12;
		var za6 = this21;
		var f13;
		if(pi >= 0 && pi > Math.PI) {
			f13 = pi;
		} else {
			var a13 = pi % (2 * Math.PI);
			f13 = a13 >= 0 ? a13 : a13 + 2 * Math.PI;
		}
		var this22 = f13;
		var zb6 = this22;
		var fa6 = pi_2;
		var fb6 = pi;
		var theta6 = Math.abs(pi_2 - pi);
		var smallest1 = theta6 <= Math.PI;
		var clockwise6 = pi_2 < pi;
		var dif8 = clockwise6 ? theta6 : -theta6;
		dif5 = smallest1 ? dif8 : clockwise6 ? -(2 * Math.PI - theta6) : 2 * Math.PI - theta6;
		break;
	case 3:
		var f14;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f14 = pi_2;
		} else {
			var a14 = pi_2 % (2 * Math.PI);
			f14 = a14 >= 0 ? a14 : a14 + 2 * Math.PI;
		}
		var this23 = f14;
		var za7 = this23;
		var f15;
		if(pi >= 0 && pi > Math.PI) {
			f15 = pi;
		} else {
			var a15 = pi % (2 * Math.PI);
			f15 = a15 >= 0 ? a15 : a15 + 2 * Math.PI;
		}
		var this24 = f15;
		var zb7 = this24;
		var fa7 = pi_2;
		var fb7 = pi;
		var theta7 = Math.abs(pi_2 - pi);
		var largest1 = theta7 > Math.PI;
		var clockwise7 = pi_2 < pi;
		var dif9 = clockwise7 ? theta7 : -theta7;
		dif5 = largest1 ? dif9 : clockwise7 ? -(2 * Math.PI - theta7) : 2 * Math.PI - theta7;
		break;
	}
	var positive1 = dif5 >= 0;
	var totalSteps1 = Math.ceil(Math.abs(dif5) / step2);
	var step3 = dif5 / totalSteps1;
	var angle1 = pi_2;
	var cx6;
	var cy6;
	var bx6 = 0;
	var by6 = 0;
	var dx6 = 0;
	var dy6 = 0;
	var ex1 = 0;
	var ey1 = 0;
	var r21 = radius - thick;
	var _g3 = 0;
	var _g11 = totalSteps1 + 1;
	while(_g3 < _g11) {
		var i1 = _g3++;
		cx6 = bx + radius * Math.sin(angle1);
		cy6 = by + radius * Math.cos(angle1);
		ex1 = bx + r21 * Math.sin(angle1);
		ey1 = by + r21 * Math.cos(angle1);
		if(i1 != 0) {
			var t01 = new trilateral_tri_Trilateral(dx6,dy6,bx6,by6,cx6,cy6);
			var t12 = new trilateral_tri_Trilateral(dx6,dy6,cx6,cy6,ex1,ey1);
			out2[out2.length] = t01;
			out2[out2.length] = t12;
		}
		angle1 += step3;
		bx6 = cx6;
		by6 = cy6;
		dx6 = ex1;
		dy6 = ey1;
	}
	var triArr1 = out2;
	var _g4 = 0;
	while(_g4 < triArr1.length) {
		var t6 = triArr1[_g4];
		++_g4;
		out[out.length] = t6;
	}
	var t7 = [];
	var this25;
	if(t7 == null) {
		var t8 = [];
		var this26 = t8 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t8;
		this25 = this26;
	} else {
		this25 = t7;
	}
	var this27 = this25;
	var out3 = this27;
	var pi3 = Math.PI;
	var step4 = pi3 * 2 / 36;
	var dif10;
	switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE._hx_index) {
	case 0:
		var f16;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f16 = pi_2;
		} else {
			var a16 = pi_2 % (2 * Math.PI);
			f16 = a16 >= 0 ? a16 : a16 + 2 * Math.PI;
		}
		var this28 = f16;
		var za8 = this28;
		var f17;
		if(0 > Math.PI) {
			f17 = 0;
		} else {
			var a17 = 0 % (2 * Math.PI);
			f17 = a17 >= 0 ? a17 : a17 + 2 * Math.PI;
		}
		var this29 = f17;
		var zb8 = this29;
		var fa8 = za8;
		var fb8 = zb8;
		var theta8 = Math.abs(pi_2);
		var clockwise8 = pi_2 < 0;
		var dif11 = clockwise8 ? theta8 : -theta8;
		dif10 = dif11 > 0 ? dif11 : 2 * Math.PI + dif11;
		break;
	case 1:
		var f18;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f18 = pi_2;
		} else {
			var a18 = pi_2 % (2 * Math.PI);
			f18 = a18 >= 0 ? a18 : a18 + 2 * Math.PI;
		}
		var this30 = f18;
		var za9 = this30;
		var f19;
		if(0 > Math.PI) {
			f19 = 0;
		} else {
			var a19 = 0 % (2 * Math.PI);
			f19 = a19 >= 0 ? a19 : a19 + 2 * Math.PI;
		}
		var this31 = f19;
		var zb9 = this31;
		var fa9 = za9;
		var fb9 = zb9;
		var theta9 = Math.abs(pi_2);
		var clockwise9 = pi_2 < 0;
		var dif12 = clockwise9 ? theta9 : -theta9;
		dif10 = dif12 < 0 ? dif12 : -2 * Math.PI + dif12;
		break;
	case 2:
		var f20;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f20 = pi_2;
		} else {
			var a20 = pi_2 % (2 * Math.PI);
			f20 = a20 >= 0 ? a20 : a20 + 2 * Math.PI;
		}
		var this32 = f20;
		var za10 = this32;
		var f21;
		if(0 > Math.PI) {
			f21 = 0;
		} else {
			var a21 = 0 % (2 * Math.PI);
			f21 = a21 >= 0 ? a21 : a21 + 2 * Math.PI;
		}
		var this33 = f21;
		var zb10 = this33;
		var fa10 = pi_2;
		var fb10 = 0;
		var theta10 = Math.abs(pi_2);
		var smallest2 = theta10 <= Math.PI;
		var clockwise10 = pi_2 < 0;
		var dif13 = clockwise10 ? theta10 : -theta10;
		dif10 = smallest2 ? dif13 : clockwise10 ? -(2 * Math.PI - theta10) : 2 * Math.PI - theta10;
		break;
	case 3:
		var f22;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f22 = pi_2;
		} else {
			var a22 = pi_2 % (2 * Math.PI);
			f22 = a22 >= 0 ? a22 : a22 + 2 * Math.PI;
		}
		var this34 = f22;
		var za11 = this34;
		var f23;
		if(0 > Math.PI) {
			f23 = 0;
		} else {
			var a23 = 0 % (2 * Math.PI);
			f23 = a23 >= 0 ? a23 : a23 + 2 * Math.PI;
		}
		var this35 = f23;
		var zb11 = this35;
		var fa11 = pi_2;
		var fb11 = 0;
		var theta11 = Math.abs(pi_2);
		var largest2 = theta11 > Math.PI;
		var clockwise11 = pi_2 < 0;
		var dif14 = clockwise11 ? theta11 : -theta11;
		dif10 = largest2 ? dif14 : clockwise11 ? -(2 * Math.PI - theta11) : 2 * Math.PI - theta11;
		break;
	}
	var positive2 = dif10 >= 0;
	var totalSteps2 = Math.ceil(Math.abs(dif10) / step4);
	var step5 = dif10 / totalSteps2;
	var angle2 = pi_2;
	var cx7;
	var cy7;
	var bx7 = 0;
	var by7 = 0;
	var dx7 = 0;
	var dy7 = 0;
	var ex2 = 0;
	var ey2 = 0;
	var r22 = radius - thick;
	var _g5 = 0;
	var _g12 = totalSteps2 + 1;
	while(_g5 < _g12) {
		var i2 = _g5++;
		cx7 = cx + radius * Math.sin(angle2);
		cy7 = cy + radius * Math.cos(angle2);
		ex2 = cx + r22 * Math.sin(angle2);
		ey2 = cy + r22 * Math.cos(angle2);
		if(i2 != 0) {
			var t02 = new trilateral_tri_Trilateral(dx7,dy7,bx7,by7,cx7,cy7);
			var t13 = new trilateral_tri_Trilateral(dx7,dy7,cx7,cy7,ex2,ey2);
			out3[out3.length] = t02;
			out3[out3.length] = t13;
		}
		angle2 += step5;
		bx7 = cx7;
		by7 = cy7;
		dx7 = ex2;
		dy7 = ey2;
	}
	var triArr2 = out3;
	var _g6 = 0;
	while(_g6 < triArr2.length) {
		var t9 = triArr2[_g6];
		++_g6;
		out[out.length] = t9;
	}
	var gamma1 = -pi_2;
	var t10 = [];
	var this36;
	if(t10 == null) {
		var t14 = [];
		var this37 = t14 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t14;
		this36 = this37;
	} else {
		this36 = t10;
	}
	var this38 = this36;
	var out4 = this38;
	var pi4 = Math.PI;
	var step6 = pi4 * 2 / 36;
	var dif15;
	switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE._hx_index) {
	case 0:
		var f24;
		if(0 > Math.PI) {
			f24 = 0;
		} else {
			var a24 = 0 % (2 * Math.PI);
			f24 = a24 >= 0 ? a24 : a24 + 2 * Math.PI;
		}
		var this39 = f24;
		var za12 = this39;
		var f25;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f25 = gamma1;
		} else {
			var a25 = gamma1 % (2 * Math.PI);
			f25 = a25 >= 0 ? a25 : a25 + 2 * Math.PI;
		}
		var this40 = f25;
		var zb12 = this40;
		var fa12 = za12;
		var fb12 = zb12;
		var theta12 = Math.abs(0 - gamma1);
		var clockwise12 = 0 < gamma1;
		var dif16 = clockwise12 ? theta12 : -theta12;
		dif15 = dif16 > 0 ? dif16 : 2 * Math.PI + dif16;
		break;
	case 1:
		var f26;
		if(0 > Math.PI) {
			f26 = 0;
		} else {
			var a26 = 0 % (2 * Math.PI);
			f26 = a26 >= 0 ? a26 : a26 + 2 * Math.PI;
		}
		var this41 = f26;
		var za13 = this41;
		var f27;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f27 = gamma1;
		} else {
			var a27 = gamma1 % (2 * Math.PI);
			f27 = a27 >= 0 ? a27 : a27 + 2 * Math.PI;
		}
		var this42 = f27;
		var zb13 = this42;
		var fa13 = za13;
		var fb13 = zb13;
		var theta13 = Math.abs(0 - gamma1);
		var clockwise13 = 0 < gamma1;
		var dif17 = clockwise13 ? theta13 : -theta13;
		dif15 = dif17 < 0 ? dif17 : -2 * Math.PI + dif17;
		break;
	case 2:
		var f28;
		if(0 > Math.PI) {
			f28 = 0;
		} else {
			var a28 = 0 % (2 * Math.PI);
			f28 = a28 >= 0 ? a28 : a28 + 2 * Math.PI;
		}
		var this43 = f28;
		var za14 = this43;
		var f29;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f29 = gamma1;
		} else {
			var a29 = gamma1 % (2 * Math.PI);
			f29 = a29 >= 0 ? a29 : a29 + 2 * Math.PI;
		}
		var this44 = f29;
		var zb14 = this44;
		var fa14 = 0;
		var fb14 = gamma1;
		var theta14 = Math.abs(0 - gamma1);
		var smallest3 = theta14 <= Math.PI;
		var clockwise14 = 0 < gamma1;
		var dif18 = clockwise14 ? theta14 : -theta14;
		dif15 = smallest3 ? dif18 : clockwise14 ? -(2 * Math.PI - theta14) : 2 * Math.PI - theta14;
		break;
	case 3:
		var f30;
		if(0 > Math.PI) {
			f30 = 0;
		} else {
			var a30 = 0 % (2 * Math.PI);
			f30 = a30 >= 0 ? a30 : a30 + 2 * Math.PI;
		}
		var this45 = f30;
		var za15 = this45;
		var f31;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f31 = gamma1;
		} else {
			var a31 = gamma1 % (2 * Math.PI);
			f31 = a31 >= 0 ? a31 : a31 + 2 * Math.PI;
		}
		var this46 = f31;
		var zb15 = this46;
		var fa15 = 0;
		var fb15 = gamma1;
		var theta15 = Math.abs(0 - gamma1);
		var largest3 = theta15 > Math.PI;
		var clockwise15 = 0 < gamma1;
		var dif19 = clockwise15 ? theta15 : -theta15;
		dif15 = largest3 ? dif19 : clockwise15 ? -(2 * Math.PI - theta15) : 2 * Math.PI - theta15;
		break;
	}
	var positive3 = dif15 >= 0;
	var totalSteps3 = Math.ceil(Math.abs(dif15) / step6);
	var step7 = dif15 / totalSteps3;
	var angle3 = 0;
	var cx8;
	var cy8;
	var bx8 = 0;
	var by8 = 0;
	var dx8 = 0;
	var dy8 = 0;
	var ex3 = 0;
	var ey3 = 0;
	var r23 = radius - thick;
	var _g7 = 0;
	var _g13 = totalSteps3 + 1;
	while(_g7 < _g13) {
		var i3 = _g7++;
		cx8 = dx + radius * Math.sin(angle3);
		cy8 = dy + radius * Math.cos(angle3);
		ex3 = dx + r23 * Math.sin(angle3);
		ey3 = dy + r23 * Math.cos(angle3);
		if(i3 != 0) {
			var t03 = new trilateral_tri_Trilateral(dx8,dy8,bx8,by8,cx8,cy8);
			var t15 = new trilateral_tri_Trilateral(dx8,dy8,cx8,cy8,ex3,ey3);
			out4[out4.length] = t03;
			out4[out4.length] = t15;
		}
		angle3 += step7;
		bx8 = cx8;
		by8 = cy8;
		dx8 = ex3;
		dy8 = ey3;
	}
	var triArr3 = out4;
	var _g8 = 0;
	while(_g8 < triArr3.length) {
		var t16 = triArr3[_g8];
		++_g8;
		out[out.length] = t16;
	}
	return out;
};
var trilateral_polys_Shapes = function(triangleArray_,colors_) {
	this.refCount = 0;
	this.triangles = triangleArray_;
	this.colors = colors_;
};
trilateral_polys_Shapes.__name__ = true;
trilateral_polys_Shapes.prototype = {
	findShapeById: function(id) {
		var this1 = this.triangles;
		var t = [];
		var this2 = t == null ? trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new([]) : t;
		var this3 = this2;
		var out = this3;
		var _g = 0;
		var _g1 = this1.length;
		while(_g < _g1) {
			var i = _g++;
			if(this1[i].id == id) {
				out[out.length] = this1[i];
			}
		}
		return out;
	}
	,star: function(x,y,radius,color,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var pi = Math.PI;
		var omega = -pi + theta;
		var a0x = x + radius * Math.sin(omega);
		var a0y = y + radius * Math.cos(omega);
		omega += pi / 3;
		var a1x = x + radius * Math.sin(omega);
		var a1y = y + radius * Math.cos(omega);
		omega += pi / 3;
		var b0x = x + radius * Math.sin(omega);
		var b0y = y + radius * Math.cos(omega);
		omega += pi / 3;
		var b1x = x + radius * Math.sin(omega);
		var b1y = y + radius * Math.cos(omega);
		omega += pi / 3;
		var c0x = x + radius * Math.sin(omega);
		var c0y = y + radius * Math.cos(omega);
		omega += pi / 3;
		var c1x = x + radius * Math.sin(omega);
		var c1y = y + radius * Math.cos(omega);
		var tri_t0 = new trilateral_tri_Trilateral(a0x,a0y,b0x,b0y,c0x,c0y);
		var tri_t1 = new trilateral_tri_Trilateral(a1x,a1y,b1x,b1y,c1x,c1y);
		var tri = tri_t0;
		var t = Object.create(trilateral_tri_Triangle.prototype);
		t.id = id;
		t.ax = tri.ax;
		t.ay = tri.ay;
		t.bx = tri.bx;
		t.by = tri.by;
		t.cx = tri.cx;
		t.cy = tri.cy;
		t.mark = tri.mark;
		t.depth = 0;
		t.alpha = 1.;
		t.colorID = color;
		t.colorA = color;
		t.colorB = color;
		t.colorC = color;
		t.windingAdjusted = tri.windingAdjusted;
		var tri0 = t;
		this1[this1.length] = tri0;
		var tri1 = tri_t1;
		var t1 = Object.create(trilateral_tri_Triangle.prototype);
		t1.id = id;
		t1.ax = tri1.ax;
		t1.ay = tri1.ay;
		t1.bx = tri1.bx;
		t1.by = tri1.by;
		t1.cx = tri1.cx;
		t1.cy = tri1.cy;
		t1.mark = tri1.mark;
		t1.depth = 0;
		t1.alpha = 1.;
		t1.colorID = color;
		t1.colorA = color;
		t1.colorB = color;
		t1.colorC = color;
		t1.windingAdjusted = tri1.windingAdjusted;
		var tri11 = t1;
		this1[this1.length] = tri11;
		return this.refCount - 1;
	}
	,diamond: function(x,y,radius,color,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var theta1 = Math.PI / 4;
		var ax = 0.;
		var ay = 0.;
		var bx = 0.;
		var by = 0.;
		var cx = 0.;
		var cy = 0.;
		var dx = 0.;
		var dy = 0.;
		if(theta1 != 0) {
			var pi = Math.PI;
			var pi4 = pi / 4;
			var pi2 = pi / 2;
			var sqrt2 = Math.sqrt(2);
			var r = radius * sqrt2;
			var aTheta = -pi + theta1 - pi4;
			var dTheta = -pi + theta1 + pi / 2 - pi / 4;
			var cTheta = theta1 - pi4;
			var bTheta = -pi + theta1 - pi2 - pi4;
			ax = x + r * Math.sin(aTheta);
			ay = y + r * Math.cos(aTheta);
			bx = x + r * Math.sin(bTheta);
			by = y + r * Math.cos(bTheta);
			cx = x + r * Math.sin(cTheta);
			cy = y + r * Math.cos(cTheta);
			dx = x + r * Math.sin(dTheta);
			dy = y + r * Math.cos(dTheta);
		} else {
			ax = x - radius;
			ay = y - radius;
			var lx = radius * 2;
			var ly = lx;
			bx = ax + lx;
			by = ay;
			cx = bx;
			cy = ay + ly;
			dx = ax;
			dy = cy;
		}
		var tri_t0 = new trilateral_tri_Trilateral(ax,ay,bx,by,dx,dy);
		var tri_t1 = new trilateral_tri_Trilateral(bx,by,cx,cy,dx,dy);
		var tri = tri_t0;
		var t = Object.create(trilateral_tri_Triangle.prototype);
		t.id = id;
		t.ax = tri.ax;
		t.ay = tri.ay;
		t.bx = tri.bx;
		t.by = tri.by;
		t.cx = tri.cx;
		t.cy = tri.cy;
		t.mark = tri.mark;
		t.depth = 0;
		t.alpha = 1.;
		t.colorID = color;
		t.colorA = color;
		t.colorB = color;
		t.colorC = color;
		t.windingAdjusted = tri.windingAdjusted;
		var tri0 = t;
		this1[this1.length] = tri0;
		var tri1 = tri_t1;
		var t1 = Object.create(trilateral_tri_Triangle.prototype);
		t1.id = id;
		t1.ax = tri1.ax;
		t1.ay = tri1.ay;
		t1.bx = tri1.bx;
		t1.by = tri1.by;
		t1.cx = tri1.cx;
		t1.cy = tri1.cy;
		t1.mark = tri1.mark;
		t1.depth = 0;
		t1.alpha = 1.;
		t1.colorID = color;
		t1.colorA = color;
		t1.colorB = color;
		t1.colorC = color;
		t1.windingAdjusted = tri1.windingAdjusted;
		var tri11 = t1;
		this1[this1.length] = tri11;
		return this.refCount - 1;
	}
	,diamondOutline: function(x,y,radius,thick,color,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var theta1 = Math.PI / 4;
		var t = [];
		var this2;
		if(t == null) {
			var t1 = [];
			var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this2 = this3;
		} else {
			this2 = t;
		}
		var this4 = this2;
		var out = this4;
		var ax = 0.;
		var ay = 0.;
		var bx = 0.;
		var by = 0.;
		var cx = 0.;
		var cy = 0.;
		var dx = 0.;
		var dy = 0.;
		var a0x = 0.;
		var a0y = 0.;
		var b0x = 0.;
		var b0y = 0.;
		var c0x = 0.;
		var c0y = 0.;
		var d0x = 0.;
		var d0y = 0.;
		if(theta1 != 0) {
			var pi = Math.PI;
			var pi4 = pi / 4;
			var pi2 = pi / 2;
			var sqrt2 = Math.sqrt(2);
			var r = radius * sqrt2;
			var aTheta = -pi + theta1 - pi4;
			var dTheta = -pi + theta1 + pi / 2 - pi / 4;
			var cTheta = theta1 - pi4;
			var bTheta = -pi + theta1 - pi2 - pi4;
			var as = Math.sin(aTheta);
			var ac = Math.cos(aTheta);
			var bs = Math.sin(bTheta);
			var bc = Math.cos(bTheta);
			var cs = Math.sin(cTheta);
			var cc = Math.cos(cTheta);
			var ds = Math.sin(dTheta);
			var dc = Math.cos(dTheta);
			var r0 = r - thick;
			ax = x + r * as;
			ay = y + r * ac;
			bx = x + r * bs;
			by = y + r * bc;
			cx = x + r * cs;
			cy = y + r * cc;
			dx = x + r * ds;
			dy = y + r * dc;
			a0x = x + r0 * as;
			a0y = y + r0 * ac;
			b0x = x + r0 * bs;
			b0y = y + r0 * bc;
			c0x = x + r0 * cs;
			c0y = y + r0 * cc;
			d0x = x + r0 * ds;
			d0y = y + r0 * dc;
		} else {
			ax = x - radius;
			ay = y - radius;
			var lx = radius * 2;
			var ly = lx;
			bx = ax + lx;
			by = ay;
			cx = bx;
			cy = ay + ly;
			dx = ax;
			dy = cy;
			var radius0 = radius - thick;
			a0x = x - radius0;
			a0y = y - radius0;
			var l0x = radius0 * 2;
			var l0y = l0x;
			b0x = a0x + l0x;
			b0y = a0y;
			c0x = b0x;
			c0y = a0y + l0y;
			d0x = a0x;
			d0y = c0y;
		}
		var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,a0x,a0y);
		out[out.length] = tri;
		var tri1 = new trilateral_tri_Trilateral(bx,by,b0x,b0y,a0x,a0y);
		out[out.length] = tri1;
		var tri2 = new trilateral_tri_Trilateral(d0x,d0y,c0x,c0y,dx,dy);
		out[out.length] = tri2;
		var tri3 = new trilateral_tri_Trilateral(c0x,c0y,cx,cy,dx,dy);
		out[out.length] = tri3;
		var tri4 = new trilateral_tri_Trilateral(ax,ay,a0x,a0y,d0x,d0y);
		out[out.length] = tri4;
		var tri5 = new trilateral_tri_Trilateral(ax,ay,d0x,d0y,dx,dy);
		out[out.length] = tri5;
		var tri6 = new trilateral_tri_Trilateral(b0x,b0y,bx,by,c0x,c0y);
		out[out.length] = tri6;
		var tri7 = new trilateral_tri_Trilateral(bx,by,cx,cy,c0x,c0y);
		out[out.length] = tri7;
		var triArr = out;
		var tri8;
		var _g = 0;
		while(_g < triArr.length) {
			var t2 = triArr[_g];
			++_g;
			if(t2 != null) {
				var t3 = Object.create(trilateral_tri_Triangle.prototype);
				t3.id = id;
				t3.ax = t2.ax;
				t3.ay = t2.ay;
				t3.bx = t2.bx;
				t3.by = t2.by;
				t3.cx = t2.cx;
				t3.cy = t2.cy;
				t3.mark = t2.mark;
				t3.depth = 0;
				t3.alpha = 1.;
				t3.colorID = color;
				t3.colorA = color;
				t3.colorB = color;
				t3.colorC = color;
				t3.windingAdjusted = t2.windingAdjusted;
				tri8 = t3;
				this1[this1.length] = tri8;
			}
		}
		return this.refCount - 1;
	}
	,square: function(x,y,radius,color,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var ax = 0.;
		var ay = 0.;
		var bx = 0.;
		var by = 0.;
		var cx = 0.;
		var cy = 0.;
		var dx = 0.;
		var dy = 0.;
		ax = x - radius;
		ay = y - radius;
		var lx = radius * 2;
		var ly = lx;
		bx = ax + lx;
		by = ay;
		cx = bx;
		cy = ay + ly;
		dx = ax;
		dy = cy;
		var tri_t0 = new trilateral_tri_Trilateral(ax,ay,bx,by,dx,dy);
		var tri_t1 = new trilateral_tri_Trilateral(bx,by,cx,cy,dx,dy);
		var tri = tri_t0;
		var t = Object.create(trilateral_tri_Triangle.prototype);
		t.id = id;
		t.ax = tri.ax;
		t.ay = tri.ay;
		t.bx = tri.bx;
		t.by = tri.by;
		t.cx = tri.cx;
		t.cy = tri.cy;
		t.mark = tri.mark;
		t.depth = 0;
		t.alpha = 1.;
		t.colorID = color;
		t.colorA = color;
		t.colorB = color;
		t.colorC = color;
		t.windingAdjusted = tri.windingAdjusted;
		var tri0 = t;
		this1[this1.length] = tri0;
		var tri1 = tri_t1;
		var t1 = Object.create(trilateral_tri_Triangle.prototype);
		t1.id = id;
		t1.ax = tri1.ax;
		t1.ay = tri1.ay;
		t1.bx = tri1.bx;
		t1.by = tri1.by;
		t1.cx = tri1.cx;
		t1.cy = tri1.cy;
		t1.mark = tri1.mark;
		t1.depth = 0;
		t1.alpha = 1.;
		t1.colorID = color;
		t1.colorA = color;
		t1.colorB = color;
		t1.colorC = color;
		t1.windingAdjusted = tri1.windingAdjusted;
		var tri11 = t1;
		this1[this1.length] = tri11;
		return this.refCount - 1;
	}
	,squareOutline: function(x,y,radius,thick,color,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var t = [];
		var this2;
		if(t == null) {
			var t1 = [];
			var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this2 = this3;
		} else {
			this2 = t;
		}
		var this4 = this2;
		var out = this4;
		var ax = 0.;
		var ay = 0.;
		var bx = 0.;
		var by = 0.;
		var cx = 0.;
		var cy = 0.;
		var dx = 0.;
		var dy = 0.;
		var a0x = 0.;
		var a0y = 0.;
		var b0x = 0.;
		var b0y = 0.;
		var c0x = 0.;
		var c0y = 0.;
		var d0x = 0.;
		var d0y = 0.;
		ax = x - radius;
		ay = y - radius;
		var lx = radius * 2;
		var ly = lx;
		bx = ax + lx;
		by = ay;
		cx = bx;
		cy = ay + ly;
		dx = ax;
		dy = cy;
		var radius0 = radius - thick;
		a0x = x - radius0;
		a0y = y - radius0;
		var l0x = radius0 * 2;
		var l0y = l0x;
		b0x = a0x + l0x;
		b0y = a0y;
		c0x = b0x;
		c0y = a0y + l0y;
		d0x = a0x;
		d0y = c0y;
		var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,a0x,a0y);
		out[out.length] = tri;
		var tri1 = new trilateral_tri_Trilateral(bx,by,b0x,b0y,a0x,a0y);
		out[out.length] = tri1;
		var tri2 = new trilateral_tri_Trilateral(d0x,d0y,c0x,c0y,dx,dy);
		out[out.length] = tri2;
		var tri3 = new trilateral_tri_Trilateral(c0x,c0y,cx,cy,dx,dy);
		out[out.length] = tri3;
		var tri4 = new trilateral_tri_Trilateral(ax,ay,a0x,a0y,d0x,d0y);
		out[out.length] = tri4;
		var tri5 = new trilateral_tri_Trilateral(ax,ay,d0x,d0y,dx,dy);
		out[out.length] = tri5;
		var tri6 = new trilateral_tri_Trilateral(b0x,b0y,bx,by,c0x,c0y);
		out[out.length] = tri6;
		var tri7 = new trilateral_tri_Trilateral(bx,by,cx,cy,c0x,c0y);
		out[out.length] = tri7;
		var triArr = out;
		var tri8;
		var _g = 0;
		while(_g < triArr.length) {
			var t2 = triArr[_g];
			++_g;
			if(t2 != null) {
				var t3 = Object.create(trilateral_tri_Triangle.prototype);
				t3.id = id;
				t3.ax = t2.ax;
				t3.ay = t2.ay;
				t3.bx = t2.bx;
				t3.by = t2.by;
				t3.cx = t2.cx;
				t3.cy = t2.cy;
				t3.mark = t2.mark;
				t3.depth = 0;
				t3.alpha = 1.;
				t3.colorID = color;
				t3.colorA = color;
				t3.colorB = color;
				t3.colorC = color;
				t3.windingAdjusted = t2.windingAdjusted;
				tri8 = t3;
				this1[this1.length] = tri8;
			}
		}
		return this.refCount - 1;
	}
	,rectangle: function(x,y,width,height,color) {
		var this1 = this.triangles;
		var id = this.refCount++;
		var ax = x;
		var ay = y;
		var bx = x + width;
		var by = ay;
		var cx = bx;
		var cy = ay + height;
		var dx = x;
		var dy = cy;
		var tri_t0 = new trilateral_tri_Trilateral(ax,ay,bx,by,dx,dy);
		var tri_t1 = new trilateral_tri_Trilateral(bx,by,cx,cy,dx,dy);
		var tri = tri_t0;
		var t = Object.create(trilateral_tri_Triangle.prototype);
		t.id = id;
		t.ax = tri.ax;
		t.ay = tri.ay;
		t.bx = tri.bx;
		t.by = tri.by;
		t.cx = tri.cx;
		t.cy = tri.cy;
		t.mark = tri.mark;
		t.depth = 0;
		t.alpha = 1.;
		t.colorID = color;
		t.colorA = color;
		t.colorB = color;
		t.colorC = color;
		t.windingAdjusted = tri.windingAdjusted;
		var tri0 = t;
		this1[this1.length] = tri0;
		var tri1 = tri_t1;
		var t1 = Object.create(trilateral_tri_Triangle.prototype);
		t1.id = id;
		t1.ax = tri1.ax;
		t1.ay = tri1.ay;
		t1.bx = tri1.bx;
		t1.by = tri1.by;
		t1.cx = tri1.cx;
		t1.cy = tri1.cy;
		t1.mark = tri1.mark;
		t1.depth = 0;
		t1.alpha = 1.;
		t1.colorID = color;
		t1.colorA = color;
		t1.colorB = color;
		t1.colorC = color;
		t1.windingAdjusted = tri1.windingAdjusted;
		var tri11 = t1;
		this1[this1.length] = tri11;
		return this.refCount - 1;
	}
	,circle: function(x,y,radius,color,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var t = [];
		var this2;
		if(t == null) {
			var t1 = [];
			var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this2 = this3;
		} else {
			this2 = t;
		}
		var this4 = this2;
		var out = this4;
		var pi = Math.PI;
		var theta1 = pi / 2;
		var step = pi * 2 / 36;
		var bx;
		var by;
		var cx;
		var cy;
		var _g = 0;
		var _g1 = 36;
		while(_g < _g1) {
			var i = _g++;
			bx = x + radius * Math.sin(theta1);
			by = y + radius * Math.cos(theta1);
			theta1 += step;
			cx = x + radius * Math.sin(theta1);
			cy = y + radius * Math.cos(theta1);
			var tri = new trilateral_tri_Trilateral(x,y,bx,by,cx,cy);
			out[out.length] = tri;
		}
		var triArr = out;
		var tri1;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t2 = triArr[_g2];
			++_g2;
			if(t2 != null) {
				var t3 = Object.create(trilateral_tri_Triangle.prototype);
				t3.id = id;
				t3.ax = t2.ax;
				t3.ay = t2.ay;
				t3.bx = t2.bx;
				t3.by = t2.by;
				t3.cx = t2.cx;
				t3.cy = t2.cy;
				t3.mark = t2.mark;
				t3.depth = 0;
				t3.alpha = 1.;
				t3.colorID = color;
				t3.colorA = color;
				t3.colorB = color;
				t3.colorC = color;
				t3.windingAdjusted = t2.windingAdjusted;
				tri1 = t3;
				this1[this1.length] = tri1;
			}
		}
		return this.refCount - 1;
	}
	,shape: function(x,y,radius,color,sides,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var triArr;
		if((sides & 1) == 0) {
			var t = [];
			var this2;
			if(t == null) {
				var t1 = [];
				var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
				this2 = this3;
			} else {
				this2 = t;
			}
			var this4 = this2;
			var out = this4;
			var pi = Math.PI;
			var theta1 = pi / 2;
			var step = pi * 2 / sides;
			theta1 -= step / 2 + theta;
			var bx;
			var by;
			var cx;
			var cy;
			var _g = 0;
			var _g1 = sides;
			while(_g < _g1) {
				var i = _g++;
				bx = x + radius * Math.sin(theta1);
				by = y + radius * Math.cos(theta1);
				theta1 += step;
				cx = x + radius * Math.sin(theta1);
				cy = y + radius * Math.cos(theta1);
				var tri = new trilateral_tri_Trilateral(x,y,bx,by,cx,cy);
				out[out.length] = tri;
			}
			triArr = out;
		} else {
			var t2 = [];
			var this5;
			if(t2 == null) {
				var t3 = [];
				var this6 = t3 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t3;
				this5 = this6;
			} else {
				this5 = t2;
			}
			var this7 = this5;
			var out1 = this7;
			var pi1 = Math.PI;
			var theta2 = pi1 / 2 + theta;
			var step1 = pi1 * 2 / sides;
			var bx1;
			var by1;
			var cx1;
			var cy1;
			var _g2 = 0;
			var _g11 = sides;
			while(_g2 < _g11) {
				var i1 = _g2++;
				bx1 = x + radius * Math.sin(theta2);
				by1 = y + radius * Math.cos(theta2);
				theta2 += step1;
				cx1 = x + radius * Math.sin(theta2);
				cy1 = y + radius * Math.cos(theta2);
				var tri1 = new trilateral_tri_Trilateral(x,y,bx1,by1,cx1,cy1);
				out1[out1.length] = tri1;
			}
			triArr = out1;
		}
		var tri2;
		var _g3 = 0;
		while(_g3 < triArr.length) {
			var t4 = triArr[_g3];
			++_g3;
			if(t4 != null) {
				var t5 = Object.create(trilateral_tri_Triangle.prototype);
				t5.id = id;
				t5.ax = t4.ax;
				t5.ay = t4.ay;
				t5.bx = t4.bx;
				t5.by = t4.by;
				t5.cx = t4.cx;
				t5.cy = t4.cy;
				t5.mark = t4.mark;
				t5.depth = 0;
				t5.alpha = 1.;
				t5.colorID = color;
				t5.colorA = color;
				t5.colorB = color;
				t5.colorC = color;
				t5.windingAdjusted = t4.windingAdjusted;
				tri2 = t5;
				this1[this1.length] = tri2;
			}
		}
		return this.refCount - 1;
	}
	,ellipse: function(x,y,rx,ry,color,sides,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var t = [];
		var this2;
		if(t == null) {
			var t1 = [];
			var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this2 = this3;
		} else {
			this2 = t;
		}
		var this4 = this2;
		var out = this4;
		var pi = Math.PI;
		var theta1 = pi / 2;
		var step = pi * 2 / sides;
		var bx;
		var by;
		var cx;
		var cy;
		var _g = 0;
		var _g1 = sides;
		while(_g < _g1) {
			var i = _g++;
			bx = x + rx * Math.sin(theta1);
			by = y + ry * Math.cos(theta1);
			theta1 += step;
			cx = x + rx * Math.sin(theta1);
			cy = y + ry * Math.cos(theta1);
			var tri = new trilateral_tri_Trilateral(x,y,bx,by,cx,cy);
			out[out.length] = tri;
		}
		var triArr = out;
		var tri1;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t2 = triArr[_g2];
			++_g2;
			if(t2 != null) {
				var t3 = Object.create(trilateral_tri_Triangle.prototype);
				t3.id = id;
				t3.ax = t2.ax;
				t3.ay = t2.ay;
				t3.bx = t2.bx;
				t3.by = t2.by;
				t3.cx = t2.cx;
				t3.cy = t2.cy;
				t3.mark = t2.mark;
				t3.depth = 0;
				t3.alpha = 1.;
				t3.colorID = color;
				t3.colorA = color;
				t3.colorB = color;
				t3.colorC = color;
				t3.windingAdjusted = t2.windingAdjusted;
				tri1 = t3;
				this1[this1.length] = tri1;
			}
		}
		return this.refCount - 1;
	}
	,roundedRectangle: function(x,y,width,height,radius,color) {
		var this1 = this.triangles;
		var id = this.refCount++;
		var t = [];
		var this2;
		if(t == null) {
			var t1 = [];
			var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this2 = this3;
		} else {
			this2 = t;
		}
		var this4 = this2;
		var out = this4;
		var pi = Math.PI;
		var pi_2 = Math.PI / 2;
		var ax = x + radius;
		var ay = y + radius;
		var bx = x + width - radius;
		var by = y + radius;
		var cx = bx;
		var cy = y + height - radius;
		var dx = ax;
		var dy = cy;
		var ax1 = ax;
		var ay1 = y;
		var bx1 = ax + (width - radius * 2);
		var by1 = ay1;
		var cx1 = bx1;
		var cy1 = ay1 + height;
		var dx1 = ax;
		var dy1 = cy1;
		var tp_t0 = new trilateral_tri_Trilateral(ax1,ay1,bx1,by1,dx1,dy1);
		var tp_t1 = new trilateral_tri_Trilateral(bx1,by1,cx1,cy1,dx1,dy1);
		out[out.length] = tp_t0;
		out[out.length] = tp_t1;
		var dimY = height - 2 * radius;
		var ax2 = x;
		var ay2 = ay;
		var bx2 = x + radius;
		var by2 = ay2;
		var cx2 = bx2;
		var cy2 = ay2 + dimY;
		var dx2 = x;
		var dy2 = cy2;
		var tp_t01 = new trilateral_tri_Trilateral(ax2,ay2,bx2,by2,dx2,dy2);
		var tp_t11 = new trilateral_tri_Trilateral(bx2,by2,cx2,cy2,dx2,dy2);
		out[out.length] = tp_t01;
		out[out.length] = tp_t11;
		var ax3 = bx;
		var ay3 = by;
		var bx3 = bx + radius;
		var by3 = ay3;
		var cx3 = bx3;
		var cy3 = ay3 + dimY;
		var dx3 = bx;
		var dy3 = cy3;
		var tp_t02 = new trilateral_tri_Trilateral(ax3,ay3,bx3,by3,dx3,dy3);
		var tp_t12 = new trilateral_tri_Trilateral(bx3,by3,cx3,cy3,dx3,dy3);
		out[out.length] = tp_t02;
		out[out.length] = tp_t12;
		var beta = -pi;
		var gamma = -pi_2;
		var t2 = [];
		var this5;
		if(t2 == null) {
			var t3 = [];
			var this6;
			if(t3 == null) {
				var t4 = [];
				var this7 = t4 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t4;
				this6 = this7;
			} else {
				this6 = t3;
			}
			this5 = this6;
		} else {
			this5 = t2;
		}
		var this8 = this5;
		var out1 = this8;
		var pi1 = Math.PI;
		var step = pi1 * 2 / 36;
		var dif;
		switch(trilateral_angle_DifferencePreference.CLOCKWISE._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this9 = f;
			var za = this9;
			var f1;
			if(gamma >= 0 && gamma > Math.PI) {
				f1 = gamma;
			} else {
				var a1 = gamma % (2 * Math.PI);
				f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
			}
			var this10 = f1;
			var zb = this10;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(beta - gamma);
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f2;
			if(beta >= 0 && beta > Math.PI) {
				f2 = beta;
			} else {
				var a2 = beta % (2 * Math.PI);
				f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
			}
			var this11 = f2;
			var za1 = this11;
			var f3;
			if(gamma >= 0 && gamma > Math.PI) {
				f3 = gamma;
			} else {
				var a3 = gamma % (2 * Math.PI);
				f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
			}
			var this12 = f3;
			var zb1 = this12;
			var fa1 = za1;
			var fb1 = zb1;
			var theta1 = Math.abs(beta - gamma);
			var clockwise1 = beta < gamma;
			var dif2 = clockwise1 ? theta1 : -theta1;
			dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
			break;
		case 2:
			var f4;
			if(beta >= 0 && beta > Math.PI) {
				f4 = beta;
			} else {
				var a4 = beta % (2 * Math.PI);
				f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
			}
			var this13 = f4;
			var za2 = this13;
			var f5;
			if(gamma >= 0 && gamma > Math.PI) {
				f5 = gamma;
			} else {
				var a5 = gamma % (2 * Math.PI);
				f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
			}
			var this14 = f5;
			var zb2 = this14;
			var fa2 = beta;
			var fb2 = gamma;
			var theta2 = Math.abs(beta - gamma);
			var smallest = theta2 <= Math.PI;
			var clockwise2 = beta < gamma;
			var dif3 = clockwise2 ? theta2 : -theta2;
			dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
			break;
		case 3:
			var f6;
			if(beta >= 0 && beta > Math.PI) {
				f6 = beta;
			} else {
				var a6 = beta % (2 * Math.PI);
				f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
			}
			var this15 = f6;
			var za3 = this15;
			var f7;
			if(gamma >= 0 && gamma > Math.PI) {
				f7 = gamma;
			} else {
				var a7 = gamma % (2 * Math.PI);
				f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
			}
			var this16 = f7;
			var zb3 = this16;
			var fa3 = beta;
			var fb3 = gamma;
			var theta3 = Math.abs(beta - gamma);
			var largest = theta3 > Math.PI;
			var clockwise3 = beta < gamma;
			var dif4 = clockwise3 ? theta3 : -theta3;
			dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step1 = dif / totalSteps;
		var angle = beta;
		var cx4;
		var cy4;
		var bx4 = 0;
		var by4 = 0;
		var _g = 0;
		var _g1 = totalSteps + 1;
		while(_g < _g1) {
			var i = _g++;
			cx4 = ax + radius * Math.sin(angle);
			cy4 = ay + radius * Math.cos(angle);
			if(i != 0) {
				var t5 = new trilateral_tri_Trilateral(ax,ay,bx4,by4,cx4,cy4);
				out1[out1.length] = t5;
			}
			angle += step1;
			bx4 = cx4;
			by4 = cy4;
		}
		var triArr = out1;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t6 = triArr[_g2];
			++_g2;
			out[out.length] = t6;
		}
		var t7 = [];
		var this17;
		if(t7 == null) {
			var t8 = [];
			var this18;
			if(t8 == null) {
				var t9 = [];
				var this19 = t9 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t9;
				this18 = this19;
			} else {
				this18 = t8;
			}
			this17 = this18;
		} else {
			this17 = t7;
		}
		var this20 = this17;
		var out2 = this20;
		var pi2 = Math.PI;
		var step2 = pi2 * 2 / 36;
		var dif5;
		switch(trilateral_angle_DifferencePreference.CLOCKWISE._hx_index) {
		case 0:
			var f8;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f8 = pi_2;
			} else {
				var a8 = pi_2 % (2 * Math.PI);
				f8 = a8 >= 0 ? a8 : a8 + 2 * Math.PI;
			}
			var this21 = f8;
			var za4 = this21;
			var f9;
			if(pi >= 0 && pi > Math.PI) {
				f9 = pi;
			} else {
				var a9 = pi % (2 * Math.PI);
				f9 = a9 >= 0 ? a9 : a9 + 2 * Math.PI;
			}
			var this22 = f9;
			var zb4 = this22;
			var fa4 = za4;
			var fb4 = zb4;
			var theta4 = Math.abs(pi_2 - pi);
			var clockwise4 = pi_2 < pi;
			var dif6 = clockwise4 ? theta4 : -theta4;
			dif5 = dif6 > 0 ? dif6 : 2 * Math.PI + dif6;
			break;
		case 1:
			var f10;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f10 = pi_2;
			} else {
				var a10 = pi_2 % (2 * Math.PI);
				f10 = a10 >= 0 ? a10 : a10 + 2 * Math.PI;
			}
			var this23 = f10;
			var za5 = this23;
			var f11;
			if(pi >= 0 && pi > Math.PI) {
				f11 = pi;
			} else {
				var a11 = pi % (2 * Math.PI);
				f11 = a11 >= 0 ? a11 : a11 + 2 * Math.PI;
			}
			var this24 = f11;
			var zb5 = this24;
			var fa5 = za5;
			var fb5 = zb5;
			var theta5 = Math.abs(pi_2 - pi);
			var clockwise5 = pi_2 < pi;
			var dif7 = clockwise5 ? theta5 : -theta5;
			dif5 = dif7 < 0 ? dif7 : -2 * Math.PI + dif7;
			break;
		case 2:
			var f12;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f12 = pi_2;
			} else {
				var a12 = pi_2 % (2 * Math.PI);
				f12 = a12 >= 0 ? a12 : a12 + 2 * Math.PI;
			}
			var this25 = f12;
			var za6 = this25;
			var f13;
			if(pi >= 0 && pi > Math.PI) {
				f13 = pi;
			} else {
				var a13 = pi % (2 * Math.PI);
				f13 = a13 >= 0 ? a13 : a13 + 2 * Math.PI;
			}
			var this26 = f13;
			var zb6 = this26;
			var fa6 = pi_2;
			var fb6 = pi;
			var theta6 = Math.abs(pi_2 - pi);
			var smallest1 = theta6 <= Math.PI;
			var clockwise6 = pi_2 < pi;
			var dif8 = clockwise6 ? theta6 : -theta6;
			dif5 = smallest1 ? dif8 : clockwise6 ? -(2 * Math.PI - theta6) : 2 * Math.PI - theta6;
			break;
		case 3:
			var f14;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f14 = pi_2;
			} else {
				var a14 = pi_2 % (2 * Math.PI);
				f14 = a14 >= 0 ? a14 : a14 + 2 * Math.PI;
			}
			var this27 = f14;
			var za7 = this27;
			var f15;
			if(pi >= 0 && pi > Math.PI) {
				f15 = pi;
			} else {
				var a15 = pi % (2 * Math.PI);
				f15 = a15 >= 0 ? a15 : a15 + 2 * Math.PI;
			}
			var this28 = f15;
			var zb7 = this28;
			var fa7 = pi_2;
			var fb7 = pi;
			var theta7 = Math.abs(pi_2 - pi);
			var largest1 = theta7 > Math.PI;
			var clockwise7 = pi_2 < pi;
			var dif9 = clockwise7 ? theta7 : -theta7;
			dif5 = largest1 ? dif9 : clockwise7 ? -(2 * Math.PI - theta7) : 2 * Math.PI - theta7;
			break;
		}
		var positive1 = dif5 >= 0;
		var totalSteps1 = Math.ceil(Math.abs(dif5) / step2);
		var step3 = dif5 / totalSteps1;
		var angle1 = pi_2;
		var cx5;
		var cy5;
		var bx5 = 0;
		var by5 = 0;
		var _g3 = 0;
		var _g11 = totalSteps1 + 1;
		while(_g3 < _g11) {
			var i1 = _g3++;
			cx5 = bx + radius * Math.sin(angle1);
			cy5 = by + radius * Math.cos(angle1);
			if(i1 != 0) {
				var t10 = new trilateral_tri_Trilateral(bx,by,bx5,by5,cx5,cy5);
				out2[out2.length] = t10;
			}
			angle1 += step3;
			bx5 = cx5;
			by5 = cy5;
		}
		var triArr1 = out2;
		var _g4 = 0;
		while(_g4 < triArr1.length) {
			var t11 = triArr1[_g4];
			++_g4;
			out[out.length] = t11;
		}
		var t12 = [];
		var this29;
		if(t12 == null) {
			var t13 = [];
			var this30;
			if(t13 == null) {
				var t14 = [];
				var this31 = t14 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t14;
				this30 = this31;
			} else {
				this30 = t13;
			}
			this29 = this30;
		} else {
			this29 = t12;
		}
		var this32 = this29;
		var out3 = this32;
		var pi3 = Math.PI;
		var step4 = pi3 * 2 / 36;
		var dif10;
		switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE._hx_index) {
		case 0:
			var f16;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f16 = pi_2;
			} else {
				var a16 = pi_2 % (2 * Math.PI);
				f16 = a16 >= 0 ? a16 : a16 + 2 * Math.PI;
			}
			var this33 = f16;
			var za8 = this33;
			var f17;
			if(0 > Math.PI) {
				f17 = 0;
			} else {
				var a17 = 0 % (2 * Math.PI);
				f17 = a17 >= 0 ? a17 : a17 + 2 * Math.PI;
			}
			var this34 = f17;
			var zb8 = this34;
			var fa8 = za8;
			var fb8 = zb8;
			var theta8 = Math.abs(pi_2);
			var clockwise8 = pi_2 < 0;
			var dif11 = clockwise8 ? theta8 : -theta8;
			dif10 = dif11 > 0 ? dif11 : 2 * Math.PI + dif11;
			break;
		case 1:
			var f18;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f18 = pi_2;
			} else {
				var a18 = pi_2 % (2 * Math.PI);
				f18 = a18 >= 0 ? a18 : a18 + 2 * Math.PI;
			}
			var this35 = f18;
			var za9 = this35;
			var f19;
			if(0 > Math.PI) {
				f19 = 0;
			} else {
				var a19 = 0 % (2 * Math.PI);
				f19 = a19 >= 0 ? a19 : a19 + 2 * Math.PI;
			}
			var this36 = f19;
			var zb9 = this36;
			var fa9 = za9;
			var fb9 = zb9;
			var theta9 = Math.abs(pi_2);
			var clockwise9 = pi_2 < 0;
			var dif12 = clockwise9 ? theta9 : -theta9;
			dif10 = dif12 < 0 ? dif12 : -2 * Math.PI + dif12;
			break;
		case 2:
			var f20;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f20 = pi_2;
			} else {
				var a20 = pi_2 % (2 * Math.PI);
				f20 = a20 >= 0 ? a20 : a20 + 2 * Math.PI;
			}
			var this37 = f20;
			var za10 = this37;
			var f21;
			if(0 > Math.PI) {
				f21 = 0;
			} else {
				var a21 = 0 % (2 * Math.PI);
				f21 = a21 >= 0 ? a21 : a21 + 2 * Math.PI;
			}
			var this38 = f21;
			var zb10 = this38;
			var fa10 = pi_2;
			var fb10 = 0;
			var theta10 = Math.abs(pi_2);
			var smallest2 = theta10 <= Math.PI;
			var clockwise10 = pi_2 < 0;
			var dif13 = clockwise10 ? theta10 : -theta10;
			dif10 = smallest2 ? dif13 : clockwise10 ? -(2 * Math.PI - theta10) : 2 * Math.PI - theta10;
			break;
		case 3:
			var f22;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f22 = pi_2;
			} else {
				var a22 = pi_2 % (2 * Math.PI);
				f22 = a22 >= 0 ? a22 : a22 + 2 * Math.PI;
			}
			var this39 = f22;
			var za11 = this39;
			var f23;
			if(0 > Math.PI) {
				f23 = 0;
			} else {
				var a23 = 0 % (2 * Math.PI);
				f23 = a23 >= 0 ? a23 : a23 + 2 * Math.PI;
			}
			var this40 = f23;
			var zb11 = this40;
			var fa11 = pi_2;
			var fb11 = 0;
			var theta11 = Math.abs(pi_2);
			var largest2 = theta11 > Math.PI;
			var clockwise11 = pi_2 < 0;
			var dif14 = clockwise11 ? theta11 : -theta11;
			dif10 = largest2 ? dif14 : clockwise11 ? -(2 * Math.PI - theta11) : 2 * Math.PI - theta11;
			break;
		}
		var positive2 = dif10 >= 0;
		var totalSteps2 = Math.ceil(Math.abs(dif10) / step4);
		var step5 = dif10 / totalSteps2;
		var angle2 = pi_2;
		var cx6;
		var cy6;
		var bx6 = 0;
		var by6 = 0;
		var _g5 = 0;
		var _g12 = totalSteps2 + 1;
		while(_g5 < _g12) {
			var i2 = _g5++;
			cx6 = cx + radius * Math.sin(angle2);
			cy6 = cy + radius * Math.cos(angle2);
			if(i2 != 0) {
				var t15 = new trilateral_tri_Trilateral(cx,cy,bx6,by6,cx6,cy6);
				out3[out3.length] = t15;
			}
			angle2 += step5;
			bx6 = cx6;
			by6 = cy6;
		}
		var triArr2 = out3;
		var _g6 = 0;
		while(_g6 < triArr2.length) {
			var t16 = triArr2[_g6];
			++_g6;
			out[out.length] = t16;
		}
		var gamma1 = -pi_2;
		var t17 = [];
		var this41;
		if(t17 == null) {
			var t18 = [];
			var this42;
			if(t18 == null) {
				var t19 = [];
				var this43 = t19 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t19;
				this42 = this43;
			} else {
				this42 = t18;
			}
			this41 = this42;
		} else {
			this41 = t17;
		}
		var this44 = this41;
		var out4 = this44;
		var pi4 = Math.PI;
		var step6 = pi4 * 2 / 36;
		var dif15;
		switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE._hx_index) {
		case 0:
			var f24;
			if(0 > Math.PI) {
				f24 = 0;
			} else {
				var a24 = 0 % (2 * Math.PI);
				f24 = a24 >= 0 ? a24 : a24 + 2 * Math.PI;
			}
			var this45 = f24;
			var za12 = this45;
			var f25;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f25 = gamma1;
			} else {
				var a25 = gamma1 % (2 * Math.PI);
				f25 = a25 >= 0 ? a25 : a25 + 2 * Math.PI;
			}
			var this46 = f25;
			var zb12 = this46;
			var fa12 = za12;
			var fb12 = zb12;
			var theta12 = Math.abs(0 - gamma1);
			var clockwise12 = 0 < gamma1;
			var dif16 = clockwise12 ? theta12 : -theta12;
			dif15 = dif16 > 0 ? dif16 : 2 * Math.PI + dif16;
			break;
		case 1:
			var f26;
			if(0 > Math.PI) {
				f26 = 0;
			} else {
				var a26 = 0 % (2 * Math.PI);
				f26 = a26 >= 0 ? a26 : a26 + 2 * Math.PI;
			}
			var this47 = f26;
			var za13 = this47;
			var f27;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f27 = gamma1;
			} else {
				var a27 = gamma1 % (2 * Math.PI);
				f27 = a27 >= 0 ? a27 : a27 + 2 * Math.PI;
			}
			var this48 = f27;
			var zb13 = this48;
			var fa13 = za13;
			var fb13 = zb13;
			var theta13 = Math.abs(0 - gamma1);
			var clockwise13 = 0 < gamma1;
			var dif17 = clockwise13 ? theta13 : -theta13;
			dif15 = dif17 < 0 ? dif17 : -2 * Math.PI + dif17;
			break;
		case 2:
			var f28;
			if(0 > Math.PI) {
				f28 = 0;
			} else {
				var a28 = 0 % (2 * Math.PI);
				f28 = a28 >= 0 ? a28 : a28 + 2 * Math.PI;
			}
			var this49 = f28;
			var za14 = this49;
			var f29;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f29 = gamma1;
			} else {
				var a29 = gamma1 % (2 * Math.PI);
				f29 = a29 >= 0 ? a29 : a29 + 2 * Math.PI;
			}
			var this50 = f29;
			var zb14 = this50;
			var fa14 = 0;
			var fb14 = gamma1;
			var theta14 = Math.abs(0 - gamma1);
			var smallest3 = theta14 <= Math.PI;
			var clockwise14 = 0 < gamma1;
			var dif18 = clockwise14 ? theta14 : -theta14;
			dif15 = smallest3 ? dif18 : clockwise14 ? -(2 * Math.PI - theta14) : 2 * Math.PI - theta14;
			break;
		case 3:
			var f30;
			if(0 > Math.PI) {
				f30 = 0;
			} else {
				var a30 = 0 % (2 * Math.PI);
				f30 = a30 >= 0 ? a30 : a30 + 2 * Math.PI;
			}
			var this51 = f30;
			var za15 = this51;
			var f31;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f31 = gamma1;
			} else {
				var a31 = gamma1 % (2 * Math.PI);
				f31 = a31 >= 0 ? a31 : a31 + 2 * Math.PI;
			}
			var this52 = f31;
			var zb15 = this52;
			var fa15 = 0;
			var fb15 = gamma1;
			var theta15 = Math.abs(0 - gamma1);
			var largest3 = theta15 > Math.PI;
			var clockwise15 = 0 < gamma1;
			var dif19 = clockwise15 ? theta15 : -theta15;
			dif15 = largest3 ? dif19 : clockwise15 ? -(2 * Math.PI - theta15) : 2 * Math.PI - theta15;
			break;
		}
		var positive3 = dif15 >= 0;
		var totalSteps3 = Math.ceil(Math.abs(dif15) / step6);
		var step7 = dif15 / totalSteps3;
		var angle3 = 0;
		var cx7;
		var cy7;
		var bx7 = 0;
		var by7 = 0;
		var _g7 = 0;
		var _g13 = totalSteps3 + 1;
		while(_g7 < _g13) {
			var i3 = _g7++;
			cx7 = dx + radius * Math.sin(angle3);
			cy7 = dy + radius * Math.cos(angle3);
			if(i3 != 0) {
				var t20 = new trilateral_tri_Trilateral(dx,dy,bx7,by7,cx7,cy7);
				out4[out4.length] = t20;
			}
			angle3 += step7;
			bx7 = cx7;
			by7 = cy7;
		}
		var triArr3 = out4;
		var _g8 = 0;
		while(_g8 < triArr3.length) {
			var t21 = triArr3[_g8];
			++_g8;
			out[out.length] = t21;
		}
		var triArr4 = out;
		var tri;
		var _g9 = 0;
		while(_g9 < triArr4.length) {
			var t22 = triArr4[_g9];
			++_g9;
			if(t22 != null) {
				var t23 = Object.create(trilateral_tri_Triangle.prototype);
				t23.id = id;
				t23.ax = t22.ax;
				t23.ay = t22.ay;
				t23.bx = t22.bx;
				t23.by = t22.by;
				t23.cx = t22.cx;
				t23.cy = t22.cy;
				t23.mark = t22.mark;
				t23.depth = 0;
				t23.alpha = 1.;
				t23.colorID = color;
				t23.colorA = color;
				t23.colorB = color;
				t23.colorC = color;
				t23.windingAdjusted = t22.windingAdjusted;
				tri = t23;
				this1[this1.length] = tri;
			}
		}
		return this.refCount - 1;
	}
	,roundedRectangleOutline: function(x,y,width,height,thick,radius,color) {
		var this1 = this.triangles;
		var id = this.refCount++;
		var t = [];
		var this2;
		if(t == null) {
			var t1 = [];
			var this3 = t1 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t1;
			this2 = this3;
		} else {
			this2 = t;
		}
		var this4 = this2;
		var out = this4;
		var pi = Math.PI;
		var pi_2 = Math.PI / 2;
		var ax = x + radius;
		var ay = y + radius;
		var bx = x + width - radius;
		var by = y + radius;
		var cx = bx;
		var cy = y + height - radius;
		var dx = ax;
		var dy = cy;
		var ax1 = ax;
		var ay1 = y;
		var bx1 = ax + (width - radius * 2);
		var by1 = ay1;
		var cx1 = bx1;
		var cy1 = ay1 + thick;
		var dx1 = ax;
		var dy1 = cy1;
		var tp_t0 = new trilateral_tri_Trilateral(ax1,ay1,bx1,by1,dx1,dy1);
		var tp_t1 = new trilateral_tri_Trilateral(bx1,by1,cx1,cy1,dx1,dy1);
		out[out.length] = tp_t0;
		out[out.length] = tp_t1;
		var ax2 = ax;
		var ay2 = y + height - thick;
		var bx2 = ax + (width - radius * 2);
		var by2 = ay2;
		var cx2 = bx2;
		var cy2 = ay2 + thick;
		var dx2 = ax;
		var dy2 = cy2;
		var tp_t01 = new trilateral_tri_Trilateral(ax2,ay2,bx2,by2,dx2,dy2);
		var tp_t11 = new trilateral_tri_Trilateral(bx2,by2,cx2,cy2,dx2,dy2);
		out[out.length] = tp_t01;
		out[out.length] = tp_t11;
		var dimY = height - 2 * radius;
		var ax3 = x;
		var ay3 = ay;
		var bx3 = x + thick;
		var by3 = ay3;
		var cx3 = bx3;
		var cy3 = ay3 + dimY;
		var dx3 = x;
		var dy3 = cy3;
		var tp_t02 = new trilateral_tri_Trilateral(ax3,ay3,bx3,by3,dx3,dy3);
		var tp_t12 = new trilateral_tri_Trilateral(bx3,by3,cx3,cy3,dx3,dy3);
		out[out.length] = tp_t02;
		out[out.length] = tp_t12;
		var x1 = x + width - thick;
		var ax4 = x1;
		var ay4 = by;
		var bx4 = x1 + thick;
		var by4 = ay4;
		var cx4 = bx4;
		var cy4 = ay4 + dimY;
		var dx4 = x1;
		var dy4 = cy4;
		var tp_t03 = new trilateral_tri_Trilateral(ax4,ay4,bx4,by4,dx4,dy4);
		var tp_t13 = new trilateral_tri_Trilateral(bx4,by4,cx4,cy4,dx4,dy4);
		out[out.length] = tp_t03;
		out[out.length] = tp_t13;
		var beta = -pi;
		var gamma = -pi_2;
		var t2 = [];
		var this5;
		if(t2 == null) {
			var t3 = [];
			var this6;
			if(t3 == null) {
				var t4 = [];
				var this7 = t4 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t4;
				this6 = this7;
			} else {
				this6 = t3;
			}
			this5 = this6;
		} else {
			this5 = t2;
		}
		var this8 = this5;
		var out1 = this8;
		var pi1 = Math.PI;
		var step = pi1 * 2 / 36;
		var dif;
		switch(trilateral_angle_DifferencePreference.CLOCKWISE._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this9 = f;
			var za = this9;
			var f1;
			if(gamma >= 0 && gamma > Math.PI) {
				f1 = gamma;
			} else {
				var a1 = gamma % (2 * Math.PI);
				f1 = a1 >= 0 ? a1 : a1 + 2 * Math.PI;
			}
			var this10 = f1;
			var zb = this10;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(beta - gamma);
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f2;
			if(beta >= 0 && beta > Math.PI) {
				f2 = beta;
			} else {
				var a2 = beta % (2 * Math.PI);
				f2 = a2 >= 0 ? a2 : a2 + 2 * Math.PI;
			}
			var this11 = f2;
			var za1 = this11;
			var f3;
			if(gamma >= 0 && gamma > Math.PI) {
				f3 = gamma;
			} else {
				var a3 = gamma % (2 * Math.PI);
				f3 = a3 >= 0 ? a3 : a3 + 2 * Math.PI;
			}
			var this12 = f3;
			var zb1 = this12;
			var fa1 = za1;
			var fb1 = zb1;
			var theta1 = Math.abs(beta - gamma);
			var clockwise1 = beta < gamma;
			var dif2 = clockwise1 ? theta1 : -theta1;
			dif = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
			break;
		case 2:
			var f4;
			if(beta >= 0 && beta > Math.PI) {
				f4 = beta;
			} else {
				var a4 = beta % (2 * Math.PI);
				f4 = a4 >= 0 ? a4 : a4 + 2 * Math.PI;
			}
			var this13 = f4;
			var za2 = this13;
			var f5;
			if(gamma >= 0 && gamma > Math.PI) {
				f5 = gamma;
			} else {
				var a5 = gamma % (2 * Math.PI);
				f5 = a5 >= 0 ? a5 : a5 + 2 * Math.PI;
			}
			var this14 = f5;
			var zb2 = this14;
			var fa2 = beta;
			var fb2 = gamma;
			var theta2 = Math.abs(beta - gamma);
			var smallest = theta2 <= Math.PI;
			var clockwise2 = beta < gamma;
			var dif3 = clockwise2 ? theta2 : -theta2;
			dif = smallest ? dif3 : clockwise2 ? -(2 * Math.PI - theta2) : 2 * Math.PI - theta2;
			break;
		case 3:
			var f6;
			if(beta >= 0 && beta > Math.PI) {
				f6 = beta;
			} else {
				var a6 = beta % (2 * Math.PI);
				f6 = a6 >= 0 ? a6 : a6 + 2 * Math.PI;
			}
			var this15 = f6;
			var za3 = this15;
			var f7;
			if(gamma >= 0 && gamma > Math.PI) {
				f7 = gamma;
			} else {
				var a7 = gamma % (2 * Math.PI);
				f7 = a7 >= 0 ? a7 : a7 + 2 * Math.PI;
			}
			var this16 = f7;
			var zb3 = this16;
			var fa3 = beta;
			var fb3 = gamma;
			var theta3 = Math.abs(beta - gamma);
			var largest = theta3 > Math.PI;
			var clockwise3 = beta < gamma;
			var dif4 = clockwise3 ? theta3 : -theta3;
			dif = largest ? dif4 : clockwise3 ? -(2 * Math.PI - theta3) : 2 * Math.PI - theta3;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step1 = dif / totalSteps;
		var angle = beta;
		var cx5;
		var cy5;
		var bx5 = 0;
		var by5 = 0;
		var dx5 = 0;
		var dy5 = 0;
		var ex = 0;
		var ey = 0;
		var r2 = radius - thick;
		var _g = 0;
		var _g1 = totalSteps + 1;
		while(_g < _g1) {
			var i = _g++;
			cx5 = ax + radius * Math.sin(angle);
			cy5 = ay + radius * Math.cos(angle);
			ex = ax + r2 * Math.sin(angle);
			ey = ay + r2 * Math.cos(angle);
			if(i != 0) {
				var t0 = new trilateral_tri_Trilateral(dx5,dy5,bx5,by5,cx5,cy5);
				var t11 = new trilateral_tri_Trilateral(dx5,dy5,cx5,cy5,ex,ey);
				out1[out1.length] = t0;
				out1[out1.length] = t11;
			}
			angle += step1;
			bx5 = cx5;
			by5 = cy5;
			dx5 = ex;
			dy5 = ey;
		}
		var triArr = out1;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t5 = triArr[_g2];
			++_g2;
			out[out.length] = t5;
		}
		var t6 = [];
		var this17;
		if(t6 == null) {
			var t7 = [];
			var this18;
			if(t7 == null) {
				var t8 = [];
				var this19 = t8 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t8;
				this18 = this19;
			} else {
				this18 = t7;
			}
			this17 = this18;
		} else {
			this17 = t6;
		}
		var this20 = this17;
		var out2 = this20;
		var pi2 = Math.PI;
		var step2 = pi2 * 2 / 36;
		var dif5;
		switch(trilateral_angle_DifferencePreference.CLOCKWISE._hx_index) {
		case 0:
			var f8;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f8 = pi_2;
			} else {
				var a8 = pi_2 % (2 * Math.PI);
				f8 = a8 >= 0 ? a8 : a8 + 2 * Math.PI;
			}
			var this21 = f8;
			var za4 = this21;
			var f9;
			if(pi >= 0 && pi > Math.PI) {
				f9 = pi;
			} else {
				var a9 = pi % (2 * Math.PI);
				f9 = a9 >= 0 ? a9 : a9 + 2 * Math.PI;
			}
			var this22 = f9;
			var zb4 = this22;
			var fa4 = za4;
			var fb4 = zb4;
			var theta4 = Math.abs(pi_2 - pi);
			var clockwise4 = pi_2 < pi;
			var dif6 = clockwise4 ? theta4 : -theta4;
			dif5 = dif6 > 0 ? dif6 : 2 * Math.PI + dif6;
			break;
		case 1:
			var f10;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f10 = pi_2;
			} else {
				var a10 = pi_2 % (2 * Math.PI);
				f10 = a10 >= 0 ? a10 : a10 + 2 * Math.PI;
			}
			var this23 = f10;
			var za5 = this23;
			var f11;
			if(pi >= 0 && pi > Math.PI) {
				f11 = pi;
			} else {
				var a11 = pi % (2 * Math.PI);
				f11 = a11 >= 0 ? a11 : a11 + 2 * Math.PI;
			}
			var this24 = f11;
			var zb5 = this24;
			var fa5 = za5;
			var fb5 = zb5;
			var theta5 = Math.abs(pi_2 - pi);
			var clockwise5 = pi_2 < pi;
			var dif7 = clockwise5 ? theta5 : -theta5;
			dif5 = dif7 < 0 ? dif7 : -2 * Math.PI + dif7;
			break;
		case 2:
			var f12;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f12 = pi_2;
			} else {
				var a12 = pi_2 % (2 * Math.PI);
				f12 = a12 >= 0 ? a12 : a12 + 2 * Math.PI;
			}
			var this25 = f12;
			var za6 = this25;
			var f13;
			if(pi >= 0 && pi > Math.PI) {
				f13 = pi;
			} else {
				var a13 = pi % (2 * Math.PI);
				f13 = a13 >= 0 ? a13 : a13 + 2 * Math.PI;
			}
			var this26 = f13;
			var zb6 = this26;
			var fa6 = pi_2;
			var fb6 = pi;
			var theta6 = Math.abs(pi_2 - pi);
			var smallest1 = theta6 <= Math.PI;
			var clockwise6 = pi_2 < pi;
			var dif8 = clockwise6 ? theta6 : -theta6;
			dif5 = smallest1 ? dif8 : clockwise6 ? -(2 * Math.PI - theta6) : 2 * Math.PI - theta6;
			break;
		case 3:
			var f14;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f14 = pi_2;
			} else {
				var a14 = pi_2 % (2 * Math.PI);
				f14 = a14 >= 0 ? a14 : a14 + 2 * Math.PI;
			}
			var this27 = f14;
			var za7 = this27;
			var f15;
			if(pi >= 0 && pi > Math.PI) {
				f15 = pi;
			} else {
				var a15 = pi % (2 * Math.PI);
				f15 = a15 >= 0 ? a15 : a15 + 2 * Math.PI;
			}
			var this28 = f15;
			var zb7 = this28;
			var fa7 = pi_2;
			var fb7 = pi;
			var theta7 = Math.abs(pi_2 - pi);
			var largest1 = theta7 > Math.PI;
			var clockwise7 = pi_2 < pi;
			var dif9 = clockwise7 ? theta7 : -theta7;
			dif5 = largest1 ? dif9 : clockwise7 ? -(2 * Math.PI - theta7) : 2 * Math.PI - theta7;
			break;
		}
		var positive1 = dif5 >= 0;
		var totalSteps1 = Math.ceil(Math.abs(dif5) / step2);
		var step3 = dif5 / totalSteps1;
		var angle1 = pi_2;
		var cx6;
		var cy6;
		var bx6 = 0;
		var by6 = 0;
		var dx6 = 0;
		var dy6 = 0;
		var ex1 = 0;
		var ey1 = 0;
		var r21 = radius - thick;
		var _g3 = 0;
		var _g11 = totalSteps1 + 1;
		while(_g3 < _g11) {
			var i1 = _g3++;
			cx6 = bx + radius * Math.sin(angle1);
			cy6 = by + radius * Math.cos(angle1);
			ex1 = bx + r21 * Math.sin(angle1);
			ey1 = by + r21 * Math.cos(angle1);
			if(i1 != 0) {
				var t01 = new trilateral_tri_Trilateral(dx6,dy6,bx6,by6,cx6,cy6);
				var t12 = new trilateral_tri_Trilateral(dx6,dy6,cx6,cy6,ex1,ey1);
				out2[out2.length] = t01;
				out2[out2.length] = t12;
			}
			angle1 += step3;
			bx6 = cx6;
			by6 = cy6;
			dx6 = ex1;
			dy6 = ey1;
		}
		var triArr1 = out2;
		var _g4 = 0;
		while(_g4 < triArr1.length) {
			var t9 = triArr1[_g4];
			++_g4;
			out[out.length] = t9;
		}
		var t10 = [];
		var this29;
		if(t10 == null) {
			var t13 = [];
			var this30;
			if(t13 == null) {
				var t14 = [];
				var this31 = t14 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t14;
				this30 = this31;
			} else {
				this30 = t13;
			}
			this29 = this30;
		} else {
			this29 = t10;
		}
		var this32 = this29;
		var out3 = this32;
		var pi3 = Math.PI;
		var step4 = pi3 * 2 / 36;
		var dif10;
		switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE._hx_index) {
		case 0:
			var f16;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f16 = pi_2;
			} else {
				var a16 = pi_2 % (2 * Math.PI);
				f16 = a16 >= 0 ? a16 : a16 + 2 * Math.PI;
			}
			var this33 = f16;
			var za8 = this33;
			var f17;
			if(0 > Math.PI) {
				f17 = 0;
			} else {
				var a17 = 0 % (2 * Math.PI);
				f17 = a17 >= 0 ? a17 : a17 + 2 * Math.PI;
			}
			var this34 = f17;
			var zb8 = this34;
			var fa8 = za8;
			var fb8 = zb8;
			var theta8 = Math.abs(pi_2);
			var clockwise8 = pi_2 < 0;
			var dif11 = clockwise8 ? theta8 : -theta8;
			dif10 = dif11 > 0 ? dif11 : 2 * Math.PI + dif11;
			break;
		case 1:
			var f18;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f18 = pi_2;
			} else {
				var a18 = pi_2 % (2 * Math.PI);
				f18 = a18 >= 0 ? a18 : a18 + 2 * Math.PI;
			}
			var this35 = f18;
			var za9 = this35;
			var f19;
			if(0 > Math.PI) {
				f19 = 0;
			} else {
				var a19 = 0 % (2 * Math.PI);
				f19 = a19 >= 0 ? a19 : a19 + 2 * Math.PI;
			}
			var this36 = f19;
			var zb9 = this36;
			var fa9 = za9;
			var fb9 = zb9;
			var theta9 = Math.abs(pi_2);
			var clockwise9 = pi_2 < 0;
			var dif12 = clockwise9 ? theta9 : -theta9;
			dif10 = dif12 < 0 ? dif12 : -2 * Math.PI + dif12;
			break;
		case 2:
			var f20;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f20 = pi_2;
			} else {
				var a20 = pi_2 % (2 * Math.PI);
				f20 = a20 >= 0 ? a20 : a20 + 2 * Math.PI;
			}
			var this37 = f20;
			var za10 = this37;
			var f21;
			if(0 > Math.PI) {
				f21 = 0;
			} else {
				var a21 = 0 % (2 * Math.PI);
				f21 = a21 >= 0 ? a21 : a21 + 2 * Math.PI;
			}
			var this38 = f21;
			var zb10 = this38;
			var fa10 = pi_2;
			var fb10 = 0;
			var theta10 = Math.abs(pi_2);
			var smallest2 = theta10 <= Math.PI;
			var clockwise10 = pi_2 < 0;
			var dif13 = clockwise10 ? theta10 : -theta10;
			dif10 = smallest2 ? dif13 : clockwise10 ? -(2 * Math.PI - theta10) : 2 * Math.PI - theta10;
			break;
		case 3:
			var f22;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f22 = pi_2;
			} else {
				var a22 = pi_2 % (2 * Math.PI);
				f22 = a22 >= 0 ? a22 : a22 + 2 * Math.PI;
			}
			var this39 = f22;
			var za11 = this39;
			var f23;
			if(0 > Math.PI) {
				f23 = 0;
			} else {
				var a23 = 0 % (2 * Math.PI);
				f23 = a23 >= 0 ? a23 : a23 + 2 * Math.PI;
			}
			var this40 = f23;
			var zb11 = this40;
			var fa11 = pi_2;
			var fb11 = 0;
			var theta11 = Math.abs(pi_2);
			var largest2 = theta11 > Math.PI;
			var clockwise11 = pi_2 < 0;
			var dif14 = clockwise11 ? theta11 : -theta11;
			dif10 = largest2 ? dif14 : clockwise11 ? -(2 * Math.PI - theta11) : 2 * Math.PI - theta11;
			break;
		}
		var positive2 = dif10 >= 0;
		var totalSteps2 = Math.ceil(Math.abs(dif10) / step4);
		var step5 = dif10 / totalSteps2;
		var angle2 = pi_2;
		var cx7;
		var cy7;
		var bx7 = 0;
		var by7 = 0;
		var dx7 = 0;
		var dy7 = 0;
		var ex2 = 0;
		var ey2 = 0;
		var r22 = radius - thick;
		var _g5 = 0;
		var _g12 = totalSteps2 + 1;
		while(_g5 < _g12) {
			var i2 = _g5++;
			cx7 = cx + radius * Math.sin(angle2);
			cy7 = cy + radius * Math.cos(angle2);
			ex2 = cx + r22 * Math.sin(angle2);
			ey2 = cy + r22 * Math.cos(angle2);
			if(i2 != 0) {
				var t02 = new trilateral_tri_Trilateral(dx7,dy7,bx7,by7,cx7,cy7);
				var t15 = new trilateral_tri_Trilateral(dx7,dy7,cx7,cy7,ex2,ey2);
				out3[out3.length] = t02;
				out3[out3.length] = t15;
			}
			angle2 += step5;
			bx7 = cx7;
			by7 = cy7;
			dx7 = ex2;
			dy7 = ey2;
		}
		var triArr2 = out3;
		var _g6 = 0;
		while(_g6 < triArr2.length) {
			var t16 = triArr2[_g6];
			++_g6;
			out[out.length] = t16;
		}
		var gamma1 = -pi_2;
		var t17 = [];
		var this41;
		if(t17 == null) {
			var t18 = [];
			var this42;
			if(t18 == null) {
				var t19 = [];
				var this43 = t19 == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t19;
				this42 = this43;
			} else {
				this42 = t18;
			}
			this41 = this42;
		} else {
			this41 = t17;
		}
		var this44 = this41;
		var out4 = this44;
		var pi4 = Math.PI;
		var step6 = pi4 * 2 / 36;
		var dif15;
		switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE._hx_index) {
		case 0:
			var f24;
			if(0 > Math.PI) {
				f24 = 0;
			} else {
				var a24 = 0 % (2 * Math.PI);
				f24 = a24 >= 0 ? a24 : a24 + 2 * Math.PI;
			}
			var this45 = f24;
			var za12 = this45;
			var f25;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f25 = gamma1;
			} else {
				var a25 = gamma1 % (2 * Math.PI);
				f25 = a25 >= 0 ? a25 : a25 + 2 * Math.PI;
			}
			var this46 = f25;
			var zb12 = this46;
			var fa12 = za12;
			var fb12 = zb12;
			var theta12 = Math.abs(0 - gamma1);
			var clockwise12 = 0 < gamma1;
			var dif16 = clockwise12 ? theta12 : -theta12;
			dif15 = dif16 > 0 ? dif16 : 2 * Math.PI + dif16;
			break;
		case 1:
			var f26;
			if(0 > Math.PI) {
				f26 = 0;
			} else {
				var a26 = 0 % (2 * Math.PI);
				f26 = a26 >= 0 ? a26 : a26 + 2 * Math.PI;
			}
			var this47 = f26;
			var za13 = this47;
			var f27;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f27 = gamma1;
			} else {
				var a27 = gamma1 % (2 * Math.PI);
				f27 = a27 >= 0 ? a27 : a27 + 2 * Math.PI;
			}
			var this48 = f27;
			var zb13 = this48;
			var fa13 = za13;
			var fb13 = zb13;
			var theta13 = Math.abs(0 - gamma1);
			var clockwise13 = 0 < gamma1;
			var dif17 = clockwise13 ? theta13 : -theta13;
			dif15 = dif17 < 0 ? dif17 : -2 * Math.PI + dif17;
			break;
		case 2:
			var f28;
			if(0 > Math.PI) {
				f28 = 0;
			} else {
				var a28 = 0 % (2 * Math.PI);
				f28 = a28 >= 0 ? a28 : a28 + 2 * Math.PI;
			}
			var this49 = f28;
			var za14 = this49;
			var f29;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f29 = gamma1;
			} else {
				var a29 = gamma1 % (2 * Math.PI);
				f29 = a29 >= 0 ? a29 : a29 + 2 * Math.PI;
			}
			var this50 = f29;
			var zb14 = this50;
			var fa14 = 0;
			var fb14 = gamma1;
			var theta14 = Math.abs(0 - gamma1);
			var smallest3 = theta14 <= Math.PI;
			var clockwise14 = 0 < gamma1;
			var dif18 = clockwise14 ? theta14 : -theta14;
			dif15 = smallest3 ? dif18 : clockwise14 ? -(2 * Math.PI - theta14) : 2 * Math.PI - theta14;
			break;
		case 3:
			var f30;
			if(0 > Math.PI) {
				f30 = 0;
			} else {
				var a30 = 0 % (2 * Math.PI);
				f30 = a30 >= 0 ? a30 : a30 + 2 * Math.PI;
			}
			var this51 = f30;
			var za15 = this51;
			var f31;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f31 = gamma1;
			} else {
				var a31 = gamma1 % (2 * Math.PI);
				f31 = a31 >= 0 ? a31 : a31 + 2 * Math.PI;
			}
			var this52 = f31;
			var zb15 = this52;
			var fa15 = 0;
			var fb15 = gamma1;
			var theta15 = Math.abs(0 - gamma1);
			var largest3 = theta15 > Math.PI;
			var clockwise15 = 0 < gamma1;
			var dif19 = clockwise15 ? theta15 : -theta15;
			dif15 = largest3 ? dif19 : clockwise15 ? -(2 * Math.PI - theta15) : 2 * Math.PI - theta15;
			break;
		}
		var positive3 = dif15 >= 0;
		var totalSteps3 = Math.ceil(Math.abs(dif15) / step6);
		var step7 = dif15 / totalSteps3;
		var angle3 = 0;
		var cx8;
		var cy8;
		var bx8 = 0;
		var by8 = 0;
		var dx8 = 0;
		var dy8 = 0;
		var ex3 = 0;
		var ey3 = 0;
		var r23 = radius - thick;
		var _g7 = 0;
		var _g13 = totalSteps3 + 1;
		while(_g7 < _g13) {
			var i3 = _g7++;
			cx8 = dx + radius * Math.sin(angle3);
			cy8 = dy + radius * Math.cos(angle3);
			ex3 = dx + r23 * Math.sin(angle3);
			ey3 = dy + r23 * Math.cos(angle3);
			if(i3 != 0) {
				var t03 = new trilateral_tri_Trilateral(dx8,dy8,bx8,by8,cx8,cy8);
				var t110 = new trilateral_tri_Trilateral(dx8,dy8,cx8,cy8,ex3,ey3);
				out4[out4.length] = t03;
				out4[out4.length] = t110;
			}
			angle3 += step7;
			bx8 = cx8;
			by8 = cy8;
			dx8 = ex3;
			dy8 = ey3;
		}
		var triArr3 = out4;
		var _g8 = 0;
		while(_g8 < triArr3.length) {
			var t20 = triArr3[_g8];
			++_g8;
			out[out.length] = t20;
		}
		var triArr4 = out;
		var tri;
		var _g9 = 0;
		while(_g9 < triArr4.length) {
			var t21 = triArr4[_g9];
			++_g9;
			if(t21 != null) {
				var t22 = Object.create(trilateral_tri_Triangle.prototype);
				t22.id = id;
				t22.ax = t21.ax;
				t22.ay = t21.ay;
				t22.bx = t21.bx;
				t22.by = t21.by;
				t22.cx = t21.cx;
				t22.cy = t21.cy;
				t22.mark = t21.mark;
				t22.depth = 0;
				t22.alpha = 1.;
				t22.colorID = color;
				t22.colorA = color;
				t22.colorB = color;
				t22.colorC = color;
				t22.windingAdjusted = t21.windingAdjusted;
				tri = t22;
				this1[this1.length] = tri;
			}
		}
		return this.refCount - 1;
	}
	,spiralLines: function(x,y,radius,nolines,startWid,stepWid,color) {
		var theta = 0.;
		var line;
		var wid = startWid;
		var _g = 0;
		var _g1 = nolines;
		while(_g < _g1) {
			var i = _g++;
			var p0_x = x;
			var p0_y = y;
			var p1_x = x + radius * Math.sin(theta);
			var p1_y = y + radius * Math.cos(theta);
			theta += Math.PI * 2 / nolines;
			var width = wid += stepWid;
			var dx = p0_x - p1_x;
			var dy = p0_y - p1_y;
			var P_x = p0_x - width / 2;
			var P_y = p0_y;
			var omega = Math.atan2(dy,dx);
			var dim_x = width;
			var dim_y = dx * dx + dy * dy;
			var pivotX = p0_x + width / 2;
			var pivotY = p0_y;
			var px = P_x;
			var py = P_y;
			var dx1 = dim_x;
			var dy1 = dim_y;
			var A_ = { x : px, y : py};
			var B_ = { x : px + dx1, y : py};
			var C_ = { x : px + dx1, y : py + dy1};
			var D_ = { x : px, y : py + dy1};
			if(omega != 0.) {
				var sin = Math.sin(omega);
				var cos = Math.cos(omega);
				var px1 = A_.x - pivotX;
				var py1 = A_.y - pivotY;
				var px2 = px1 * cos - py1 * sin;
				py1 = py1 * cos + px1 * sin;
				A_ = { x : px2 + pivotX, y : py1 + pivotY};
				var px3 = B_.x - pivotX;
				var py2 = B_.y - pivotY;
				var px21 = px3 * cos - py2 * sin;
				py2 = py2 * cos + px3 * sin;
				B_ = { x : px21 + pivotX, y : py2 + pivotY};
				var px4 = C_.x - pivotX;
				var py3 = C_.y - pivotY;
				var px22 = px4 * cos - py3 * sin;
				py3 = py3 * cos + px4 * sin;
				C_ = { x : px22 + pivotX, y : py3 + pivotY};
				var px5 = D_.x - pivotX;
				var py4 = D_.y - pivotY;
				var px23 = px5 * cos - py4 * sin;
				py4 = py4 * cos + px5 * sin;
				D_ = { x : px23 + pivotX, y : py4 + pivotY};
			}
			var q_A = A_;
			var q_B = B_;
			var q_C = C_;
			var q_D = D_;
			line = { t0 : new trilateral_tri_Trilateral(q_A.x,q_A.y,q_B.x,q_B.y,q_D.x,q_D.y), t1 : new trilateral_tri_Trilateral(q_B.x,q_B.y,q_C.x,q_C.y,q_D.x,q_D.y)};
			var this1 = this.triangles;
			var id = this.refCount;
			var tri = line.t0;
			var t = Object.create(trilateral_tri_Triangle.prototype);
			t.id = id;
			t.ax = tri.ax;
			t.ay = tri.ay;
			t.bx = tri.bx;
			t.by = tri.by;
			t.cx = tri.cx;
			t.cy = tri.cy;
			t.mark = tri.mark;
			t.depth = 0;
			t.alpha = 1.;
			t.colorID = color;
			t.colorA = color;
			t.colorB = color;
			t.colorC = color;
			t.windingAdjusted = tri.windingAdjusted;
			var tri0 = t;
			this1[this1.length] = tri0;
			var tri1 = line.t1;
			var t1 = Object.create(trilateral_tri_Triangle.prototype);
			t1.id = id;
			t1.ax = tri1.ax;
			t1.ay = tri1.ay;
			t1.bx = tri1.bx;
			t1.by = tri1.by;
			t1.cx = tri1.cx;
			t1.cy = tri1.cy;
			t1.mark = tri1.mark;
			t1.depth = 0;
			t1.alpha = 1.;
			t1.colorID = color;
			t1.colorA = color;
			t1.colorB = color;
			t1.colorC = color;
			t1.windingAdjusted = tri1.windingAdjusted;
			var tri11 = t1;
			this1[this1.length] = tri11;
		}
		this.refCount++;
		return this.refCount - 1;
	}
};
var trilateral_tri_Trilateral = function(ax_,ay_,bx_,by_,cx_,cy_,mark_) {
	if(mark_ == null) {
		mark_ = 0;
	}
	this.mark = 0;
	this.ax = ax_;
	this.ay = ay_;
	this.bx = bx_;
	this.by = by_;
	this.cx = cx_;
	this.cy = cy_;
	this.windingAdjusted = this.adjustWinding();
	if(this.windingAdjusted) {
		this.ax = ax_;
		this.ay = ay_;
		this.bx = cx_;
		this.by = cy_;
		this.cx = bx_;
		this.cy = by_;
	}
	this.mark = mark_;
};
trilateral_tri_Trilateral.__name__ = true;
trilateral_tri_Trilateral.prototype = {
	get_x: function() {
		return Math.min(Math.min(this.ax,this.bx),this.cx);
	}
	,set_x: function(x) {
		var dx = x - this.get_x();
		this.ax += dx;
		this.bx += dx;
		this.cx += dx;
		return x;
	}
	,get_y: function() {
		return Math.min(Math.min(this.ay,this.by),this.cy);
	}
	,set_y: function(y) {
		var dy = y - this.get_y();
		this.ay += dy;
		this.by += dy;
		this.cy += dy;
		return y;
	}
	,get_right: function() {
		return Math.max(Math.max(this.ax,this.bx),this.cx);
	}
	,get_bottom: function() {
		return Math.max(Math.max(this.ay,this.by),this.cy);
	}
	,moveDelta: function(dx,dy) {
		this.ax += dx;
		this.ay += dy;
		this.bx += dx;
		this.by += dy;
		this.cx += dx;
		this.cy += dy;
	}
	,liteHit: function(px,py) {
		var planeAB = (this.ax - px) * (this.by - py) - (this.bx - px) * (this.ay - py);
		var planeBC = (this.bx - px) * (this.cy - py) - (this.cx - px) * (this.by - py);
		var planeCA = (this.cx - px) * (this.ay - py) - (this.ax - px) * (this.cy - py);
		if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0)) {
			return (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0);
		} else {
			return false;
		}
	}
	,fullHit: function(px,py) {
		if(px > this.get_x() && px < this.get_right() && py > this.get_y() && py < this.get_bottom()) {
			return true;
		}
		var planeAB = (this.ax - px) * (this.by - py) - (this.bx - px) * (this.ay - py);
		var planeBC = (this.bx - px) * (this.cy - py) - (this.cx - px) * (this.by - py);
		var planeCA = (this.cx - px) * (this.ay - py) - (this.ax - px) * (this.cy - py);
		if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0)) {
			return (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0);
		} else {
			return false;
		}
	}
	,adjustWinding: function() {
		return this.ax * this.by - this.bx * this.ay + (this.bx * this.cy - this.cx * this.by) + (this.cx * this.ay - this.ax * this.cy) > 0;
	}
	,rotate: function(x,y,theta) {
		var cos = Math.cos(theta);
		var sin = Math.sin(theta);
		this.ax -= x;
		this.ay -= y;
		this.bx -= x;
		this.by -= y;
		this.cx -= x;
		this.cy -= y;
		var dx = this.ax;
		var dy = this.ay;
		this.ax = dx * cos - dy * sin;
		this.ay = dx * sin + dy * cos;
		dx = this.bx;
		dy = this.by;
		this.bx = dx * cos - dy * sin;
		this.by = dx * sin + dy * cos;
		dx = this.cx;
		dy = this.cy;
		this.cx = dx * cos - dy * sin;
		this.cy = dx * sin + dy * cos;
		this.ax += x;
		this.ay += y;
		this.bx += x;
		this.by += y;
		this.cx += x;
		this.cy += y;
	}
	,rotateTrig: function(x,y,cos,sin) {
		this.ax -= x;
		this.ay -= y;
		this.bx -= x;
		this.by -= y;
		this.cx -= x;
		this.cy -= y;
		var dx = this.ax;
		var dy = this.ay;
		this.ax = dx * cos - dy * sin;
		this.ay = dx * sin + dy * cos;
		dx = this.bx;
		dy = this.by;
		this.bx = dx * cos - dy * sin;
		this.by = dx * sin + dy * cos;
		dx = this.cx;
		dy = this.cy;
		this.cx = dx * cos - dy * sin;
		this.cy = dx * sin + dy * cos;
		this.ax += x;
		this.ay += y;
		this.bx += x;
		this.by += y;
		this.cx += x;
		this.cy += y;
	}
};
var trilateral_tri_Triangle = function(id_,A,B,C,depth_,colorID_) {
	this.id = id_;
	trilateral_tri_Trilateral.call(this,A.x,A.y,B.x,B.y,C.x,C.y);
	this.depth = depth_;
	this.alpha = 1.;
	this.colorID = colorID_;
	this.colorA = colorID_;
	this.colorB = colorID_;
	this.colorC = colorID_;
};
trilateral_tri_Triangle.__name__ = true;
trilateral_tri_Triangle.fromTrilateral = function(id_,tri,depth_,colorID_) {
	var t = Object.create(trilateral_tri_Triangle.prototype);
	t.id = id_;
	t.ax = tri.ax;
	t.ay = tri.ay;
	t.bx = tri.bx;
	t.by = tri.by;
	t.cx = tri.cx;
	t.cy = tri.cy;
	t.mark = tri.mark;
	t.depth = depth_;
	t.alpha = 1.;
	t.colorID = colorID_;
	t.colorA = colorID_;
	t.colorB = colorID_;
	t.colorC = colorID_;
	t.windingAdjusted = tri.windingAdjusted;
	return t;
};
trilateral_tri_Triangle.__super__ = trilateral_tri_Trilateral;
trilateral_tri_Triangle.prototype = $extend(trilateral_tri_Trilateral.prototype,{
	hitTest: function(P) {
		return this.fullHit(P.x,P.y);
	}
	,drawStrips: function(drawRect) {
		var xi = Math.floor(this.get_x());
		var yi = Math.floor(this.get_y());
		var righti = Math.ceil(this.get_right());
		var bottomi = Math.ceil(this.get_bottom());
		var sx = 0;
		var ex = 0;
		var sFound;
		var eFound;
		var _g = yi;
		var _g1 = bottomi;
		while(_g < _g1) {
			var y0 = _g++;
			sFound = false;
			eFound = false;
			var _g2 = xi;
			var _g11 = righti;
			while(_g2 < _g11) {
				var x0 = _g2++;
				var planeAB = (this.ax - x0) * (this.by - y0) - (this.bx - x0) * (this.ay - y0);
				var planeBC = (this.bx - x0) * (this.cy - y0) - (this.cx - x0) * (this.by - y0);
				var planeCA = (this.cx - x0) * (this.ay - y0) - (this.ax - x0) * (this.cy - y0);
				if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0) && (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0)) {
					sx = x0;
					sFound = true;
					break;
				}
			}
			if(sFound) {
				var _g21 = sx;
				var _g3 = righti;
				while(_g21 < _g3) {
					var x01 = _g21++;
					var planeAB1 = (this.ax - x01) * (this.by - y0) - (this.bx - x01) * (this.ay - y0);
					var planeBC1 = (this.bx - x01) * (this.cy - y0) - (this.cx - x01) * (this.by - y0);
					var planeCA1 = (this.cx - x01) * (this.ay - y0) - (this.ax - x01) * (this.cy - y0);
					if(!((Math.abs(planeAB1) / planeAB1 | 0) == (Math.abs(planeBC1) / planeBC1 | 0) && (Math.abs(planeBC1) / planeBC1 | 0) == (Math.abs(planeCA1) / planeCA1 | 0))) {
						ex = x01;
						eFound = true;
						break;
					}
				}
				if(eFound) {
					drawRect(sx,y0,ex - sx,1);
				}
			}
		}
	}
});
var trilateral_tri__$TriangleArray_TriangleArray_$Impl_$ = {};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.__name__ = true;
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new = function(t) {
	var this1 = t == null ? trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new([]) : t;
	return this1;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.changeFillColorByID = function(this1,id,colorID,startID,endID) {
	if(endID == null) {
		endID = 0;
	}
	if(startID == null) {
		startID = 0;
	}
	var tri;
	if(endID == 0) {
		endID = this1.length;
	}
	var _g = startID;
	var _g1 = endID;
	while(_g < _g1) {
		var i = _g++;
		tri = this1[i];
		if(tri.id == id) {
			tri.colorID = colorID;
			tri.colorA = colorID;
			tri.colorB = colorID;
			tri.colorC = colorID;
		}
	}
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.getEmpty = function() {
	var t = [];
	var this1 = t == null ? trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new([]) : t;
	return this1;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.clear = function(this1) {
	var t = [];
	var this2 = t == null ? trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new([]) : t;
	var this3 = this2;
	this1 = this3;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.pushPair = function(this1,tp) {
	this1[this1.length] = tp.t0;
	this1[this1.length] = tp.t1;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.drawTriangle = function(this1,id,p0,p1,p2,colorID) {
	var tri = new trilateral_tri_Triangle(id,p0,p1,p2,0,colorID);
	this1[this1.length] = tri;
	return tri;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.add = function(this1,id,tri,colorID) {
	var t = Object.create(trilateral_tri_Triangle.prototype);
	t.id = id;
	t.ax = tri.ax;
	t.ay = tri.ay;
	t.bx = tri.bx;
	t.by = tri.by;
	t.cx = tri.cx;
	t.cy = tri.cy;
	t.mark = tri.mark;
	t.depth = 0;
	t.alpha = 1.;
	t.colorID = colorID;
	t.colorA = colorID;
	t.colorB = colorID;
	t.colorC = colorID;
	t.windingAdjusted = tri.windingAdjusted;
	var tri1 = t;
	this1[this1.length] = tri1;
	return tri1;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.addPair = function(this1,id,tri,colorID) {
	var tri1 = tri.t0;
	var t = Object.create(trilateral_tri_Triangle.prototype);
	t.id = id;
	t.ax = tri1.ax;
	t.ay = tri1.ay;
	t.bx = tri1.bx;
	t.by = tri1.by;
	t.cx = tri1.cx;
	t.cy = tri1.cy;
	t.mark = tri1.mark;
	t.depth = 0;
	t.alpha = 1.;
	t.colorID = colorID;
	t.colorA = colorID;
	t.colorB = colorID;
	t.colorC = colorID;
	t.windingAdjusted = tri1.windingAdjusted;
	var tri0 = t;
	this1[this1.length] = tri0;
	var tri2 = tri.t1;
	var t1 = Object.create(trilateral_tri_Triangle.prototype);
	t1.id = id;
	t1.ax = tri2.ax;
	t1.ay = tri2.ay;
	t1.bx = tri2.bx;
	t1.by = tri2.by;
	t1.cx = tri2.cx;
	t1.cy = tri2.cy;
	t1.mark = tri2.mark;
	t1.depth = 0;
	t1.alpha = 1.;
	t1.colorID = colorID;
	t1.colorA = colorID;
	t1.colorB = colorID;
	t1.colorC = colorID;
	t1.windingAdjusted = tri2.windingAdjusted;
	var tri11 = t1;
	this1[this1.length] = tri11;
	return tri;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.addArray = function(this1,id,triArr,colorID) {
	var tri;
	var _g = 0;
	while(_g < triArr.length) {
		var t = triArr[_g];
		++_g;
		if(t != null) {
			var t1 = Object.create(trilateral_tri_Triangle.prototype);
			t1.id = id;
			t1.ax = t.ax;
			t1.ay = t.ay;
			t1.bx = t.bx;
			t1.by = t.by;
			t1.cx = t.cx;
			t1.cy = t.cy;
			t1.mark = t.mark;
			t1.depth = 0;
			t1.alpha = 1.;
			t1.colorID = colorID;
			t1.colorA = colorID;
			t1.colorB = colorID;
			t1.colorC = colorID;
			t1.windingAdjusted = t.windingAdjusted;
			tri = t1;
			this1[this1.length] = tri;
		}
	}
	return triArr;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.getTriangles = function(this1,id) {
	var t = [];
	var this2 = t == null ? trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new([]) : t;
	var this3 = this2;
	var out = this3;
	var _g = 0;
	var _g1 = this1.length;
	while(_g < _g1) {
		var i = _g++;
		if(this1[i].id == id) {
			out[out.length] = this1[i];
		}
	}
	return out;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.getHitTriangles = function(this1,p) {
	var t = [];
	var this2 = t == null ? trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new([]) : t;
	var this3 = this2;
	var out = this3;
	var _g = 0;
	var _g1 = this1.length;
	while(_g < _g1) {
		var i = _g++;
		if(this1[i].hitTest(p)) {
			out[out.length] = this1[i];
		}
	}
	return out;
};
var trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$ = {};
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$.__name__ = true;
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new = function(t) {
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	return this1;
};
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$.reversed = function(this1) {
	this1.reverse();
	return this1;
};
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$.getEmpty = function() {
	var t = [];
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	return this1;
};
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$.clear = function(this1) {
	var t = [];
	var this2 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	var this3 = this2;
	this1 = this3;
};
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$.add = function(this1,tri) {
	this1[this1.length] = tri;
};
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$.addPair = function(this1,tp) {
	this1[this1.length] = tp.t0;
	this1[this1.length] = tp.t1;
};
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$.addArray = function(this1,triArr) {
	var _g = 0;
	while(_g < triArr.length) {
		var t = triArr[_g];
		++_g;
		this1[this1.length] = t;
	}
	return triArr;
};
var trilateralXtra_parsing_FillDrawTess2 = function(w,h) {
	trilateral_parsing_FillDraw.call(this,w,h);
};
trilateralXtra_parsing_FillDrawTess2.__name__ = true;
trilateralXtra_parsing_FillDrawTess2.__super__ = trilateral_parsing_FillDraw;
trilateralXtra_parsing_FillDrawTess2.prototype = $extend(trilateral_parsing_FillDraw.prototype,{
	fillFunc: function(p) {
		var res = hxGeomAlgo_Tess2.tesselate(p,null,hxGeomAlgo_ResultType.POLYGONS,3);
		var vert = res.vertices;
		var tri = res.elements;
		return { vert : vert, tri : tri};
	}
	,pathFactory: function() {
		var pen = new trilateral_path_Fine(null,null,null);
		return pen;
	}
});
var truetype_TTFGlyphUtils = function(ttf) {
	var _g = 0;
	var _g1 = ttf.tables;
	while(_g < _g1.length) {
		var table = _g1[_g];
		++_g;
		switch(table._hx_index) {
		case 0:
			var descriptions = table.descriptions;
			console.log("truetype/TTFGlyphUtils.hx:24:","TGlyf descriptions: " + descriptions.length);
			this.descriptions = descriptions;
			this.length = this.descriptions.length;
			break;
		case 5:
			var headdata = table.data;
			this.headdata = headdata;
			break;
		default:
		}
	}
};
truetype_TTFGlyphUtils.__name__ = true;
truetype_TTFGlyphUtils.prototype = {
	getGlyphSimple: function(index) {
		var description = this.descriptions[index];
		switch(description._hx_index) {
		case 0:
			var data = description.data;
			var h = description.header;
			return data;
		case 1:
			var components = description.components;
			var h1 = description.header;
			throw new js__$Boot_HaxeError("TGlyphComposite " + index);
		case 2:
			console.log("truetype/TTFGlyphUtils.hx:44:","TGlyphNull " + index);
			return null;
		}
	}
	,getGlyphHeader: function(index) {
		var description = this.descriptions[index];
		switch(description._hx_index) {
		case 0:
			var data = description.data;
			var header = description.header;
			return header;
		case 1:
			var components = description.components;
			var header1 = description.header;
			return header1;
		case 2:
			console.log("truetype/TTFGlyphUtils.hx:57:","TGlyphNull " + index);
			return null;
		}
	}
	,getGlyphContours: function(index) {
		var simple = this.getGlyphSimple(index);
		var points = [];
		var _g = 0;
		var _g1 = simple.flags.length;
		while(_g < _g1) {
			var i = _g++;
			var onCurve = simple.flags[i] % 2 != 0;
			var point = { onCurve : onCurve, x : simple.xCoordinates[i], y : simple.yCoordinates[i]};
			points.push(point);
		}
		var p = 0;
		var c = 0;
		var first = 1;
		var contour = [];
		var contours = [];
		while(p < points.length) {
			var point1 = points[p];
			if(first == 1) {
				first = 0;
			}
			contour.push(point1);
			if(p == simple.endPtsOfContours[c]) {
				++c;
				first = 1;
				contours.push(contour.slice());
				contour = [];
			}
			++p;
		}
		this.adjustContours(contours);
		return contours;
	}
	,adjustContours: function(contours) {
		var hasOnCurve = function(contour) {
			return contour.filter(function(i) {
				return i.onCurve == true;
			}).length > 0;
		};
		var shiftPoints = function(contour1) {
			var first = contour1[0];
			while(first.onCurve == false) {
				contour1.push(contour1.shift());
				first = contour1[0];
			}
		};
		var addControlPointOnCurve = function(contour2) {
			var p0 = contour2[0];
			var p1 = contour2[contour2.length - 1];
			var newX = (p1.x - p0.x) / 2 + p0.x;
			var newY = (p1.y - p0.y) / 2 + p0.y;
			var newPoint = { x : newX, y : newY, onCurve : true};
			contour2.unshift(newPoint);
		};
		var _g = 0;
		while(_g < contours.length) {
			var contour3 = contours[_g];
			++_g;
			if(hasOnCurve(contour3)) {
				shiftPoints(contour3);
			} else {
				addControlPointOnCurve(contour3);
			}
		}
		var _g1 = 0;
		while(_g1 < contours.length) {
			var contour4 = contours[_g1];
			++_g1;
			var newContour = [];
			var _g11 = 0;
			var _g2 = contour4.length;
			while(_g11 < _g2) {
				var i1 = _g11++;
				var point = contour4[i1];
				newContour.push(point);
				if(i1 > 0) {
					var prevPoint = contour4[i1 - 1];
					if(point.onCurve == false && prevPoint.onCurve == false) {
						var newX1 = (point.x - prevPoint.x) / 2 + prevPoint.x;
						var newY1 = (point.y - prevPoint.y) / 2 + prevPoint.y;
						var newPoint1 = { x : newX1, y : newY1, onCurve : true};
						newContour.splice(newContour.length - 1,0,newPoint1);
					}
				}
			}
			newContour.push(newContour[0]);
			contours[contours.indexOf(contour4)] = newContour;
		}
	}
};
var $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
haxe_Resource.content = [{ name : "font", data : "AAEAAAAPAIAAAwBwRkZUTWucvysAAVnAAAAAHEdERUYLLw2oAAEtxAAAAFpHUE9T28cHIwABP6QAABoaR1NVQrUi0iMAAS4gAAARhE9TLzKKZk5KAAABeAAAAGBjbWFwuHinsQAADUQAAAPmZ2FzcP//AAMAAS28AAAACGdseWaQJTvmAAAW5AAA2nBoZWFk+pBpsgAAAPwAAAA2aGhlYQfGBgYAAAE0AAAAJGhtdHiCSWMtAAAB2AAAC2xsb2NhYxSamgAAESwAAAW4bWF4cAMkAEkAAAFYAAAAIG5hbWXC36eqAADxVAAAJHJwb3N0Zjc/NgABFcgAABfzAAEAAAABAABEqeLYXw889QALA+gAAAAAy7wTAgAAAADLvBMC/z7/BgS6A8MAAQAIAAIAAAAAAAAAAQAAA8v/AgAABN3/Pv9LBLoAAQAAAAAAAAAAAAAAAAAAAtsAAQAAAtsARgAHAAAAAAACAAAAAQABAAAAQAAAAAAAAAADAlwC7gAFAAACvAKKAAAAjAK8AooAAAHdADIA+gAAAgsIAwICAgICBIAAAg9QACBKAAAAAAAAAABMSU5PACAADfsEAvT/DADIA8sA/iAAAJcAAAAAAfICxAAAACAABAIAAAAB9AAAAU0AAAH0AAAA+gAAAWUAUQHyAFYCWwAuAoYAIwOPAB0DDQAtAS8AVgFWAB0BVgA2AekAHAKaADgBLAAUAUYAJAEsADEBn//5AoYALgKGAEAChgA1AoYAIAKGABkChgAoAoYAKwKGAD8ChgA5AoYALAFMAEQBTAAeApoATwKaAEQCmgBPAiIAKAMgAB0C2f/yApkASQK4ACgDBgBJAl8ASQJAAEkDAQAoAvwASQE+AEkCEf/9AscASQIOAEkDuwBJAxYASQNTACgCgABJA1kAJAKXAEkCTwAPAkUABQLiAEICqv/xBAEAAAK///gCnf/sAnsAJwFWADUBnwABAVYASQKyAEkB9AAAASz/2QI2ACECkwBCAfcAJwKSACcCVAAnAWwAAAKSACcCaQBCASgANgEr/9sCUwBBASoAQgOcAEACaABAAngAJwKRAEACkQAnAYwAQAHYAAsBdAACAmYAOwI3//8DZwAAAlL//QI3//8CAAAiAVYABgDxADcBVgAyApoAVQD6AAABZQBRAoYAUQKGAEgDtgCSAoYADADxADcCXwAoASz/1gMgABQBgAAtAh8AGQKaADMBRgAkAlgASAEs/+4BoAAoApoAPQGkAC0BpAAnASwARQKXAEACagAYASwAMQEsABEBpAAvAYAAJQIfACIDrAAuA6wALgOsACcCIgATAtn/8gLZ//IC2f/yAtn/8gLZ//IC2f/yBAn//AK4ACgCXwBJAl8ASQJfAEkCXwBJAT7/5wE+AEkBPv/ZAT7/3wMGAA0DFgBJA1MAKANTACgDUwAoA1MAKANTACgCmgA/A1MAJwLiAEIC4gBCAuIAQgLiAEICnf/sAoAASQKbAEACNgAhAjYAIQI2ACECNgAhAjYAIQI2ACEDgwAhAfcAJwJUACcCVAAnAlQAJwJUACcBKP/WASgAQgEo/9IBKP/WAngAJwJoAEACeAAnAngAJwJ4ACcCeAAnAngAJwKaAE8CeAAYAmYAOwJmADsCZgA7AmYAOwI3//8CkwBCAjf//wLZ//ICNgAhAtn/8gI2ACEC2f/yAjYAIQK4ACgB9wAnArgAKAH3ACcCuAAoAfcAJwK4ACgB9wAnAwYASQMXACcDBgANApIAJwJfAEkCVAAnAl8ASQJUACcCXwBJAlQAJwJfAEkCVAAnAl8ASQJUACcDAQAoApIAJwMBACgCkgAnAwEAKAKSACcDAQAoApIAJwL8AEkCaQBCAvwASQJpABQBPv/mASj/3AE+//YBKP/uAT7/8QEo/+YBPgAoASgAFQE+AEYBKABCA0UASQJNADYCEf/9ASv/0ALHAEkCUwBBAlMAQQIOAEkBKgBCAg4ASQEqAAsCDgBJAbAAQgIOAEkBwABCAg4ACQEqAAgDFgBJAmgAQAMWAEkCaABAAxYASQJoAEACwv/3AxYASQJoAEADUwAoAngAJwNTACgCeAAnA1MAKAJ4ACcD+wAoA80AJwKXAEkBjABAApcASQGMAAwClwBJAYwAHwJPAA8B2AALAk8ADwHYAAsCTwAPAdgACwJPAA8B2AALAkUABQF0AAICRQAFAbAAAgJFAAUBdAACAuIAQgJmADsC4gBCAmYAOwLiAEICZgA7AuIAQgJmADsC4gBCAmYAOwLiAEICZgA7BAEAAANnAAACnf/sAjf//wKd/+wCewAnAgAAIgJ7ACcCAAAiAnsAJwIAACIChv/+Ak8ADwHYAAsCRQAFAXQAAgEr/9sBLP/RASz/0QEs/+4BLP/o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BoAGoAbKBvAHOAdKB2gHfgegB7oH0gfqB/wIDAgeCDAIPghMCH4IrAjSCQAJLAlMCYIJogm+CegKAgoOCj4KXgqACrAK3gr8CywLTgtuC4QLpgu+C+IL9gwiDDAMXAyADIAMnAzODPYNNA1YDWwNyA3sDjAOXA52DoYOkg7SDuAPAA8cD0QPeg+ID7QPzA/gEAQQFhA8EFgQiBDCERYRUBFwEZARtBHmEhwSUhJ2ErgS1hL0ExYTShNcE24ThBOsE9oUDBQ4FGQUlBTQFRIVLBVyFZYVuhXiFhwWOhZcFpgW0BcKF0gXlBfkGDIYghjCGPQZJhlcGaQZthnIGd4aBhpCGnoaohrKGvYbMBtuG5Yb0Bv2HBwcRhyCHKwc2h0aHToddB2gHegeFh5eHoweuB7oHxgfTB9+H7Af4CAUIEggdiCqIMgg+iEkIWYhjCHGIfIiMCJSIogivCL8IzgjhCO6I/4kLiRsJI4kuCTWJP4lIiVGJVglaiWIJaolyiX4JhImHiZEJoImrCbSJvQnFCcsJ0QnVidsJ4AnmCeqJ8gn4if8KBQoNChaKHoooCjEKO4pFilAKXApnCnEKfwqNCpmKpQqxisMKzgrXCuIK6wr3CwELFIsiCzaLRQtdC2+LhAuSi5kLowuqi7SLuwvFi9ML4QvqC/OL/4wMjBsMKgw0jD+MTAxYjGOMbox3DIKMj4yXDJ4MpwyvjLgMwAzNDOCM7oz1DP8NBg0KjQ8NEo0ZjR6NJ40ujTaNO41BjU2NWI1hDWiNdY2ADYYNkQ2jDaYNsI24jcWN0I3ZDeIN6g34jf6OBQ4MjhkOHQ4ljisONY5DDkkOVA5bDmMOao5wjnmOfg6GDo+OlA6djqoOsI62jr4Ow47KjtMO3A7jju6O+g8DjxAPII8sDzAPOA9DD0uPWA9eD2iPbo92D32Pgo+Kj48Pmw+kj6kPsg++j8SPyo/Rj9cP3g/mD+8P9hAAEAsQE5AgkDMQQBBGEFCQXJBjEG2QeBCEEI2Ql5CfkKeQtJC6EL6QwpDMkNaQ4JDqkPoRCZERERuRHpEiESWRKZEtkTERNpE8EUGRRxFOEVKRXZFzEXeRfBGKEY4RlhGdEagRsxG3kcaR0ZHZkd4R6BH1kfySBxISEhYSJJIvkj8SUZJfEm4SfRKHkpOSnhKsErIStxK+EsGSxZLKktCS4JLyEwC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AAEECQAKCJQJUQADAAEECQALAC4WMgADAAEECQAMAEoWegADAAEECQANB54W7AADAAEECQAOAD4iXAADAAEECQAQAB4ivABDAG8AcAB5AHIAaQBnAGgAdAAgAKkAIAAyADAAMAAzACAALQAgADIAMAAxADIAIABMAGkAbgBvAHQAeQBwAGUAIABHAG0AYgBIACwAIAB3AHcAdwAuAGwAaQBuAG8AdAB5AHAAZQAuAGMAbwBtAC4AIABBAGwAbAAgAHIAaQBnAGgAdABzACAAcgBlAHMAZQByAHYAZQBkAC4AIABUAGgAaQBzACAAZgBvAG4AdAAgAHMAbwBmAHQAdwBhAHIAZQAgAG0AYQB5ACAAbgBvAHQAIABiAGUAIAByAGUAcAByAG8AZAB1AGMAZQBkACwAIABtAG8AZABpAGYAaQBlAGQALAAgAGQAaQBzAGMAbABvAHMAZQBkACAAbwByACAAdAByAGEAbgBzAGYAZQByAHIAZQBkACAAdwBpAHQAaABvAHUAdAAgAHQAaABlACAAZQB4AHAAcgBlAHMAcwAgAHcAcgBpAHQAdABlAG4AIABhAHAAcAByAG8AdgBhAGwAIABvAGYAIABMAGkAbgBvAHQAeQBwAGUAIABHAG0AYgBIAC4AIABBAHYAZQBuAGkAcgAgAGkAcwAgAGEAIAB0AHIAYQBkAGUAbQBhAHIAawAgAG8AZgAgAEwAaQBuAG8AdAB5AHAAZQAgAEcAbQBiAEgAIAByAGUAZwBpAHMAdABlAHIAZQBkACAAaQBuACAAdABoAGUAIABVAC4AUwAuACAAUABhAHQAZQBuAHQAIABhAG4AZAAgAFQAcgBhAGQAZQBtAGEAcgBrACAATwBmAGYAaQBjAGUAIABhAG4AZAAgAG0AYQB5ACAAYgBlACAAcgBlAGcAaQBzAHQAZQByAGUAZAAgAGkAbgAgAGMAZQByAHQAYQBpAG4AIABvAHQAaABlAHIAIABqAHUAcgBpAHMAZABpAGMAdABpAG8AbgBzAC4AIABUAGgAaQBzACAAdAB5AHAAZQBmAGEAYwBlACAAaQBzACAAbwByAGkAZwBpAG4AYQBsACAAYQByAHQAdwBvAHIAawAgAG8AZgAgAEEAZAByAGkAYQBuACAARgByAHUAdABpAGcAZQByACAAYQBuAGQAIABBAGsAaQByAGEAIABLAG8AYgBhAHkAYQBzAGgAaQAuACAAVABoAGUAIABkAGUAcwBpAGcAbgAgAG0AYQB5ACAAYgBlACAAcAByAG8AdABlAGMAdABlAGQAIABpAG4AIABjAGUAcgB0AGEAaQBuACAAagB1AHIAaQBzAGQAaQBjAHQAaQBvAG4AcwAuAABDb3B5cmlnaHQgqSAyMDAzIC0gMjAxMiBMaW5vdHlwZSBHbWJILCB3d3cubGlub3R5cGUuY29tLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBUaGlzIGZvbnQgc29mdHdhcmUgbWF5IG5vdCBiZSByZXByb2R1Y2VkLCBtb2RpZmllZCwgZGlzY2xvc2VkIG9yIHRyYW5zZmVycmVkIHdpdGhvdXQgdGhlIGV4cHJlc3Mgd3JpdHRlbiBhcHByb3ZhbCBvZiBMaW5vdHlwZSBHbWJILiBBdmVuaXIgaXMgYSB0cmFkZW1hcmsgb2YgTGlub3R5cGUgR21iSCByZWdpc3RlcmVkIGluIHRoZSBVLlMuIFBhdGVudCBhbmQgVHJhZGVtYXJrIE9mZmljZSBhbmQgbWF5IGJlIHJlZ2lzdGVyZWQgaW4gY2VydGFpbiBvdGhlciBqdXJpc2RpY3Rpb25zLiBUaGlzIHR5cGVmYWNlIGlzIG9yaWdpbmFsIGFydHdvcmsgb2YgQWRyaWFuIEZydXRpZ2VyIGFuZCBBa2lyYSBLb2JheWFzaGkuIFRoZSBkZXNpZ24gbWF5IGJlIHByb3RlY3RlZCBpbiBjZXJ0YWluIGp1cmlzZGljdGlvbnMuAABBAHYAZQBuAGkAcgAgAE4AZQB4AHQAIABDAHkAcgAgAE0AZQBkAGkAdQBtAABBdmVuaXIgTmV4dCBDeXIgTWVkaXVtAABCAG8AbABkAABCb2xkAABMAGkAbgBvAHQAeQBwAGUAIABHAG0AYgBIADoAQQB2AGUAbgBpAHIAIABOAGUAeAB0ACAAQwB5AHIAIABCAG8AbABkADoAMgAwADEAMgAATGlub3R5cGUgR21iSDpBdmVuaXIgTmV4dCBDeXIgQm9sZDoyMDEyAABBAHYAZQBuAGkAcgBOAGUAeAB0AEMAeQByAC0AQgBvAGwAZAAAQXZlbmlyTmV4dEN5ci1Cb2xkAABWAGUAcgBzAGkAbwBuACAAMQAuADAAMAAAVmVyc2lvbiAxLjAwAABBAHYAZQBuAGkAcgBOAGUAeAB0AEMAeQByAC0AQgBvAGwAZAAAQXZlbmlyTmV4dEN5ci1Cb2xkAABBAHYAZQBuAGkAcgAgAGkAcwAgAGEAIAB0AHIAYQBkAGUAbQBhAHIAawAgAG8AZgAgAEwAaQBuAG8AdAB5AHAAZQAgAEcAbQBiAEgAIAByAGUAZwBpAHMAdABlAHIAZQBkACAAaQBuACAAdABoAGUAIABVAC4AUwAuACAAUABhAHQAZQBuAHQAIABhAG4AZAAgAFQAcgBhAGQAZQBtAGEAcgBrACAATwBmAGYAaQBjAGUAIABhAG4AZAAgAG0AYQB5ACAAYgBlACAAcgBlAGcAaQBzAHQAZQByAGUAZAAgAGkAbgAgAGMAZQByAHQAYQBpAG4AIABvAHQAaABlAHIAIABqAHUAcgBpAHMAZABpAGMAdABpAG8AbgBzAC4AAEF2ZW5pciBpcyBhIHRyYWRlbWFyayBvZiBMaW5vdHlwZSBHbWJIIHJlZ2lzdGVyZWQgaW4gdGhlIFUuUy4gUGF0ZW50IGFuZCBUcmFkZW1hcmsgT2ZmaWNlIGFuZCBtYXkgYmUgcmVnaXN0ZXJlZCBpbiBjZXJ0YWluIG90aGVyIGp1cmlzZGljdGlvbnMuAABMAGkAbgBvAHQAeQBwAGUAIABHAG0AYgBIAABMaW5vdHlwZSBHbWJIAABBAGQAcgBpAGEAbgAgAEYAcgB1AHQAaQBnAGUAcgAgAGEAbgBkACAAQQBrAGkAcgBhACAASwBvAGIAYQB5AGEAcwBoAGkAAEFkcmlhbiBGcnV0aWdlciBhbmQgQWtpcmEgS29iYXlhc2hpAABBAGQAcgBpAGEAbgAgAEYAcgB1AHQAaQBnAGUAcgAgAGQAZQBzAGkAZwBuAGUAZAAgAEEAdgBlAG4AaQByACAAaQBuACAAMQA5ADgAOAAsACAAYQBmAHQAZQByACAAeQBlAGEAcgBzACAAbwBmACAAaABhAHYAaQBuAGcAIABhAG4AIABpAG4AdABlAHIAZQBzAHQAIABpAG4AIABzAGEAbgBzACAAcwBlAHIAaQBmACAAdAB5AHAAZQBmAGEAYwBlAHMALgAgAEkAbgAgAGEAbgAgAGkAbgB0AGUAcgB2AGkAZQB3ACAAdwBpAHQAaAAgAEwAaQBuAG8AdAB5AHAAZQAsACAAaABlACAAcwBhAGkAZAAgAGgAZQAgAGYAZQBsAHQAIABhAG4AIABvAGIAbABpAGcAYQB0AGkAbwBuACAAdABvACAAZABlAHMAaQBnAG4AIABhACAAbABpAG4AZQBhAHIAIABzAGEAbgBzACAAaQBuACAAdABoAGUAIAB0AHIAYQBkAGkAdABpAG8AbgAgAG8AZgAgAEUAcgBiAGEAcgAgAGEAbgBkACAARgB1AHQAdQByAGEALAAgAGIAdQB0ACAAdABvACAAYQBsAHMAbwAgAG0AYQBrAGUAIAB1AHMAZQAgAG8AZgAgAHQAaABlACAAZQB4AHAAZQByAGkAZQBuAGMAZQAgAGEAbgBkACAAcwB0AHkAbABpAHMAdABpAGMAIABkAGUAdgBlAGwAbwBwAG0AZQBuAHQAcwAgAG8AZgAgAHQAaABlACAAdAB3AGUAbgB0AGkAZQB0AGgAIABjAGUAbgB0AHUAcgB5AC4AIABUAGgAZQAgAHcAbwByAGQAIABBAHYAZQBuAGkAcgAgAG0AZQBhAG4AcwAgACcAZgB1AHQAdQByAGUAJwAgAGkAbgAgAEYAcgBlAG4AYwBoACAAYQBuAGQAIABoAGkAbgB0AHMAIAB0AGgAYQB0ACAAdABoAGUAIAB0AHkAcABlAGYAYQBjAGUAIABvAHcAZQBzACAAcwBvAG0AZQAgAG8AZgAgAGkAdABzACAAaQBuAHQAZQByAHAAcgBlAHQAYQB0AGkAbwBuACAAdABvACAARgB1AHQAdQByAGEALgAgAEIAdQB0ACAAdQBuAGwAaQBrAGUAIABGAHUAdAB1AHIAYQAsACAAQQB2AGUAbgBpAHIAIABpAHMAIABuAG8AdAAgAHAAdQByAGUAbAB5ACAAZwBlAG8AbQBlAHQAcgBpAGMAOwAgAGkAdAAgAGgAYQBzACAAdgBlAHIAdABpAGMAYQBsACAAcwB0AHIAbwBrAGUAcwAgAHQAaABhAHQAIABhAHIAZQAgAHQAaABpAGMAawBlAHIAIAB0AGgAYQBuACAAdABoAGUAIABoAG8AcgBpAHoAbwBuAHQAYQBsAHMALAAgAGEAbgAgACIAbwAiACAAdABoAGEAdAAgAGkAcwAgAG4AbwB0ACAAYQAgAHAAZQByAGYAZQBjAHQAIABjAGkAcgBjAGwAZQAsACAAYQBuAGQAIABzAGgAbwByAHQAZQBuAGUAZAAgAGEAcwBjAGUAbgBkAGUAcgBzAC4AIABUAGgAZQBzAGUAIABuAHUAYQBuAGMAZQBzACAAYQBpAGQAIABpAG4AIABsAGUAZwBpAGIAaQBsAGkAdAB5ACAAYQBuAGQAIABnAGkAdgBlACAAQQB2AGUAbgBpAHIAIABhACAAaABhAHIAbQBvAG4AaQBvAHUAcwAgAGEAbgBkACAAcwBlAG4AcwBpAGIAbABlACAAYQBwAHAAZQBhAHIAYQBuAGMAZQAgAGYAbwByACAAYgBvAHQAaAAgAHQAZQB4AHQAcwAgAGEAbgBkACAAaABlAGEAZABsAGkAbgBlAHMALgAgAEkAbgAgADIAMAAwADQAIABBAGQAcgBpAGEAbgAgAEYAcgB1AHQAaQBnAGUAcgAgAGEAbgBkACAAdABoAGUAIAB0AHkAcABlACAAZABpAHIAZQBjAHQAbwByACAAbwBmACAATABpAG4AbwB0AHkAcABlACAARwBtAGIASAAgAEEAawBpAHIAYQAgAEsAbwBiAGEAeQBhAHMAaABpACAAcgBlAHcAbwByAGsAZQBkACAAdABoAGUAIABBAHYAZQBuAGkAcgAgAGEAbgBkACAAYwByAGUAYQB0AGUAZAAgAHQAaABlACAAQQB2AGUAbgBpAHIAIABOAGUAeAB0ACAAZgBvAHIAIAB0AGgAZQAgAFAAbABhAHQAaQBuAHUAbQAgAEMAbwBsAGwAZQBjAHQAaQBvAG4ALgAgAEkAdAAgAGkAbgBjAGwAdQBkAGUAcwAgAG4AZQB3ACAAcwBtAGEAbABsACAAYwBhAHAAcwAsACAAbgBlAHcAbAB5ACAAZABlAHMAaQBnAG4AZQBkACAAdAByAHUAZQAgAGkAdABhAGwAaQBjAHMALAAgAGEAbgBkACAAYQAgAGMAbwBtAHAAbABlAHQAZQAgAG4AZQB3ACAAcgBhAG4AZwBlACAAbwBmACAAYwBvAG4AZABlAG4AcwBlAGQAIAB3AGUAaQBnAGgAdABzAC4AIABBAHYAZQBuAGkAcgAgAE4AZQB4AHQAIABpAHMAIABhACAAdgBlAHIAcwBhAHQAaQBsAGUAIABzAGEAbgBzACAAcwBlAHIAaQBmACAAZgBhAG0AaQBsAHkALAAgAHIAZQBhAGQAeQAgAGYAbwByACAAbABhAHIAZwBlACAAYQBuAGQAIABjAG8AbQBwAGwAZQB4ACAAcAByAG8AagBlAGMAdABzACAAZgByAG8AbQAgAGIAbwBvAGsAcwAgAHQAbwAgAHMAaQBnAG4AYQBnAGUAIAB0AG8AIABhAGQAdgBlAHIAdABpAHMAaQBuAGcALgAAQWRyaWFuIEZydXRpZ2VyIGRlc2lnbmVkIEF2ZW5pciBpbiAxOTg4LCBhZnRlciB5ZWFycyBvZiBoYXZpbmcgYW4gaW50ZXJlc3QgaW4gc2FucyBzZXJpZiB0eXBlZmFjZXMuIEluIGFuIGludGVydmlldyB3aXRoIExpbm90eXBlLCBoZSBzYWlkIGhlIGZlbHQgYW4gb2JsaWdhdGlvbiB0byBkZXNpZ24gYSBsaW5lYXIgc2FucyBpbiB0aGUgdHJhZGl0aW9uIG9mIEVyYmFyIGFuZCBGdXR1cmEsIGJ1dCB0byBhbHNvIG1ha2UgdXNlIG9mIHRoZSBleHBlcmllbmNlIGFuZCBzdHlsaXN0aWMgZGV2ZWxvcG1lbnRzIG9mIHRoZSB0d2VudGlldGggY2VudHVyeS4gVGhlIHdvcmQgQXZlbmlyIG1lYW5zICdmdXR1cmUnIGluIEZyZW5jaCBhbmQgaGludHMgdGhhdCB0aGUgdHlwZWZhY2Ugb3dlcyBzb21lIG9mIGl0cyBpbnRlcnByZXRhdGlvbiB0byBGdXR1cmEuIEJ1dCB1bmxpa2UgRnV0dXJhLCBBdmVuaXIgaXMgbm90IHB1cmVseSBnZW9tZXRyaWM7IGl0IGhhcyB2ZXJ0aWNhbCBzdHJva2VzIHRoYXQgYXJlIHRoaWNrZXIgdGhhbiB0aGUgaG9yaXpvbnRhbHMsIGFuICJvIiB0aGF0IGlzIG5vdCBhIHBlcmZlY3QgY2lyY2xlLCBhbmQgc2hvcnRlbmVkIGFzY2VuZGVycy4gVGhlc2UgbnVhbmNlcyBhaWQgaW4gbGVnaWJpbGl0eSBhbmQgZ2l2ZSBBdmVuaXIgYSBoYXJtb25pb3VzIGFuZCBzZW5zaWJsZSBhcHBlYXJhbmNlIGZvciBib3RoIHRleHRzIGFuZCBoZWFkbGluZXMuIEluIDIwMDQgQWRyaWFuIEZydXRpZ2VyIGFuZCB0aGUgdHlwZSBkaXJlY3RvciBvZiBMaW5vdHlwZSBHbWJIIEFraXJhIEtvYmF5YXNoaSByZXdvcmtlZCB0aGUgQXZlbmlyIGFuZCBjcmVhdGVkIHRoZSBBdmVuaXIgTmV4dCBmb3IgdGhlIFBsYXRpbnVtIENvbGxlY3Rpb24uIEl0IGluY2x1ZGVzIG5ldyBzbWFsbCBjYXBzLCBuZXdseSBkZXNpZ25lZCB0cnVlIGl0YWxpY3MsIGFuZCBhIGNvbXBsZXRlIG5ldyByYW5nZSBvZiBjb25kZW5zZWQgd2VpZ2h0cy4gQXZlbmlyIE5leHQgaXMgYSB2ZXJzYXRpbGUgc2FucyBzZXJpZiBmYW1pbHksIHJlYWR5IGZvciBsYXJnZSBhbmQgY29tcGxleCBwcm9qZWN0cyBmcm9tIGJvb2tzIHRvIHNpZ25hZ2UgdG8gYWR2ZXJ0aXNpbmcuAABoAHQAdABwADoALwAvAHcAdwB3AC4AbABpAG4AbwB0AHkAcABlAC4AYwBvAG0AAGh0dHA6Ly93d3cubGlub3R5cGUuY29tAABoAHQAdABwADoALwAvAHcAdwB3AC4AbABpAG4AbwB0AHkAcABlAC4AYwBvAG0ALwBmAG8AbgB0AGQAZQBzAGkAZwBuAGUAcgBzAABodHRwOi8vd3d3Lmxpbm90eXBlLmNvbS9mb250ZGVzaWduZXJzAABOAE8AVABJAEYASQBDAEEAVABJAE8ATgAgAE8ARgAgAEwASQBDAEUATgBTAEUAIABBAEcAUgBFAEUATQBFAE4AVAANAAoADQAKAFkAbwB1ACAAaABhAHYAZQAgAG8AYgB0AGEAaQBuAGUAZAAgAHQAaABpAHMAIABmAG8AbgB0ACAAcwBvAGYAdAB3AGEAcgBlACAAZQBpAHQAaABlAHIAIABkAGkAcgBlAGMAdABsAHkAIABmAHIAbwBtACAATABpAG4AbwB0AHkAcABlACAARwBtAGIASAAgAG8AcgAgAHQAbwBnAGUAdABoAGUAcgAgAHcAaQB0AGgAIABzAG8AZgB0AHcAYQByAGUAIABkAGkAcwB0AHIAaQBiAHUAdABlAGQAIABiAHkAIABvAG4AZQAgAG8AZgAgAEwAaQBuAG8AdAB5AHAAZQAnAHMAIABsAGkAYwBlAG4AcwBlAGUAcwAuAA0ACgANAAoAVABoAGkAcwAgAGYAbwBuAHQAIABzAG8AZgB0AHcAYQByAGUAIABpAHMAIABhACAAdgBhAGwAdQBhAGIAbABlACAAYQBzAHMAZQB0ACAAbwBmACAATABpAG4AbwB0AHkAcABlACAARwBtAGIASAAuACAAVQBuAGwAZQBzAHMAIAB5AG8AdQAgAGgAYQB2AGUAIABlAG4AdABlAHIAZQBkACAAaQBuAHQAbwAgAGEAIABzAHAAZQBjAGkAZgBpAGMAIABsAGkAYwBlAG4AcwBlACAAYQBnAHIAZQBlAG0AZQBuAHQAIABnAHIAYQBuAHQAaQBuAGcAIAB5AG8AdQAgAGEAZABkAGkAdABpAG8AbgBhAGwAIAByAGkAZwBoAHQAcwAsACAAeQBvAHUAcgAgAHUAcwBlACAAbwBmACAAdABoAGkAcwAgAGYAbwBuAHQAIABzAG8AZgB0AHcAYQByAGUAIABpAHMAIABsAGkAbQBpAHQAZQBkACAAdABvACAAeQBvAHUAcgAgAHcAbwByAGsAcwB0AGEAdABpAG8AbgAgAGYAbwByACAAeQBvAHUAcgAgAG8AdwBuACAAdQBzAGUALgAgAFkAbwB1ACAAbQBhAHkAIABuAG8AdAAgAGMAbwBwAHkAIABvAHIAIABkAGkAcwB0AHIAaQBiAHUAdABlACAAdABoAGkAcwAgAGYAbwBuAHQAIABzAG8AZgB0AHcAYQByAGUALgAgAEkAZgAgAHkAbwB1ACAAaABhAHYAZQAgAGEAbgB5ACAAcQB1AGUAcwB0AGkAbwBuAHMAIAByAGUAZwBhAHIAZABpAG4AZwAgAHkAbwB1AHIAIABsAGkAYwBlAG4AcwBlACAAdABlAHIAbQBzACwAIABwAGwAZQBhAHMAZQAgAHIAZQB2AGkAZQB3ACAAdABoAGUAIABsAGkAYwBlAG4AcwBlACAAYQBnAHIAZQBlAG0AZQBuAHQAIAB5AG8AdQAgAHIAZQBjAGUAaQB2AGUAZAAgAHcAaQB0AGgAIAB0AGgAZQAgAHMAbwBmAHQAdwBhAHIAZQAuAA0ACgANAAoARwBlAG4AZQByAGEAbAAgAGwAaQBjAGUAbgBzAGUAIAB0AGUAcgBtAHMAIABhAG4AZAAgAHUAcwBhAGcAZQAgAHIAaQBnAGgAdABzACAAYwBhAG4AIABiAGUAIAB2AGkAZQB3AGUAZAAgAGEAdAAgAHcAdwB3AC4AbABpAG4AbwB0AHkAcABlAC4AYwBvAG0ALwBsAGkAYwBlAG4AcwBlAC4ADQAKAA0ACgBHAGUAbgBlAHIAZQBsAGwAZQAgAEwAaQB6AGUAbgB6AGIAZQBkAGkAbgBnAHUAbgBnAGUAbgAgAHUAbgBkACAATgB1AHQAegB1AG4AZwBzAHIAZQBjAGgAdABlACAAZgBpAG4AZABlAG4AIABTAGkAZQAgAHUAbgB0AGUAcgAgAHcAdwB3AC4AbABpAG4AbwB0AHkAcABlAC4AYwBvAG0ALwBsAGkAYwBlAG4AcwBlAC4ADQAKAA0ACgBQAG8AdQByACAAcABsAHUAcwAgAGQAJwBpAG4AZgBvAHIAbQBhAHQAaQBvAG4AcwAgAGMAbwBuAGMAZQByAG4AYQBuAHQAIABsAGUAIABjAG8AbgB0AHIAYQB0ACAAZAAnAHUAdABpAGwAaQBzAGEAdABpAG8AbgAgAGQAdQAgAGwAbwBnAGkAYwBpAGUAbAAgAGQAZQAgAHAAbwBsAGkAYwBlAHMALAAgAHYAZQB1AGkAbABsAGUAegAgAGMAbwBuAHMAdQBsAHQAZQByACAAbgBvAHQAcgBlACAAcwBpAHQAZQAgAHcAZQBiACAAdwB3AHcALgBsAGkAbgBvAHQAeQBwAGUALgBjAG8AbQAvAGwAaQBjAGUAbgBzAGUALgANAAoADQAKAEwAaQBuAG8AdAB5AHAAZQAgAEcAbQBiAEgAIABjAGEAbgAgAGIAZQAgAGMAbwBuAHQAYQBjAHQAZQBkACAAYQB0ADoADQAKAA0ACgBUAGUAbAAuADoAIAArADQAOQAoADAAKQA2ADEANwAyACAANAA4ADQALQA0ADEAOAAATk9USUZJQ0FUSU9OIE9GIExJQ0VOU0UgQUdSRUVNRU5UDQoNCllvdSBoYXZlIG9idGFpbmVkIHRoaXMgZm9udCBzb2Z0d2FyZSBlaXRoZXIgZGlyZWN0bHkgZnJvbSBMaW5vdHlwZSBHbWJIIG9yIHRvZ2V0aGVyIHdpdGggc29mdHdhcmUgZGlzdHJpYnV0ZWQgYnkgb25lIG9mIExpbm90eXBlJ3MgbGljZW5zZWVzLg0KDQpUaGlzIGZvbnQgc29mdHdhcmUgaXMgYSB2YWx1YWJsZSBhc3NldCBvZiBMaW5vdHlwZSBHbWJILiBVbmxlc3MgeW91IGhhdmUgZW50ZXJlZCBpbnRvIGEgc3BlY2lmaWMgbGljZW5zZSBhZ3JlZW1lbnQgZ3JhbnRpbmcgeW91IGFkZGl0aW9uYWwgcmlnaHRzLCB5b3VyIHVzZSBvZiB0aGlzIGZvbnQgc29mdHdhcmUgaXMgbGltaXRlZCB0byB5b3VyIHdvcmtzdGF0aW9uIGZvciB5b3VyIG93biB1c2UuIFlvdSBtYXkgbm90IGNvcHkgb3IgZGlzdHJpYnV0ZSB0aGlzIGZvbnQgc29mdHdhcmUuIElmIHlvdSBoYXZlIGFueSBxdWVzdGlvbnMgcmVnYXJkaW5nIHlvdXIgbGljZW5zZSB0ZXJtcywgcGxlYXNlIHJldmlldyB0aGUgbGljZW5zZSBhZ3JlZW1lbnQgeW91IHJlY2VpdmVkIHdpdGggdGhlIHNvZnR3YXJlLg0KDQpHZW5lcmFsIGxpY2Vuc2UgdGVybXMgYW5kIHVzYWdlIHJpZ2h0cyBjYW4gYmUgdmlld2VkIGF0IHd3dy5saW5vdHlwZS5jb20vbGljZW5zZS4NCg0KR2VuZXJlbGxlIExpemVuemJlZGluZ3VuZ2VuIHVuZCBOdXR6dW5nc3JlY2h0ZSBmaW5kZW4gU2llIHVudGVyIHd3dy5saW5vdHlwZS5jb20vbGljZW5zZS4NCg0KUG91ciBwbHVzIGQnaW5mb3JtYXRpb25zIGNvbmNlcm5hbnQgbGUgY29udHJhdCBkJ3V0aWxpc2F0aW9uIGR1IGxvZ2ljaWVsIGRlIHBvbGljZXMsIHZldWlsbGV6IGNvbnN1bHRlciBub3RyZSBzaXRlIHdlYiB3d3cubGlub3R5cGUuY29tL2xpY2Vuc2UuDQoNCkxpbm90eXBlIEdtYkggY2FuIGJlIGNvbnRhY3RlZCBhdDoNCg0KVGVsLjogKzQ5KDApNjE3MiA0ODQtNDE4AABoAHQAdABwADoALwAvAHcAdwB3AC4AbABpAG4AbwB0AHkAcABlAC4AYwBvAG0ALwBsAGkAYwBlAG4AcwBlAABodHRwOi8vd3d3Lmxpbm90eXBlLmNvbS9saWNlbnNlAABBAHYAZQBuAGkAcgAgAE4AZQB4AHQAIABDAHkAcgAAQXZlbmlyIE5leHQgQ3lyAAAAAAIAAAAAAAD/UQAyAAAAAAAAAAAAAAAAAAAAAAAAAAAC2wAAAAEAAgECAAMABAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwAPQA+AD8AQABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQEDAKMAhACFAL0AlgDoAIYAjgCLAJ0AqQCkAQQAigDaAIMAkwDyAPMAjQCXAIgAwwDeAPEAngCqAPUA9AD2AKIArQDJAMcArgBiAGMAkABkAMsAZQDIAMoAzwDMAM0AzgDpAGYA0wDQANEArwBnAPAAkQDWANQA1QBoAOsA7QCJAGoAaQBrAG0AbABuAKAAbwBxAHAAcgBzAHUAdAB2AHcA6gB4AHoAeQB7AH0AfAC4AKEAfwB+AIAAgQDsAO4AugEFAQYBBwEIAQkBCgD9AP4BCwEMAQ0BDgD/AQABDwEQAREBAQESARMBFAEVARYBFwEYARkBGgEbARwBHQD4APkBHgEfASABIQEiASMBJAElASYBJwEoASkBKgErASwBLQD6ANcBLgEvATABMQEyATMBNAE1ATYBNwE4ATkBOgE7ATwA4gDjAT0BPgE/AUABQQFCAUMBRAFFAUYBRwFIAUkBSgFLALAAsQFMAU0BTgFPAVABUQFSAVMBVAFVAPsA/ADkAOUBVgFXAVgBWQFaAVsBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAWoBawC7AWwBbQFuAW8A5gDnAKYBcAFxAXIBcwF0ANgA4QF1ANsA3ADdAOAA2QDfAXYBdwF4AJsBeQF6AXsBfAF9AX4BfwGAAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAdUB1gHXAdgB2QHaAdsB3AHdAd4B3wHgAeEB4gHjALIAswC2ALcAxAC0ALUAxQCCAMIAhwCrAMYAvgC/AeQAvAHlAeYB5wHoAekB6gHrAewB7QHuAe8B8AHxAfIB8wH0AfUB9gH3AfgB+QH6AIwAnwH7AJgAqACaAJkA7wH8Af0ApQCSAJwApwCPAJQAlQC5Af4B/wIAAgEAwADBAgICAwIEAgUCBgIHAggCCQIKAgsCDAINAg4CDwIQAhECEgITAhQCFQIWAhcCGAIZAhoCGwIcAh0CHgIfAiACIQIiAiMCJAIlAiYCJwIoAikCKgIrAiwCLQIuAi8CMAIxAjICMwI0AjUCNgI3AjgCOQI6AjsCPAI9Aj4CPwJAAkECQgJDAkQCRQJGAkcCSAJJAkoCSwJMAk0CTgJPAlACUQJSAlMCVAJVAlYCVwJYAlkCWgJbAlwCXQJeAl8CYAJhAmICYwJkAmUCZgJnAmgCaQJqAmsCbAJtAm4CbwJwAnECcgJzAnQCdQJ2AncCeAJ5AnoCewJ8An0CfgJ/AoACgQKCAoMChAKFAoYChwKIAokCigKLAowCjQKOAo8CkAKRApICkwKUApUClgKXApgCmQKaApsCnAKdAp4CnwKgAqECogKjAqQCpQKmAqcCqAKpAqoCqwKsAq0CrgKvArACsQKyArMCtAK1ArYCtwK4ArkCugK7ArwCvQK+Ar8CwALBAsICwwLEAsUCxgLHAsgCyQLKAssCzALNAs4CzwLQAtEC0gLTAtQC1QLWAtcC2ALZAtoC2wLcAt0CQ1IHdW5pMDBBMAd1bmkwMEFEB0FtYWNyb24HYW1hY3JvbgZBYnJldmUGYWJyZXZlB0FvZ29uZWsHYW9nb25lawtDY2lyY3VtZmxleAtjY2lyY3VtZmxleApDZG90YWNjZW50CmNkb3RhY2NlbnQGRGNhcm9uBmRjYXJvbgZEY3JvYXQHRW1hY3JvbgdlbWFjcm9uBkVicmV2ZQZlYnJldmUKRWRvdGFjY2VudAplZG90YWNjZW50B0VvZ29uZWsHZW9nb25lawZFY2Fyb24GZWNhcm9uC0djaXJjdW1mbGV4C2djaXJjdW1mbGV4Ckdkb3RhY2NlbnQKZ2RvdGFjY2VudAxHY29tbWFhY2NlbnQMZ2NvbW1hYWNjZW50C0hjaXJjdW1mbGV4C2hjaXJjdW1mbGV4BEhiYXIEaGJhcgZJdGlsZGUGaXRpbGRlB0ltYWNyb24HaW1hY3JvbgZJYnJldmUGaWJyZXZlB0lvZ29uZWsHaW9nb25lawJJSgJpagtKY2lyY3VtZmxleAtqY2lyY3VtZmxleAxLY29tbWFhY2NlbnQMa2NvbW1hYWNjZW50DGtncmVlbmxhbmRpYwZMYWN1dGUGbGFjdXRlDExjb21tYWFjY2VudAxsY29tbWFhY2NlbnQGTGNhcm9uBmxjYXJvbgRMZG90BGxkb3QGTmFjdXRlBm5hY3V0ZQxOY29tbWFhY2NlbnQMbmNvbW1hYWNjZW50Bk5jYXJvbgZuY2Fyb24LbmFwb3N0cm9waGUDRW5nA2VuZwdPbWFjcm9uB29tYWNyb24GT2JyZXZlBm9icmV2ZQ1PaHVuZ2FydW1sYXV0DW9odW5nYXJ1bWxhdXQGUmFjdXRlBnJhY3V0ZQxSY29tbWFhY2NlbnQMcmNvbW1hYWNjZW50BlJjYXJvbgZyY2Fyb24GU2FjdXRlBnNhY3V0ZQtTY2lyY3VtZmxleAtzY2lyY3VtZmxleAd1bmkwMTYyB3VuaTAxNjMGVGNhcm9uBnRjYXJvbgRUYmFyBHRiYXIGVXRpbGRlBnV0aWxkZQdVbWFjcm9uB3VtYWNyb24GVWJyZXZlBnVicmV2ZQVVcmluZwV1cmluZw1VaHVuZ2FydW1sYXV0DXVodW5nYXJ1bWxhdXQHVW9nb25lawd1b2dvbmVrC1djaXJjdW1mbGV4C3djaXJjdW1mbGV4C1ljaXJjdW1mbGV4C3ljaXJjdW1mbGV4BlphY3V0ZQZ6YWN1dGUKWmRvdGFjY2VudAp6ZG90YWNjZW50DFNjb21tYWFjY2VudAxzY29tbWFhY2NlbnQHdW5pMDIxQQd1bmkwMjFCCGRvdGxlc3NqB3VuaTAyQzkHdW5pMDM5NAd1bmkwM0E5B3VuaTAzQkMHdW5pMDQwMAd1bmkwNDAxB3VuaTA0MDIHdW5pMDQwMwd1bmkwNDA0B3VuaTA0MDUHdW5pMDQwNgd1bmkwNDA3B3VuaTA0MDgHdW5pMDQwOQd1bmkwNDBBB3VuaTA0MEIHdW5pMDQwQwd1bmkwNDBEB3VuaTA0MEUHdW5pMDQwRgd1bmkwNDEwB3VuaTA0MTEHdW5pMDQxMgd1bmkwNDEzB3VuaTA0MTQHdW5pMDQxNQd1bmkwNDE2B3VuaTA0MTcHdW5pMDQxOAd1bmkwNDE5B3VuaTA0MUEHdW5pMDQxQgd1bmkwNDFDB3VuaTA0MUQHdW5pMDQxRQd1bmkwNDFGB3VuaTA0MjAHdW5pMDQyMQd1bmkwNDIyB3VuaTA0MjMHdW5pMDQyNAd1bmkwNDI1B3VuaTA0MjYHdW5pMDQyNwd1bmkwNDI4B3VuaTA0MjkHdW5pMDQyQQd1bmkwNDJCB3VuaTA0MkMHdW5pMDQyRAd1bmkwNDJFB3VuaTA0MkYHdW5pMDQzMAd1bmkwNDMxB3VuaTA0MzIHdW5pMDQzMwd1bmkwNDM0B3VuaTA0MzUHdW5pMDQzNgd1bmkwNDM3B3VuaTA0MzgHdW5pMDQzOQd1bmkwNDNBB3VuaTA0M0IHdW5pMDQzQwd1bmkwNDNEB3VuaTA0M0UHdW5pMDQzRgd1bmkwNDQwB3VuaTA0NDEHdW5pMDQ0Mgd1bmkwNDQzB3VuaTA0NDQHdW5pMDQ0NQd1bmkwNDQ2B3VuaTA0NDcHdW5pMDQ0OAd1bmkwNDQ5B3VuaTA0NEEHdW5pMDQ0Qgd1bmkwNDRDB3VuaTA0NEQHdW5pMDQ0RQd1bmkwNDRGB3VuaTA0NTAHdW5pMDQ1MQd1bmkwNDUyB3VuaTA0NTMHdW5pMDQ1NAd1bmkwNDU1B3VuaTA0NTYHdW5pMDQ1Nwd1bmkwNDU4B3VuaTA0NTkHdW5pMDQ1QQd1bmkwNDVCB3VuaTA0NUMHdW5pMDQ1RAd1bmkwNDVFB3VuaTA0NUYHdW5pMDQ5MAd1bmkwNDkxBldncmF2ZQZ3Z3JhdmUGV2FjdXRlBndhY3V0ZQlXZGllcmVzaXMJd2RpZXJlc2lzBllncmF2ZQZ5Z3JhdmUHdW5pMjAxMAtpbnRlcnJvYmFuZw16ZXJvLnN1cGVyaW9yDWZvdXIuc3VwZXJpb3INZml2ZS5zdXBlcmlvcgxzaXguc3VwZXJpb3IOc2V2ZW4uc3VwZXJpb3IOZWlnaHQuc3VwZXJpb3INbmluZS5zdXBlcmlvcg16ZXJvLmluZmVyaW9yDG9uZS5pbmZlcmlvcgx0d28uaW5mZXJpb3IOdGhyZWUuaW5mZXJpb3INZm91ci5pbmZlcmlvcg1maXZlLmluZmVyaW9yDHNpeC5pbmZlcmlvcg5zZXZlbi5pbmZlcmlvcg5laWdodC5pbmZlcmlvcg1uaW5lLmluZmVyaW9yBEV1cm8JYWZpaTYxMjQ4CWFmaWk2MTI4OQd1bmkyMTE2CXB1Ymxpc2hlZAllc3RpbWF0ZWQHdW5pMjIxNQd1bmkyMjE5A2ZfaQNmX2wHdW5pRjhGRgNmX2YFZl9mX2kFZl9mX2wJZ3JhdmUuY2FwCWFjdXRlLmNhcA5jaXJjdW1mbGV4LmNhcAljYXJvbi5jYXAJY2Fyb24uYWx0CXRpbGRlLmNhcAxkaWVyZXNpcy5jYXAKbWFjcm9uLmNhcAlicmV2ZS5jYXAIcmluZy5jYXAQaHVuZ2FydW1sYXV0LmNhcA1kb3RhY2NlbnQuY2FwC2NvbW1hYWNjZW50D2NvbW1hYWNjZW50LmFsdBB6ZXJvLmRlbm9taW5hdG9yD29uZS5kZW5vbWluYXRvcg90d28uZGVub21pbmF0b3IRdGhyZWUuZGVub21pbmF0b3IQZm91ci5kZW5vbWluYXRvchBmaXZlLmRlbm9taW5hdG9yD3NpeC5kZW5vbWluYXRvchFzZXZlbi5kZW5vbWluYXRvchFlaWdodC5kZW5vbWluYXRvchBuaW5lLmRlbm9taW5hdG9yDnplcm8ubnVtZXJhdG9yDW9uZS5udW1lcmF0b3INdHdvLm51bWVyYXRvcg90aHJlZS5udW1lcmF0b3IOZm91ci5udW1lcmF0b3IOZml2ZS5udW1lcmF0b3INc2l4Lm51bWVyYXRvcg9zZXZlbi5udW1lcmF0b3IPZWlnaHQubnVtZXJhdG9yDm5pbmUubnVtZXJhdG9yCGN5cmJyZXZlDGN5cmJyZXZlLmNhcAlleGNsYW0uc2MJZG9sbGFyLnNjCnBlcmNlbnQuc2MMYW1wZXJzYW5kLnNjDHBhcmVubGVmdC5zYw1wYXJlbnJpZ2h0LnNjDmJyYWNrZXRsZWZ0LnNjDGJhY2tzbGFzaC5zYw9icmFja2V0cmlnaHQuc2MMYnJhY2VsZWZ0LnNjCHNsYXNoLnNjDWJyYWNlcmlnaHQuc2MHemVyby5zYwZvbmUuc2MGdHdvLnNjCHRocmVlLnNjB2ZvdXIuc2MHZml2ZS5zYwZzaXguc2MIc2V2ZW4uc2MIZWlnaHQuc2MHbmluZS5zYwtxdWVzdGlvbi5zYwRhLnNjBGIuc2MEYy5zYwRkLnNjBGUuc2MEZi5zYwRnLnNjBGguc2MEaS5zYwRqLnNjBGsuc2MEbC5zYwRtLnNjBG4uc2MEby5zYwRwLnNjBHEuc2MEci5zYwRzLnNjBHQuc2MEdS5zYwR2LnNjBHcuc2MEeC5zYwR5LnNjBHouc2MJYWdyYXZlLnNjCWFhY3V0ZS5zYw5hY2lyY3VtZmxleC5zYwlhdGlsZGUuc2MMYWRpZXJlc2lzLnNjCmFtYWNyb24uc2MJYWJyZXZlLnNjCGFyaW5nLnNjCmFvZ29uZWsuc2MFYWUuc2MJY2FjdXRlLnNjDmNjaXJjdW1mbGV4LnNjCWNjYXJvbi5zYw1jZG90YWNjZW50LnNjC2NjZWRpbGxhLnNjCWRjYXJvbi5zYwlkY3JvYXQuc2MGZXRoLnNjCWVncmF2ZS5zYwllYWN1dGUuc2MOZWNpcmN1bWZsZXguc2MJZWNhcm9uLnNjDGVkaWVyZXNpcy5zYwplbWFjcm9uLnNjCWVicmV2ZS5zYw1lZG90YWNjZW50LnNjCmVvZ29uZWsuc2MOZ2NpcmN1bWZsZXguc2MJZ2JyZXZlLnNjDWdkb3RhY2NlbnQuc2MPZ2NvbW1hYWNjZW50LnNjD2tncmVlbmxhbmRpYy5zYw5oY2lyY3VtZmxleC5zYwdoYmFyLnNjCWlncmF2ZS5zYwlpYWN1dGUuc2MJaWJyZXZlLnNjDmljaXJjdW1mbGV4LnNjCWl0aWxkZS5zYwxpZGllcmVzaXMuc2MKaW1hY3Jvbi5zYw1pZG90YWNjZW50LnNjCmlvZ29uZWsuc2MOamNpcmN1bWZsZXguc2MPa2NvbW1hYWNjZW50LnNjCWxhY3V0ZS5zYwlsY2Fyb24uc2MPbGNvbW1hYWNjZW50LnNjCWxzbGFzaC5zYwdsZG90LnNjCW5hY3V0ZS5zYwluY2Fyb24uc2MJbnRpbGRlLnNjD25jb21tYWFjY2VudC5zYwlvZ3JhdmUuc2MJb2FjdXRlLnNjDm9jaXJjdW1mbGV4LnNjCW90aWxkZS5zYwxvZGllcmVzaXMuc2MKb21hY3Jvbi5zYwlvYnJldmUuc2MQb2h1bmdhcnVtbGF1dC5zYwlvc2xhc2guc2MFb2Uuc2MJcmFjdXRlLnNjCXJjYXJvbi5zYw9yY29tbWFhY2NlbnQuc2MJc2FjdXRlLnNjDnNjaXJjdW1mbGV4LnNjCXNjYXJvbi5zYwtzY2VkaWxsYS5zYw9zY29tbWFhY2NlbnQuc2MJdGNhcm9uLnNjD3Rjb21tYWFjY2VudC5zYwd0YmFyLnNjCHRob3JuLnNjCXVncmF2ZS5zYwl1YWN1dGUuc2MOdWNpcmN1bWZsZXguc2MJdXRpbGRlLnNjDHVkaWVyZXNpcy5zYwp1bWFjcm9uLnNjCXVicmV2ZS5zYwh1cmluZy5zYxB1aHVuZ2FydW1sYXV0LnNjCnVvZ29uZWsuc2MJd2FjdXRlLnNjDndjaXJjdW1mbGV4LnNjDHdkaWVyZXNpcy5zYwl3Z3JhdmUuc2MJeWFjdXRlLnNjDnljaXJjdW1mbGV4LnNjDHlkaWVyZXNpcy5zYwl5Z3JhdmUuc2MJemFjdXRlLnNjCXpjYXJvbi5zYw16ZG90YWNjZW50LnNjBWlqLnNjDWdlcm1hbmRibHMuc2MGZW5nLnNjCGdyYXZlLnNjCGFjdXRlLnNjDWNpcmN1bWZsZXguc2MIY2Fyb24uc2MIdGlsZGUuc2MLZGllcmVzaXMuc2MJbWFjcm9uLnNjCGJyZXZlLnNjB3Jpbmcuc2MPaHVuZ2FydW1sYXV0LnNjDGRvdGFjY2VudC5zYw1leGNsYW1kb3duLnNjD3F1ZXN0aW9uZG93bi5zYwdFdXJvLnNjB2NlbnQuc2MLc3Rlcmxpbmcuc2MJZmxvcmluLnNjBnllbi5zYw5wZXJ0aG91c2FuZC5zYwl6ZXJvLm9udW0Ib25lLm9udW0IdHdvLm9udW0KdGhyZWUub251bQlmb3VyLm9udW0JZml2ZS5vbnVtCHNpeC5vbnVtCnNldmVuLm9udW0KZWlnaHQub251bQluaW5lLm9udW0ObmFwb3N0cm9waGUuc2MOb3JkZmVtaW5pbmUuc2MFZmkuc2MFZmwuc2MAAAAAAf//AAIAAQAAAAwAAABSAAAAAgALAAEACAABAAkACQACAAoAfgABAH8AgAACAIEBCwABAQwBDAACAQ0BywABAcwBzAACAc0B+wABAfwCAAACAgEC2gABAAQAAAACAAAAAAABAAAACgEGAgAAAmN5cmwADmxhdG4AMAAEAAAAAP//AAwAAQADAAQABQAIAAkACgALAAwADQAPABAAIgAFQUZLIABATU9MIABcTkxEIAB2Uk9NIACSVFJLIACwAAD//wAMAAAAAgADAAQABgAIAAoACwAMAA4ADwAQAAD//wALAAIAAwAEAAUACAAKAAsADAAOAA8AEAAA//8ACgADAAQABgAIAAkACgALAAwADwAQAAD//wALAAIAAwAEAAYACAAKAAsADAAOAA8AEAAA//8ADAACAAMABAAGAAgACQAKAAsADAAOAA8AEAAA//8ACwABAAMABAAHAAgACgALAAwADQAPABAAEWFhbHQAaGMyc2MAcGMyc2MAemRub20AhGZyYWMAimxpZ2EAmGxpZ2EAomxpZ2EAqmxudW0AsGxvY2wAtm51bXIAvG9udW0AwnNpbmYAyHNtY3AAznNtY3AA3HN1YnMA6nN1cHMA8AAAAAIAAAABAAAAAwAGAAoADAAAAAMABgAKAAsAAAABABkAAAAFAA0ADgAPABAAEQAAAAMAFQAWABcAAAACABUAFgAAAAEAFgAAAAEAGgAAAAEAAgAAAAEAGAAAAAEACQAAAAEAHAAAAAUAAwAEAAUABgAIAAAABQADAAQABQAGAAcAAAABABsAAAADABIAEwAUACAAQgBKAFIAWgBiAGoAcgB6AIIAigCSAJoAogCqALIAzADUANwA5gDuAPYA/gEGAQ4BFgEeASYBLgE2AT4BRgFOAAEAAAABARQAAwAAAAEDmgABAAAAAQWQAAEAAAABBZYAAQAAAAEHiAABAAAAAQfeAAEAAAABB+wAAQAAAAEH9AABAAAAAQf4AAEAAAABCAIAAQAAAAEIOAABAAAAAQoqAAEAAAABCi4AAQAAAAEKOAAGAAAACgpGCnAKmgrECu4LGAtCC3QLmgvAAAEAAAABC84AAQAAAAEL3AAGAAAAAgvkDAoAAQAAAAEMJgABAAAAAQyIAAEAAAABDKQABAAAAAEMtgAEAAAAAQzQAAQAAAABDPIAAQAAAAENnAABAAAAAQ2kAAEAAAABDawAAQAAAAENtAABAAAAAQ28AAQAAAABDcQABAAAAAEOFAABAAAAAQ4mAAIBSAChAiUCJgInAigCKQIqAjsAbQB9AisCLAItAj0CPgI/AkACQQJCAkMCRQJGAkcCSAJJAksCTAJNAk4CTwJQAlECUgJTAlQCVQIuAjACxQLIAskCywHuAsYCuAJWAlcCWAJZAloCXQJfAmQCaAJpAmoCbAJ4AnkCewJ9AmcCigKMAo0CjgKPApAClAKiAqMCpAKmArACoQKyAlsCXAJeAmACYQJjAmICZQJmAm0CbgJvAnACawJxAnICcwJ0AnYCdwJ8An4CegKAAkQCtwKBAoICdQKDAoUChAKHAoYCiAKLAokCuQKRApICkwKVApYCmAKXApkCmgFDApsCnwKeAqACpQKnAqgCqQKqAqsCrgKxArQCtgK1AsoCnQKfAkUCrwKsAq0CswHuAswB0ALHAdACDwIQAhECEgITAhQCFQIWAhcCGAABAKEABQAIAAkACgAMAA0AIwAlADMAPwBAAEEARgBHAEgASQBKAEsATABOAE8AUABRAFIAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYQBkAGUAZgBoAHAAggCiAKMApAClAKYApwCoAKkAqgCrAKwArQCuAK8AsACxALIAswC0ALUAtgC3ALgAuQC7ALwAvQC+AL8AwADBAMIAxADGAMgAygDMAM4A0ADSANQA1gDYANoA3ADeAOAA4gDkAOYA6ADqAOwA7gDwAPIA9AD2APgA+gD7AP0A/wEBAQMBBQEHAQkBCwEOARABEgEUARYBGAEaARwBHgEgASEBJAEmASgBKgEsAS4BMAEyATQBNgE4AToBPQE/AUEBQgFEAUYBRwG4AboBvAG+AcABzAHQAeIB7wIZAhoCGwIcAh0CHgIfAiACIQIiAAEBsgApAFgAcgCMAJgAngCsALoAyADWAOQA8gEAAQ4BHAEqATABNgE8AUABRAFIAU4BVAFaAWABZgFsAXIBeAF+AYQBigGOAZIBlgGaAZ4BogGmAaoBrgAMAAYACwHCAcMBxQHGAcQBxwHNAc4AbgB+AAwABgALAcIBwwHFAcYBxAHHAc0BzgBuAH4ABQARAHABwAHBAe4AAgIvAdAABgIxAs0CGQAUAdEB2AAGAjICzgIaABUAfAHZAAYCMwLPAhsAFgB1AdoABgI0AtACHAAXAHYB2wAGAjUC0QIdABgB0gHcAAYCNgLSAh4AGQHTAd0ABgI3AtMCHwAaAdQB3gAGAjgC1AIgABsB1QHfAAYCOQLVAiEAHAHWAeAABgI6AtYCIgAdAdcB4QACAjwAbQACAkQCfwACAkoAfQABABYAAQAXAAEAFQACAUQCnAACAs0AFAACAs4AFQAC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AZn/7gGl/+YBpv/mAan/5gHA/+wBwf/sAAYBif/0AYv/5gGQ//QBl//sAZr/6gGu//QADAAQ//QAEv/0AYn/9AGL/+YBkP/0AZf/7AGa/+oBn//sAa7/9AHE//QBx//0Acv/9AAKAYYAEgGJAAwBjAAMAZAACgGXABIBmAASAZoACgGiAB4BrgAKAbMAEgAUABD/zgAR/+IAEv/OAYX/9AGJ//QBiv/sAZD/7AGT/+wBlv/sAZcADAGZ/+wBpf/sAab/7AGp//QBrv/sAcD/4gHB/+IBxP/OAcf/zgHL/84ADAAQ/9wAEv/cAYYADAGJ/+4BkP/oAZcADAGZ//QBogASAa7/6AHE/9wBx//cAcv/3AAGAZD/9AGX/+wBmP/0AZr/7AGu//QBs//0AAoAEf/0AYr/6gGT/+oBlv/qAZn/+gGl/+oBpv/qAan/6gHA//QBwf/0AAYAEAAeABIAHgGJAB4BxAAeAccAHgHLAB4ABgGX/+IBmP/sAZz/9AGz/+wBw//iAcb/4gAGAZf/4gGY/+IBnP/0AbP/4gHD/+IBxv/iAAYBif/0AYv/7gGQ//QBl//sAZr/6gGu//QAEAAQ/7oAEf/OABL/ugGF//QBif/0AYr/9AGQ/+wBk//sAZb/9AGXAAoBmf/0AcD/zgHB/84BxP+6Acf/ugHL/7oABQGX/+IBmP/iAZz/9AHD/+IBxv/iAAcAEf/sAYr/5gGT/+YBlv/mAZn/7gHA/+wBwf/sAAsAEP/cABL/3AGGAAwBif/uAZD/6AGXAAwBmf/0AaIAEgHE/9wBx//cAcv/3AARABD/ugAR/84AEv+6AYX/9AGJ//QBiv/0AZD/7AGT/+wBlv/0AZcACgGZ//QBpv/0AcD/zgHB/84BxP+6Acf/ugHL/7oACQFU/+wBV/+mAWD/pgFr/+gBd/+mAXr/6AGL/+wBl//iAZr/9AAeABD/pgAS/6YAJf+4AC7/lAA4ABIAOgASADsAEgA9ABIARf/iAEf/1gBI/9YASf/WAEv/1gBT/9YAVf/WAIn/pgFe/8QBZf+4AWn/xAFw/8QBhf/iAYn/2AGQ/9gBrv/YAcv/pgI8/74CPv/WAkL/1gJK/9YCTP/WAA4AEP+mABL/pgAl/9AARf/EAEf/xABJ/8QAU//EAFf/0AEV//QCPP+yAj7/xAJK/8QCTv/QAl//xAAPAC4AGAA4/7gAOf/oADr/0AA7/+gAPf/EAE4APABa//QAW//0AF3/9AJFAAoCT//iAlH/9AJS//QCVP/cAB4AEP+mABL/pgAl/7gALv+IADgAEgA6ABIAOwASAD0AEgBF/+IAR//WAEj/1gBJ/9YAS//WAFP/1gBV/9YAif+IAV7/xAFl/7gBaf/EAXD/xAGF/+IBif/YAZD/2AGu/9gBy/+mAjz/sgI+/9YCQv/WAkr/1gJM/9YAAwAQ/4gAEv+IAcv/iAAPAC4ADAA4/7gAOf/oADr/0AA7/9wAPf/EAE4APABa//QAW//0AF3/9AJFAAoCT//iAlH/9AJS//QCVP/cAAkABP/iABH/3ABu/9UBwP/cAcH/3AHC/7gBxf+4Acb/uAHN/9AACAAE/+IAOP/cADr/7gA7/+4APf/oAVf/xAFg/8QBd//EAAgABP/iABD/3AAS/9wAOP/EADr/6AA7/+4APf/cAcv/3AANAHH/4gHD/9YBxv/QAef/xAI+//oCQv/6Akr/+gJM//oCT//oAlD/9AJR/+4CUv/0AlT/4gAEABD/9AAS//QCPP/6AlT/+gAHABH/6AI8//oCPv/0Akr/9AJM//QCT//6Al//7AAJABD/6AAS/+gCPP/6AkX/6AJP/+4CU//iAlT/9AJV//QCX//xAAYAEP+4ABL/uAI8/9YCRf++Akr/9AJf/8QACQAR/+gCPP/6Aj7/6AJC/+gCSv/oAk7/+gJQ//QCVP/0Al//+gAQABH/4gBx/8QBwv/iAcP/4gHF/9YBxv/WAef/xAI+/+gCQv/oAkr/6AJM/+gCT//iAlD/9AJR/9YCUv/WAlT/0AAJABD/6AAS/+gCPP/6AkX/6AJP/+4CUf/6AlP/4gJU/+4CVf/uAAQAEP+sABL/rAI8/9wCX/+1AAMCKgAMAi0ADAIwAAwAAgJO//QCT//0AAsAEP++ABH/4gAS/74BwwAYAcYAGAI8/+gCPv/uAkL/7gJF/74CSv/uAl//vwACAjz/9AJf/+cABwAQ/9AAEv/QAcMAGAHGABgCPP/uAkr/+gJf/90ABQAQ/9wAEv/cAcMAGAHGABgCPP/0AAMAEf/0Aj7/4gJK/+IACwAQ/7IAEf/cABL/sgHDABgBxgAYAjz/4gI+/+4CRf+mAkr/7gJM/+4CX/+/AAECSv/uAAECzQAKAAECzv/sAAEC1P/sAAQAEP+wABH/7AAS/7AC0f/sAAECzv/2AAEAigAEAAwAEAARABIAJQAnACgAKQAqACsALgAvADAAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBFAEYASQBKAEsATwBTAFYAWABaAFsAXABdAF8AZABuAH4AggFSAVMBVAFXAVgBXgFfAWABYQFjAWUBZgFnAWgBaQFrAWwBbwFzAXUBdgF3AXgBeQF6AXsBfgF/AYEBggGDAYYBiAGJAYoBiwGPAZMBlQGWAZcBmAGZAZoBmwGeAZ8BoQGiAaMBpQGmAagBrgGvAbEBswG1AbYBwAHBAcIBwwHEAcUBxgHHAcsBzQHOAjwCPQI+Aj8CQQJGAkcCSgJLAkwCTgJPAlACUQJSAlMCVAJVAs0C0QLTAtQC1QAAAAAAAQAAAADUJJkmAAAAAMu8EwIAAAAAy7wTAg"}];
var __map_reserved = {};
hxGeomAlgo_PolyTools.exposeEnum(hxGeomAlgo_WindingRule);
hxGeomAlgo_PolyTools.exposeEnum(hxGeomAlgo_ResultType);
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
MainWebGL.fl = 420;
MainWebGL.stageRadius = 570;
format_ttf_TableId.BASE = 1111577413;
format_ttf_TableId.CFF = 1128678944;
format_ttf_TableId.DSIG = 1146308935;
format_ttf_TableId.EBDT = 1161970772;
format_ttf_TableId.EBLC = 1161972803;
format_ttf_TableId.EBSC = 1161974595;
format_ttf_TableId.GDEF = 1195656518;
format_ttf_TableId.GPOS = 1196445523;
format_ttf_TableId.GSUB = 1196643650;
format_ttf_TableId.JSTF = 1246975046;
format_ttf_TableId.LTSH = 1280594760;
format_ttf_TableId.MMFX = 1296909912;
format_ttf_TableId.MMSD = 1296913220;
format_ttf_TableId.OS_2 = 1330851634;
format_ttf_TableId.PCLT = 1346587732;
format_ttf_TableId.VDMX = 1447316824;
format_ttf_TableId.cmap = 1668112752;
format_ttf_TableId.cvt = 1668707360;
format_ttf_TableId.fpgm = 1718642541;
format_ttf_TableId.fvar = 1719034226;
format_ttf_TableId.gasp = 1734439792;
format_ttf_TableId.glyf = 1735162214;
format_ttf_TableId.hdmx = 1751412088;
format_ttf_TableId.head = 1751474532;
format_ttf_TableId.hhea = 1751672161;
format_ttf_TableId.hmtx = 1752003704;
format_ttf_TableId.kern = 1801810542;
format_ttf_TableId.loca = 1819239265;
format_ttf_TableId.maxp = 1835104368;
format_ttf_TableId._name = 1851878757;
format_ttf_TableId.prep = 1886545264;
format_ttf_TableId.post = 1886352244;
format_ttf_TableId.vhea = 1986553185;
format_ttf_TableId.vmtx = 1986884728;
format_ttf_CFlag.ARG_1_AND_2_ARE_WORDS = 1;
format_ttf_CFlag.ARGS_ARE_XY_VALUES = 2;
format_ttf_CFlag.ROUND_XY_TO_GRID = 4;
format_ttf_CFlag.WE_HAVE_A_SCALE = 8;
format_ttf_CFlag.MORE_COMPONENTS = 32;
format_ttf_CFlag.WE_HAVE_AN_X_AND_Y_SCALE = 64;
format_ttf_CFlag.WE_HAVE_A_TWO_BY_TWO = 128;
format_ttf_CFlag.WE_HAVE_INSTRUCTIONS = 256;
format_ttf_CFlag.USE_MY_METRICS = 512;
format_ttf_MacGlyphNames.names = [".notdef","quotesingle","zero","semicolon","G","V","grave","o","braceright","Udieresis","egrave","oacute","udieresis","registered","infinity","product","exclamdown","guillemotright","emdash","Ydieresis","middot","Edieresis","Ograve","breve","Scaron","thorn","threequarters"];
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS);
haxe_io_FPHelper.helper = new DataView(new ArrayBuffer(8));
htmlHelper_tools_AnimateTimer.counter = 0;
hxGeomAlgo_HomogCoord.INFINITY = new hxGeomAlgo_HomogCoord();
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.EMPTY = hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(NaN,NaN);
hxGeomAlgo_PolyTools.point = hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new();
hxGeomAlgo_PolyTools.zero = hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(0,0);
hxGeomAlgo_PolyTools.EPSILON = .00000001;
khaMath_Matrix4.width = 4;
khaMath_Matrix4.height = 4;
shaders_Shaders.vertex = "attribute vec3 pos;" + "attribute vec4 color;" + "varying vec4 vcol;" + "uniform mat4 modelViewProjection;" + "void main(void) {" + " gl_Position = modelViewProjection * vec4(pos, 1.0);" + " vcol = color;" + "}";
shaders_Shaders.fragment = "precision mediump float;" + "varying vec4 vcol;" + "void main(void) {" + " gl_FragColor = vcol;" + "}";
trilateral_geom_Algebra.quadStep = 0.03;
trilateral_geom_Algebra.cubicStep = 0.03;
trilateral_geom_Contour.smallDotScale = 0.07;
MainWebGL.main();
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this);

//# sourceMappingURL=trueTypeTrilateralTestWebGL.js.map